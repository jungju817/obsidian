{
	"nodes":[
		{"id":"893aaf353bf0645b","type":"text","text":"# upnp 입력 받는 부분만 ","x":344,"y":259,"width":440,"height":61},
		{"id":"93b5894842a56207","type":"text","text":"# sub_40C330","x":1600,"y":260,"width":250,"height":60},
		{"id":"f100651321b964f0","type":"text","text":"```c\nint __fastcall sub_40C330(int a1, int a2)\n{\n  const char *i; // $s0\n  int v5; // $a0\n  int v6; // $v1\n  int v7; // $a1\n  int *v8; // $v1\n  unsigned int v9; // $s1\n  int v10; // $v0\n  int v11; // $s5\n  int v12; // $v0\n  int v13; // $v0\n  int v14; // $v0\n  const char *v15; // $s1\n  int v16; // $v0\n  int v17; // $v0\n  int v18; // $v0\n  int v19; // $v0\n  int v20; // $v0\n  _DWORD *j; // $s0\n  _DWORD *v22; // $s2\n  int v23; // $a0\n  int v24; // $v0\n  _DWORD *v25; // $v0\n  int v26; // $a0\n  int v27; // $s1\n  int result; // $v0\n  _DWORD *k; // $a0\n  int v30; // $v1\n  _DWORD *v31; // $s0\n  unsigned int v32; // [sp+14h] [-34h]\n  int v33; // [sp+38h] [-10h] BYREF\n  int v34; // [sp+3Ch] [-Ch] BYREF\n  int v35; // [sp+40h] [-8h] BYREF\n\n  for ( i = (const char *)dword_424D30; i; i = *(const char **)i )\n  {\n    v32 = *((_DWORD *)i + 2);\n    syslog(\n      7,\n      \"%s: %p %d %d %d %d\",\n      \"upnpevents_processfds\",\n      i,\n      *((_DWORD *)i + 3),\n      v32,\n      (*(int *)(a1 + 4 * (v32 >> 5)) >> (v32 & 0x1F)) & 1,\n      (*(int *)(a2 + 4 * (v32 >> 5)) >> (v32 & 0x1F)) & 1);\n    v5 = *((_DWORD *)i + 2);\n    if ( v5 >= 0 )\n    {\n      v6 = 4 * ((unsigned int)v5 >> 5);\n      v7 = (*(int *)(a1 + v6) >> (v5 & 0x1F)) & 1;\n      v8 = (int *)(a2 + v6);\n      if ( v7 || ((*v8 >> (v5 & 0x1F)) & 1) != 0 )\n      {\n        v9 = *((_DWORD *)i + 3);\n        if ( v9 == 3 )\n          goto LABEL_36;\n        if ( v9 < 4 )\n        {\n          if ( v9 == 2 )\n          {\n            v34 = 4;\n            v10 = getsockopt(v5, 0xFFFF, 4103, &v35, &v34);\n            v11 = v35;\n            if ( v10 < 0 )\n            {\n              syslog(3, \"%s: getsockopt: %m\", \"upnp_event_process_notify\");\nLABEL_18:\n              *((_DWORD *)i + 3) = 6;\n              continue;\n            }\n            if ( v35 )\n            {\n              *(_DWORD *)_errno_location() = v11;\n              syslog(4, \"%s: connect failed: %m\", \"upnp_event_process_notify\");\n              goto LABEL_18;\n            }\n            v12 = *((_DWORD *)i + 4);\n            if ( v12 )\n            {\n              v13 = *(_DWORD *)(v12 + 20);\n              switch ( v13 )\n              {\n                case 2:\n                  v14 = sub_4058A4(&v33);\n                  break;\n                case 3:\n                  v14 = sub_4058CC(&v33);\n                  break;\n                case 1:\n                  v14 = sub_4058B8(&v33);\n                  break;\n                default:\n                  v15 = 0;\n                  v33 = 0;\nLABEL_28:\n                  *((_DWORD *)i + 6) = 1024;\n                  v16 = malloc(1024);\n                  *((_DWORD *)i + 5) = v16;\n                  if ( !v16 )\n                  {\n                    syslog(3, (const char *)dword_413B14, \"upnp_event_prepare\");\n                    if ( v15 )\n                      free(v15);\n                    goto LABEL_31;\n                  } // i 부근에 입력받은 data 있음\n                  *((_DWORD *)i + 7) = snprintf( // 그리고 v16 chunk에 파싱해서 저장하는듯\n                                         v16,\n                                         1024,\n                                         \"NOTIFY %s HTTP/1.1\\r\\n\"\n                                         \"Host: %s%s\\r\\n\"\n                                         \"Content-Type: text/xml\\r\\n\"\n                                         \"Content-Length: %d\\r\\n\"\n                                         \"NT: upnp:event\\r\\n\"\n                                         \"NTS: upnp:propchange\\r\\n\"\n                                         \"SID: %s\\r\\n\"\n                                         \"SEQ: %u\\r\\n\"\n                                         \"Connection: close\\r\\n\"\n                                         \"Cache-Control: no-cache\\r\\n\"\n                                         \"\\r\\n\"\n                                         \"%.*s\\r\\n\",\n                                         *((const char **)i + 9),\n                                         i + 44,\n                                         i + 92,\n                                         v33 + 2,\n                                         (const char *)(*((_DWORD *)i + 4) + 24),\n                                         *(_DWORD *)(*((_DWORD *)i + 4) + 16),\n                                         v33,\n                                         v15);\n                  if ( v15 )\n                    free(v15);\n                  v17 = 3;\nLABEL_35:\n                  *((_DWORD *)i + 3) = v17;\n                  if ( *((_DWORD *)i + 3) != 3 )\n                    continue;\nLABEL_36:\n                  sub_40BB78(i);\n                  continue;\n              }\n              v15 = (const char *)v14;\n              goto LABEL_28;\n            }\nLABEL_31:\n            v17 = 6;\n            goto LABEL_35;\n          }\n          goto LABEL_43;\n        }\n        if ( v9 != 4 )\n        {\n          if ( v9 == 5 )\n          {\n            close(v5);\n            *((_DWORD *)i + 2) = -1;\n            continue;\n          }\nLABEL_43:\n          syslog(3, \"%s: unknown state\", \"upnp_event_process_notify\");\n          continue;\n        }\n        v18 = recv(v5, *((_DWORD *)i + 5), *((_DWORD *)i + 6), 0);      // recv 함수\n        if ( v18 >= 0 )\n        {\n          syslog(7, \"%s: (%dbytes) %.*s\", \"upnp_event_recv\", v18, v18, *((const char **)i + 5));\n          *((_DWORD *)i + 3) = 5;\n          v20 = *((_DWORD *)i + 4);\n          if ( v20 )\n            ++*(_DWORD *)(v20 + 16);\n        }\n        else\n        {\n          v19 = *(_DWORD *)_errno_location();\n          if ( v19 != 11 && v19 != 4 )\n          {\n            syslog(3, \"%s: recv(): %m\", \"upnp_event_recv\");\n            goto LABEL_18;\n          }\n        }\n      }\n    }\n  }\n  for ( j = (_DWORD *)dword_424D30; j; j = v22 )\n  {\n    v22 = (_DWORD *)*j;\n    if ( (unsigned int)(j[3] - 5) < 2 )\n    {\n      v23 = j[2];\n      if ( v23 >= 0 )\n        close(v23);\n      v24 = j[4];\n      if ( v24 )\n        *(_DWORD *)(v24 + 8) = 0;\n      if ( j[3] == 6 )\n      {\n        v25 = (_DWORD *)j[4];\n        if ( v25 )\n        {\n          if ( *v25 )\n          {\n            *(_DWORD *)(*v25 + 4) = v25[1];\n            v25 = (_DWORD *)j[4];\n          }\n          *(_DWORD *)v25[1] = *v25;\n          free(j[4]);\n        }\n      }\n      v26 = j[5];\n      if ( v26 )\n        free(v26);\n      if ( *j )\n        *(_DWORD *)(*j + 4) = j[1];\n      *(_DWORD *)j[1] = *j;\n      free(j);\n    }\n  }\n  v27 = time(0);\n  result = 4325376;\n  for ( k = (_DWORD *)dword_424D34; k; k = v31 )\n  {\n    v30 = k[3];\n    v31 = (_DWORD *)*k;\n    if ( v30 )\n    {\n      if ( v30 < v27 )\n      {\n        result = k[2];\n        if ( !result )\n        {\n          if ( v31 )\n            v31[1] = k[1];\n          *(_DWORD *)k[1] = *k;\n          result = free(k);\n        }\n      }\n    }\n  }\n  return result;\n}\n```","x":1475,"y":320,"width":925,"height":5780},
		{"id":"d25996bf6078868e","type":"text","text":"","x":1030,"y":500,"width":250,"height":60},
		{"id":"61cdda36d0be847f","x":2640,"y":260,"width":250,"height":60,"type":"text","text":"# sub_403D7C"},
		{"id":"ad0c48391b29174c","x":2560,"y":320,"width":960,"height":15440,"type":"text","text":"```c\nvoid __fastcall sub_403D7C(const char *a1)\n{\n  const char *v1; // $s0\n  int v2; // $a2\n  int v3; // $v0\n  int v4; // $s1\n  int v5; // $v0\n  int v6; // $v0\n  int v7; // $a0\n  int v8; // $s1\n  int v9; // $v0\n  _BYTE *v10; // $v0\n  _BYTE *i; // $v1\n  bool v12; // dc\n  int v13; // $v1\n  int v14; // $v1\n  int v15; // $a0\n  char *v16; // $t0\n  int v17; // $v1\n  int v18; // $a0\n  char *v19; // $t0\n  _DWORD *v20; // $a0\n  int j; // $v1\n  int v22; // $a1\n  _BYTE *v23; // $t0\n  int v24; // $a2\n  const char *v25; // $s2\n  int v26; // $a2\n  int v27; // $s6\n  const char *v28; // $s1\n  int k; // $v0\n  int v30; // $a1\n  int v31; // $v0\n  int v32; // $v0\n  int jj; // $v1\n  int v34; // $v0\n  int v35; // $a2\n  int ii; // $v0\n  int v37; // $v1\n  int v38; // $s6\n  int v39; // $v0\n  int v40; // $v0\n  int n; // $v0\n  int v42; // $v1\n  int v43; // $v0\n  const char *v44; // $s1\n  char *m; // $s1\n  int v46; // $v0\n  char *v47; // $s1\n  int v48; // $a1\n  int v49; // $v1\n  int v50; // $a2\n  void **v51; // $s1\n  int (__fastcall *v52)(int *); // $t9\n  int v53; // $v0\n  int v54; // $s1\n  int v55; // $v0\n  int v56; // $a2\n  int v57; // $s1\n  int v58; // $v0\n  int v59; // $s3\n  int v60; // $s2\n  char *v61; // $v1\n  int v62; // $a0\n  int v63; // $v0\n  unsigned int v64; // $s2\n  char *v65; // $v1\n  unsigned int v66; // $s2\n  int v67; // $a0\n  int v68; // $v1\n  _DWORD *v69; // $a1\n  int v70; // $a2\n  const char *v71; // $s1\n  int v72; // $v0\n  const char *v73; // $a0\n  int v74; // $a1\n  const char *v75; // $a2\n  const char *v76; // $a3\n  int v77; // $v0\n  int v78; // $s1\n  int v79; // $v0\n  int v80; // $v0\n  int v81; // $a0\n  int v82; // $s1\n  int v83; // $v0\n  int v84; // [sp+10h] [-8E0h]\n  char v85[2048]; // [sp+20h] [-8D0h] BYREF\n  char v86[128]; // [sp+820h] [-D0h] BYREF\n  int v87[12]; // [sp+8A0h] [-50h] BYREF\n  char v88[16]; // [sp+8D0h] [-20h] BYREF\n  char v89[16]; // [sp+8E0h] [-10h] BYREF\n\n  v1 = a1;\n  if ( !a1 )\n    return;\n  v2 = *((_DWORD *)a1 + 7);\n  if ( v2 == 1 )\n  {\n    v77 = recv(*(_DWORD *)a1, v85, 2048, 0);\n    v78 = v77;\n    if ( v77 >= 0 )\n    {\n      if ( v77 )\n      {\n        v80 = realloc(*((_DWORD *)v1 + 12), v77 + *((_DWORD *)v1 + 15));\n        if ( v80 )\n        {\n          v81 = *((_DWORD *)v1 + 15);\n          *((_DWORD *)v1 + 12) = v80;\n          memcpy(v80 + v81, v85, v78);\n          v82 = v78 + *((_DWORD *)v1 + 15);\n          v83 = *((_DWORD *)v1 + 17);\n          *((_DWORD *)v1 + 15) = v82;\n          if ( v82 - v83 >= *((_DWORD *)v1 + 16) )\nLABEL_193:\n            sub_403C38(v1);\n          return;\n        }\n        syslog(3, \"memory allocation error %m\");\n      }\n      else\n      {\n        syslog(4, \"HTTP Connection closed inexpectedly\");\n      }\n    }\n    else\n    {\n      v79 = *(_DWORD *)_errno_location();\n      if ( v79 == 11 || v79 == 4 )\n        return;\n      syslog(3, \"recv (state1): %m\");\n    }\nLABEL_13:\n    *((_DWORD *)v1 + 7) = 100;\n    return;\n  }\n  if ( !v2 )\n  {\n    v3 = recv(*(_DWORD *)a1, v85, 2048, 0);\n    v4 = v3;\n    if ( v3 < 0 )\n    {\n      v5 = *(_DWORD *)_errno_location();\n      if ( v5 == 11 || v5 == 4 )\n        return;\n      syslog(3, \"recv (state0): %m\");\n      goto LABEL_13;\n    }\n    if ( !v3 )\n    {\n      syslog(4, \"HTTP Connection closed unexpectedly\");\n      goto LABEL_13;\n    }\n    v6 = realloc(*((_DWORD *)v1 + 12), v3 + *((_DWORD *)v1 + 15) + 1);\n    if ( v6 )\n    {\n      v7 = *((_DWORD *)v1 + 15);\n      *((_DWORD *)v1 + 12) = v6;\n      memcpy(v6 + v7, v85, v4);\n      v8 = v4 + *((_DWORD *)v1 + 15);\n      v9 = *((_DWORD *)v1 + 12);\n      *((_DWORD *)v1 + 15) = v8;\n      *(_BYTE *)(v9 + v8) = 0;\n    }\n    else\n    {\n      syslog(4, \"Unable to allocate new memory for h->req_buf)\");\n      *((_DWORD *)v1 + 7) = 100;\n    }\n    v10 = (_BYTE *)*((_DWORD *)v1 + 12);\n    for ( i = v10; ; ++i )\n    {\n      if ( &v10[*((_DWORD *)v1 + 15)] - i < 4 )\n        return;\n      if ( *i == 13 && i[1] == 10 && i[2] == 13 && i[3] == 10 )\n        break;\n    }\n    v12 = i == 0;\n    v13 = i - v10;\n    if ( v12 )\n      return;\n    *((_DWORD *)v1 + 17) = v13 + 4;\n    if ( !v10 )\n      return;\n    v14 = 0;\n    do\n    {\n      v15 = (char)*v10;\n      if ( v15 == 32 )\n        break;\n      if ( v15 == 13 )\n        break;\n      ++v10;\n      v16 = &v89[v14++];\n      *v16 = v15;\n    }\n    while ( v14 != 15 );\n    v89[v14] = 0;\n    while ( *v10 == 32 )\n      ++v10;\n    v17 = 0;\n    do\n    {\n      v18 = (char)*v10;\n      if ( v18 == 32 )\n        break;\n      if ( v18 == 13 )\n        break;\n      ++v10;\n      v19 = &v86[v17++];\n      *v19 = v18;\n    }\n    while ( v17 != 127 );\n    v85[v17 + 2048] = 0;\n    while ( 1 )\n    {\n      v20 = v1 + 32;\n      if ( *v10 != 32 )\n        break;\n      ++v10;\n    }\n    for ( j = 0; j != 15; ++j )\n    {\n      v22 = (char)v10[j];\n      v23 = (char *)v20 + j;\n      if ( v22 == 13 )\n        break;\n      *v23 = v22;\n    }\n    *((_BYTE *)v20 + j) = 0;\n    syslog(6, \"HTTP REQUEST : %s %s (%s)\", v89, v86, v1 + 32);\n    v25 = (const char *)*((_DWORD *)v1 + 12);\n    if ( v25 && *((int *)v1 + 17) > 0 )\n    {\n      while ( 1 )\n      {\n        v27 = *((_DWORD *)v1 + 12);\n        if ( (unsigned int)v25 >= v27 + *((_DWORD *)v1 + 17) )\n          break;\n        v28 = v25;\n        for ( k = *v25; ; k = *v28 )\n        {\n          v24 = 14;\n          if ( k == 58 )\n            break;\n          if ( k == 13 )\n            goto LABEL_118;\n          ++v28;\n          if ( k == 10 )\n            goto LABEL_118;\n        }\n        if ( strncasecmp(v25, \"Content-Length\", 14) )\n        {\n          if ( strncasecmp(v25, \"SOAPAction\", 10) )\n          {\n            if ( strncasecmp(v25, \"accept-language\", 15) )\n            {\n              if ( strncasecmp(v25, \"expect\", 6) )\n              {\n                if ( strncasecmp(v25, \"Callback\", 8) )\n                {\n                  if ( strncasecmp(v25, \"SID\", 3) )\n                  {\n                    v47 = (char *)(v28 + 1);\n                    if ( !strncasecmp(v25, \"Timeout\", 7) )\n                    {\n                      while ( (*(_WORD *)(_ctype_b + 2 * *v47) & 0x20) != 0 )\n                        ++v47;\n                      if ( !strncasecmp(v47, \"Second-\", 7) )\n                        *((_DWORD *)v1 + 23) = atoi(v47 + 7, v48);\n                    }\n                  }\n                  else\n                  {\n                    for ( m = (char *)(v28 + 1); ; ++m )\n                    {\n                      v46 = *(_WORD *)(_ctype_b + 2 * *m) & 0x20;\n                      if ( !v46 )\n                        break;\n                    }\n                    while ( (*(_WORD *)(_ctype_b + 2 * m[v46]) & 0x20) == 0 )\n                      ++v46;\n                    *((_DWORD *)v1 + 25) = v46;\n                    *((_DWORD *)v1 + 24) = &m[-v27];\n                  }\n                }\n                else\n                {\n                  while ( 1 )\n                  {\n                    v40 = *v28;\n                    if ( v40 == 60 )\n                      break;\n                    v12 = v40 == 13;\n                    n = 0;\n                    if ( v12 )\n                      break;\n                    ++v28;\n                  }\n                  for ( n = 0; ; ++n )\n                  {\n                    v42 = v28[n];\n                    if ( v42 == 62 || v42 == 13 )\n                      break;\n                  }\n                  v43 = n - 1;\n                  v44 = v28 + 1;\n                  if ( v43 < 0 )\n                    v43 = 0;\n                  *((_DWORD *)v1 + 21) = &v44[-v27];\n                  *((_DWORD *)v1 + 22) = v43;\n                }\n              }\n              else\n              {\n                while ( 1 )\n                {\n                  v39 = *v28;\n                  if ( v39 != 58 && v39 != 32 && v39 != 9 )\n                    break;\n                  ++v28;\n                }\n                if ( !strncasecmp(v28, \"100-continue\", 12) )\n                {\n                  *((_DWORD *)v1 + 27) |= 0x40u;\n                  syslog(7, \"\\\"Expect: 100-Continue\\\" header detected\");\n                }\n              }\n            }\n            else\n            {\n              while ( 1 )\n              {\n                v34 = *v28;\n                if ( v34 != 58 && v34 != 32 )\n                {\n                  v35 = 0;\n                  if ( v34 != 9 )\n                    break;\n                }\n                ++v28;\n              }\n              while ( v28[v35] >= 32 )\n                ++v35;\n              syslog(7, \"accept-language HTTP header : '%.*s'\", v35, v28);\n              for ( ii = 0; ; ++ii )\n              {\n                v37 = v28[ii];\n                v38 = 7;\n                if ( v37 < 33 || v37 == 44 )\n                  break;\n              }\n              if ( ii < 8 )\n                v38 = ii;\n              memcpy(v1 + 52, v28, v38);\n              v1[v38 + 52] = 0;\n            }\n          }\n          else\n          {\n            while ( 1 )\n            {\n              v32 = *v28;\n              if ( v32 != 58 && v32 != 32 && v32 != 9 )\n                break;\n              ++v28;\n            }\n            for ( jj = 0; v28[jj] >= 32; ++jj )\n              ;\n            if ( (v32 == 34 || v32 == 39) && v28[jj - 1] == v32 )\n            {\n              ++v28;\n              jj -= 2;\n            }\n            *((_DWORD *)v1 + 20) = jj;\n            *((_DWORD *)v1 + 19) = &v28[-v27];\n          }\n        }\n        else\n        {\n          while ( (unsigned __int8)(*v28 - 48) >= 0xAu )\n            ++v28;\n          v31 = atoi(v28, v30);\n          *((_DWORD *)v1 + 16) = v31;\n          if ( v31 < 0 )\n          {\n            syslog(4, \"ParseHttpHeaders() invalid Content-Length %d\", v31);\n            *((_DWORD *)v1 + 16) = 0;\n          }\n        }\n        do\n        {\nLABEL_118:\n          while ( *v25 != 13 )\n            ++v25;\n          v49 = *++v25;\n        }\n        while ( v49 != 10 );\n        ++v25;\n      }\n    }\n    if ( !strcmp(\"POST\", v89, v24) )\n    {\n      *((_DWORD *)v1 + 18) = 2;\n      goto LABEL_193;\n    }\n    if ( !strcmp(\"GET\", v89, v26) )\n    {\n      v51 = &off_40FC3C;\n      *((_DWORD *)v1 + 18) = 1;\n      while ( *v51 )\n      {\n        if ( !strcasecmp(*v51, v86) )\n        {\n          v52 = (int (__fastcall *)(int *))v51[1];\n          if ( v52 )\n          {\n            v53 = v52(v87);\n            v54 = v53;\n            if ( v53 )\n            {\n              sub_403A6C(v1, v53, v87[0]);\n            }\n            else\n            {\n              syslog(3, \"Failed to generate XML description\");\n              *((_DWORD *)v1 + 27) = 128;\n              sub_403A04(\n                v1,\n                500,\n                \"Internal Server Error\",\n                \"<HTML><HEAD><TITLE>Error 500</TITLE></HEAD><BODY>Internal Server Error</BODY></HTML>\\r\\n\",\n                86);\n            }\n            sub_403B5C(v1);\n            free(v54);\n            return;\n          }\n        }\n        v51 += 2;\n      }\n      v12 = memcmp(v86, \"/ctl/\", 5) == 0;\n      v55 = 384;\n      if ( !v12 && (v12 = memcmp(v86, \"/evt/\", 5) != 0, v55 = 640, v12) )\n      {\n        syslog(5, \"%s not found, responding ERROR 404\", v86);\n        *((_DWORD *)v1 + 27) = 128;\n        sub_403A04(\n          v1,\n          404,\n          \"Not Found\",\n          \"<HTML><HEAD><TITLE>404 Not Found</TITLE></HEAD><BODY><H1>Not Found</H1>The requested URL was not found on this\"\n          \" server.</BODY></HTML>\\r\\n\",\n          134);\n      }\n      else\n      {\n        *((_DWORD *)v1 + 27) = v55;\n        sub_403A04(\n          v1,\n          405,\n          \"Method Not Allowed\",\n          \"<HTML><HEAD><TITLE>405 Method Not Allowed</TITLE></HEAD><BODY><H1>Method Not Allowed</H1>The HTTP Method is no\"\n          \"t allowed on this resource.</BODY></HTML>\\r\\n\",\n          153);\n      }\n      goto LABEL_183;\n    }\n    if ( strcmp(\"SUBSCRIBE\", v89, v50) )\n    {\n      if ( strcmp(\"UNSUBSCRIBE\", v89, v56) )\n      {\n        syslog(5, \"Unsupported HTTP Command %s\", v89);\n        *((_DWORD *)v1 + 27) = 128;\n        v74 = 501;\n        v75 = \"Not Implemented\";\n        v76 = \"<HTML><HEAD><TITLE>501 Not Implemented</TITLE></HEAD><BODY><H1>Not Implemented</H1>The HTTP Method is not \"\n              \"implemented by this server.</BODY></HTML>\\r\\n\";\n        v84 = 149;\n        v73 = v1;\n        goto LABEL_182;\n      }\n      *((_DWORD *)v1 + 18) = 4;\n      syslog(7, \"ProcessHTTPUnSubscribe %s\", v86);\n      syslog(7, \"SID '%.*s'\", *((_DWORD *)v1 + 25), (const char *)(*((_DWORD *)v1 + 12) + *((_DWORD *)v1 + 24)));\n      if ( sub_40BEE4(*((_DWORD *)v1 + 12) + *((_DWORD *)v1 + 24), *((_DWORD *)v1 + 25)) < 0 )\n      {\n        v84 = 0;\n        goto LABEL_174;\n      }\n      goto LABEL_176;\n    }\n    *((_DWORD *)v1 + 18) = 3;\n    syslog(7, \"ProcessHTTPSubscribe %s\", v86);\n    syslog(\n      7,\n      \"Callback '%.*s' Timeout=%d\",\n      *((_DWORD *)v1 + 22),\n      (const char *)(*((_DWORD *)v1 + 12) + *((_DWORD *)v1 + 21)),\n      *((_DWORD *)v1 + 23));\n    syslog(7, \"SID '%.*s'\", *((_DWORD *)v1 + 25), (const char *)(*((_DWORD *)v1 + 12) + *((_DWORD *)v1 + 24)));\n    v57 = *((_DWORD *)v1 + 21);\n    if ( v57 <= 0 )\n    {\n      v58 = *((_DWORD *)v1 + 24);\n      if ( v58 <= 0 )\n      {\n        v84 = 0;\nLABEL_174:\n        v73 = v1;\n        v74 = 412;\n        v75 = \"Precondition Failed\";\n        v76 = 0;\nLABEL_182:\n        sub_403A04(v73, v74, v75, v76, v84);\nLABEL_183:\n        a1 = v1;\nLABEL_177:\n        sub_403B5C(a1);\n        return;\n      }\n      if ( sub_40BE3C(*((_DWORD *)v1 + 12) + v58, *((_DWORD *)v1 + 25), *((_DWORD *)v1 + 23)) < 0 )\n      {\nLABEL_173:\n        v84 = 0;\n        goto LABEL_174;\n      }\n      *((_DWORD *)v1 + 27) = 1;\nLABEL_176:\n      sub_403A6C(v1, 0, 0);\n      a1 = v1;\n      goto LABEL_177;\n    }\n    v59 = *((_DWORD *)v1 + 22);\n    if ( v59 >= 8 )\n    {\n      v60 = *((_DWORD *)v1 + 12);\n      if ( !memcmp(v60 + v57, \"http://\", 7) )\n      {\n        v61 = (char *)(v60 + v57 + 7);\n        v62 = *v61;\n        v63 = 0;\n        if ( v62 == 91 )\n        {\n          v65 = v61 + 1;\n          v66 = v60 + v59 + v57;\n          while ( 1 )\n          {\n            v67 = *v65;\n            if ( v67 == 93 || v63 == 47 || (unsigned int)v65 >= v66 )\n              break;\n            ++v63;\n            ++v65;\n            *((_BYTE *)v87 + v63 - 1) = v67;\n          }\n          v68 = 1;\n        }\n        else\n        {\n          v64 = v60 + v59 + v57;\n          while ( 1 )\n          {\n            if ( v62 == 47 )\n            {\n              v68 = 0;\n              goto LABEL_156;\n            }\n            if ( v62 == 58 || v63 == 47 || (unsigned int)v61 >= v64 )\n              break;\n            ++v63;\n            ++v61;\n            *((_BYTE *)v87 + v63 - 1) = v62;\n            v62 = *v61;\n          }\n          v68 = 0;\n        }\nLABEL_156:\n        *((_BYTE *)v87 + v63) = 0;\n        if ( v68 )\n        {\n          if ( inet_pton(10, v87, v88) <= 0 || !*((_DWORD *)v1 + 2) )\n            goto LABEL_171;\n          v69 = v1 + 12;\n          v70 = 16;\n        }\n        else\n        {\n          if ( inet_pton(2, v87, v88) <= 0 )\n            goto LABEL_171;\n          if ( *((_DWORD *)v1 + 2) )\n          {\n            if ( *((_DWORD *)v1 + 3) || *((_DWORD *)v1 + 4) || *((_DWORD *)v1 + 5) != 0xFFFF )\n              goto LABEL_171;\n            v69 = v1 + 24;\n          }\n          else\n          {\n            v69 = v1 + 4;\n          }\n          v70 = 4;\n        }\n        if ( !memcmp(v88, v69, v70) )\n        {\n          v71 = (const char *)sub_40BCA0(\n                                v86,\n                                *((_DWORD *)v1 + 12) + *((_DWORD *)v1 + 21),\n                                *((_DWORD *)v1 + 22),\n                                *((_DWORD *)v1 + 23));\n          *((_DWORD *)v1 + 27) = 1;\n          if ( v71 )\n          {\n            syslog(7, \"generated sid=%s\", v71);\n            v72 = *((_DWORD *)v1 + 27);\n            *((_DWORD *)v1 + 26) = v71;\n            *((_DWORD *)v1 + 27) = v72 | 2;\n          }\n          goto LABEL_176;\n        }\n      }\n    }\nLABEL_171:\n    syslog(\n      4,\n      \"Invalid Callback in SUBSCRIBE %.*s\",\n      *((_DWORD *)v1 + 22),\n      (const char *)(*((_DWORD *)v1 + 12) + *((_DWORD *)v1 + 21)));\n    goto LABEL_173;\n  }\n  if ( v2 != 2 )\n  {\n    if ( v2 != 3 )\n    {\n      syslog(4, \"Unexpected state: %d\", v2);\n      return;\n    }\n    goto LABEL_177;\n  }\n  if ( sub_403A98() )\n    *((_DWORD *)v1 + 7) = 1;\n}\n```"},
		{"id":"4de6a43ee28b788c","x":1031,"y":1320,"width":250,"height":60,"type":"text","text":""},
		{"id":"843883385c9e5c16","type":"text","text":"```c\n\n      v122 = v74;\n      sub_40C008(v115, v114, &v122, v71); // v115, v114가 read,write fd 이고 v122가 max fd\n      if ( select(v122 + 1, v115, v114, 0, &v119) >= 0 ) // select 하는 곳, select은 연결된 client 들 중 특정 client가 데이터를 보내면 이를 감지함\n      { // if(1) 여기서 부터\n        v62 = 0;\n        sub_40C330(v115, v114);                            // recv 받는 곳 \n        while ( v62 < v45 )\n        {\n          v86 = *(_DWORD *)(v47 + 4 * v62);\n          if ( v86 >= 0 && ((v115[(unsigned int)v86 >> 5] >> v86) & 1) != 0 )\n            sub_40B2CC(); // NAT-PMP 요청을 처리하는 함수\n          ++v62;\n        }\n        if ( v57 >= 0 )\n        {\n          v61 = (int *)v125;\n          if ( (v134 & v132[64]) != 0 )\n            sub_40AA7C(v57, v125 & 0xFFFF); // udp 소켓으로부터 데이터를 받아들이고 처리\n        }\n        if ( v58 >= 0 && (v140 & v115[v139]) != 0 )\n        {\n          syslog(6, \"Received UDP Packet (IPv6)\");\n          sub_40AA7C(v58, v125 & 0xFFFF); // udp 소켓으로부터 데이터를 받아들이고 처리 (IPv6 로그 남김)\n        }\n        if ( v53 >= 0 && (v136 & v115[v135]) != 0 )\n        {\n          sub_40CF80(v53); // 네트워크 인터페이스 관련 정보 수신, 처리 \n          v63 = (int *)v123;\n        }\n        else\n        {\n          v63 = (int *)v123;\n        }\n        while ( v63 )\n        {\n          if ( *v63 >= 0 )\n          {\n            v61 = &v108;\n            v87 = *v63 & 0x1F;\n            v88 = &v108 + ((unsigned int)*v63 >> 5);\n            if ( ((v88[64] >> v87) & 1) != 0 || ((v88[32] >> v87) & 1) != 0 )\n              sub_403D7C(v63);      // recv 받는 곳, v63 은 fd임\n          }\n          v63 = (int *)v63[32];\n        }\n        if ( v55 == -1 )\n          goto LABEL_221;\n        v64 = v123;\n        if ( (v138 & v115[v137]) == 0 )\n        {\nLABEL_222:\n          while ( v64 )\n          {\n            v96 = (unsigned int *)v64[32];\n            if ( v64[7] >= 0x64 )\n            {\n              if ( v96 )\n                v96[33] = v64[33];\n              *(_DWORD *)v64[33] = v64[32];\n              sub_4036B0();         // close 하는 함수\n            }\n            v64 = v96;\n          }\n          continue;                 // continue\n        }\n        v121 = 128;\n        v89 = accept(v55, &v108, &v121, v61);      //accept 받는 곳 \n        if ( v89 < 0 )                     // accept 에러 처리\n        {\n          v90 = *(_DWORD *)_errno_location();\n          if ( v90 != 11 && v90 != 4 )\n          {\n            syslog(3, \"accept(http): %m\");\nLABEL_336:\n            v64 = v123;\n            goto LABEL_222;\n          }\nLABEL_221:\n          v64 = v123;\n          goto LABEL_222;\n        }\n        sub_40C830(&v108, v116, 64);      // address 를 v116에 저장하는 \n        syslog(6, \"HTTP connection from %s\", v116);\n        if ( !sub_40C948(&v108) )  // lan 아니면 분기되는듯\n        {\n          syslog(4, \"HTTP peer %s is not from a LAN, closing the connection\", v116);\nLABEL_335:\n          close(v89);\n          goto LABEL_336;\n        }\n        v91 = (unsigned int *)sub_4035E0(v89, 4259840);    // 논 블로킹 하는 함수인듯\n        if ( !v91 )\n        {\n          syslog(3, \"New_upnphttp() failed\");\n          goto LABEL_335;\n        }\n        if ( HIWORD(v108) == 2 )\n        {\n          v91[1] = v109;\n        }\n        else\n        {\n          v92 = (int)v123;\n          if ( HIWORD(v108) != 10 )\n          {\nLABEL_331:\n            v91[32] = v92;\n            if ( v92 )\n              *(_DWORD *)(v92 + 132) = v91 + 32;\n            v123 = v91;\n            v91[33] = (unsigned int)&v123;\n            goto LABEL_221;\n          }\n          if ( v110 || v111 || v112 != 0xFFFF )\n          {\n            v93 = v91 + 3;\n            v94 = &v110;\n            v95 = 16;\n            v91[2] = 1;\n          }\n          else\n          {\n            v93 = v91 + 1;\n            v94 = v113;\n            v95 = 4;\n          }\n          memcpy(v93, v94, v95);\n        }\n        v92 = (int)v123;\n        goto LABEL_331;\n      } // if(1) 여기까지 \n      break;\n    }\n    // ------------------ 여기 아래 부터는 소켓 및 자원 정리 부분이다. -----------------------\n    v76 = (int)v123;\n    if ( dword_424C64 )\n    {\n      while ( v76 )\n      {\n        v97 = *(_DWORD *)(v76 + 128);\n        if ( v97 )\n          *(_DWORD *)(v97 + 132) = *(_DWORD *)(v76 + 132);\n        **(_DWORD **)(v76 + 132) = *(_DWORD *)(v76 + 128);\n        sub_4036B0();\nLABEL_345:\n        v76 = (int)v123;\n      }\n      if ( v57 >= 0 )\n        close(v57);\n      if ( v55 != -1 )\n        close(v55);\n      if ( v58 >= 0 )\n        close(v58);\n      v98 = 0;\n      if ( v53 >= 0 )\n      {\n        close(v53);\n        v98 = 0;\n      }\n      v99 = (_DWORD *)v47;\n      while ( v98 < v45 )\n      {\n        if ( (int)*v99 >= 0 )\n        {\n          close(*v99);\n          *v99 = -1;\n        }\n        ++v98;\n        ++v99;\n      }\n      v100 = 2 * v45;\n      if ( (dword_424D04 & 0x20) != 0 )\n      {\n        v102 = 0;\n        if ( sub_40AB28(v126, 2 * v45) < 0 )\n        {\n          syslog(3, \"Failed to broadcast good-bye notifications\");\n          v102 = 0;\n        }\n        for ( n = v100 > 0; n; n = v102 < v100 )\n        {\n          v104 = 4 * v102++;\n          close(*(_DWORD *)(v126 + v104));\n        }\n      }\n      if ( off_424BDC )\n      {\n        v105 = unlink(off_424BDC);\n        v101 = dword_424CB4;\n        if ( v105 < 0 )\n        {\n          syslog(3, \"Failed to remove pidfile %s: %m\", off_424BDC);\n          v101 = dword_424CB4;\n        }\n      }\n      else\n      {\n        v101 = dword_424CB4;\n      }\n      while ( v101 )\n      {\n        v106 = *(_DWORD *)(v101 + 44);\n        if ( v106 )\n          *(_DWORD *)(v106 + 48) = *(_DWORD *)(v101 + 48);\n        **(_DWORD **)(v101 + 48) = *(_DWORD *)(v101 + 44);\n        free(v101);\n        v101 = dword_424CB4;\n      }\n      free(v47);\n      free(v126);\n      closelog();\n      sub_4093D4();\n      return (int)v124;\n    }\n  }\n  while ( *(_DWORD *)_errno_location() == 4 );\n  syslog(3, \"select(all): %m\");\n  syslog(3, \"Failed to select open sockets. EXITING\");\n  return 1;\n}\n```","x":-152,"y":320,"width":1433,"height":5280},
		{"id":"cadf3d410385375c","x":1239,"y":-140,"width":250,"height":60,"type":"text","text":"memcpy : 존나 안전함"},
		{"id":"e78026fb4f328cb6","x":1080,"y":6204,"width":346,"height":60,"type":"text","text":"싯팔 존나 안전한 코드인데?"}
	],
	"edges":[
		{"id":"7836cb4f496d45a8","fromNode":"d25996bf6078868e","fromSide":"right","toNode":"93b5894842a56207","toSide":"left"},
		{"id":"a6f289346fd35f36","fromNode":"4de6a43ee28b788c","fromSide":"right","toNode":"61cdda36d0be847f","toSide":"left"}
	]
}