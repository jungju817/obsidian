{
	"nodes":[
		{"id":"38d02793c9646d4d","type":"text","text":"# 주제 : AFL++: Combining Incremental Steps of Fuzzing Research","x":-280,"y":-120,"width":1080,"height":80},
		{"id":"df5a86a41b99a02f","type":"text","text":"Fuzzing은 우리가 직접 손으로는 할 수 없는 매우 많은 유용한 테스트를 한다. 이는 복잡한 입력을 처리하는 프로그램에 매우 효과적이다. 그리고 parser가 있는 프로그램은 fuzz하기 좋은 후보이다. 예를 들면 images libraries, PDF readers, compilers, system utils(readelf나 objdump), HTTP servers, etc...\n\np. 8","x":-280,"y":498,"width":840,"height":162,"color":"2"},
		{"id":"02de7dff04174f4f","type":"text","text":"### White-Box Fuzzing\nwhite box fuzzer는 프로그램 분석을 하여 탐색 횟수를 최대화 하다.\n일반적으로 사용된 분석은 symbolic execution이다.(like in SAGE \\[1]) \n우리는 code의 critical portion에 도달할 가능성을 높이기 위해 탐색되는 경로의 수를 최대화 하는 것에 관심이 있다.\n이 접근 방식은 다른 비슷한 fuzzer에서도 흔하며 일반적으로 우리는 \"더 많은 code coverage는 좋다\" 는 것만 알아두자.\n\np. 9","x":-880,"y":801,"width":640,"height":359},
		{"id":"cc8a6d7e843b1dfb","type":"text","text":"### Grey-Box Fuzzing\ngrey box fuzzer는 정보를 얻기 위해 소스코드나 바이너러의 프로그램 계측을 사용한다.\n일반적으로 이 정보는 code coverage에 연관된다. 그러나 다른 분석 방법도 사용될 수 있다. fuzzer에 도움이 되는 유용한 정보를 위해 계측기를 사용하는 분석이 있다. (CompCov\\[3], Vuzzer\\[4], Angora\\[5])\n\n여기서는 가장 인기있는 grey-box coverage-guided fuzzer인 American Fuzzy Lop에 중점을 둘 것이다.\n\np. 11","x":-200,"y":801,"width":680,"height":399},
		{"id":"dae874f42c7b8919","type":"text","text":"### Black-Box Fuzzing\nBlack box fuzzer는 target program 구조를 알지 못한다. 마치 dumb bash fuzzed 가 이전에 보여준것 혹은 진짜 fuzzer인 Radamsa\\[2]와 비슷하다. \nheuristics을 기반으로한 output에 대한 input의 연관성을 이용한 smart black-box fuzzer가 있다.\n이러한 방법으로 fuzzer는 프로그램 구조에 대한 몇가지 정보를 알 수 있다.\n\np.10","x":520,"y":800,"width":640,"height":340},
		{"id":"06eadf9f49c12016","type":"file","file":"toor/picture/Pasted image 20231111174538.png","x":1760,"y":3320,"width":640,"height":548},
		{"id":"58530c47b4c14cd7","type":"file","file":"toor/picture/Pasted image 20231111174514.png","x":1760,"y":2788,"width":640,"height":412},
		{"id":"723e8aaf6f3ebad4","type":"file","file":"toor/picture/Pasted image 20231111183227.png","x":2880,"y":2520,"width":880,"height":396},
		{"id":"08f8a2263c13f249","type":"file","file":"toor/picture/Pasted image 20231111183307.png","x":2720,"y":2973,"width":880,"height":389},
		{"id":"cc9eec796de8c58b","type":"file","file":"toor/picture/Pasted image 20231111183353.png","x":2800,"y":3396,"width":880,"height":394},
		{"id":"92213d2d60138dc3","type":"file","file":"toor/picture/Pasted image 20231111183637.png","x":2880,"y":3842,"width":880,"height":392},
		{"id":"a8ede895e5dec0ef","type":"file","file":"toor/picture/Pasted image 20231111183833.png","x":2720,"y":4282,"width":859,"height":298},
		{"id":"217b3b28cd099f19","type":"file","file":"toor/picture/Pasted image 20231111222119.png","x":1520,"y":3920,"width":985,"height":816},
		{"id":"bb85d7b6000a7c78","type":"text","text":"Heuristics : 발견법, 경험에 기반하여 문제를 해결하거나 학습하거나 발견해 내는 방법","x":-1080,"y":2581,"width":315,"height":105},
		{"id":"a939ae6ade3c443e","type":"text","text":"whitepaper : 공식 기술 문서","x":-1080,"y":2720,"width":315,"height":60},
		{"id":"6220ab3d472fa0f2","type":"text","text":"trimming : 다듬기 == 입력 데이터의 크기 줄이기","x":-880,"y":7403,"width":491,"height":50},
		{"id":"5a3af1928ea0f645","type":"text","text":"### Symbolic Execution(심볼릭 실행)이란?\nsymbolic execution은 구체적인 입력값을 가지고 프로그램을 실행하는 것이 아닌 기호를 사용하여 프로그램을 실행하는 기법이다. 즉 입력값을 모르는 상태로 기호로 표현한다는 의미이다.\n```c\nvoid foo(int x){\n\tint i = 10;\n\tif(x > 0)\n\t\ti = x;\n\telse\n\t\ti = -x;\n}\n```\n","x":-1560,"y":768,"width":520,"height":432},
		{"id":"3a300778e8a58232","type":"text","text":"계측 코드 삽입을 위해 register를 저장한다.","x":3800,"y":2688,"width":265,"height":100},
		{"id":"2d15cce6082d0ec5","type":"text","text":"register를 다시 복원한다.","x":3770,"y":3563,"width":295,"height":50},
		{"id":"519ec65d30eaa00c","type":"text","text":"\\_\\_afl_maybe_log에서는 \\_\\_afl_setup으로 jump하고 \\_\\_afl_setup 에서는 \\_\\_afl_setup_first로 jump한다.(AFL 초기화 코드)\n그리고 \\_\\_afl_store로 jump 한다.","x":3860,"y":3960,"width":420,"height":160},
		{"id":"dd49b6ecac47e56b","type":"text","text":"\\_\\_afl_store 에서는 rcx의 값을 \\_\\_afl_prev_loc에 넣고 >> 1 한다.\n그리고 rdx+rcx가 위치한 곳에 1을 더한다.\n","x":3660,"y":4375,"width":405,"height":145},
		{"id":"72e30b4da58405c6","type":"text","text":"rcx에는<compile_time_random>을 넣고 \\_\\_afl_maybe_log를 호출한다.","x":3680,"y":3140,"width":385,"height":122},
		{"id":"d0101f7a1e1d0b7a","type":"text","text":"### Fuzzing이란?\n\nFrom Wikipedia : \nFuzzing 또는 Fuzz testing은 자동화된 소프트웨어 테스트 기법으로 잘못되거나, 예상치못한, 혹은 랜덤 데이터를 컴퓨터 프로그램에 입력하는 것을 포함한다.\n\nFuzzer를 이용해 무엇을 할 수 있나? :\nbug를 유발하는 input을 찾을 수 있다.\n\nFuzzer를 이용해서 할 수 없는것은? : \nfuzz된 소프트웨어가 버그가 없다고 증명을 할 수는 없다.\n즉 fuzz test에서 통과했다고 버그가 없다고 증명할 수는 없다.\n\np. 5","x":-160,"y":0,"width":840,"height":440,"color":"1"},
		{"id":"8f8345ae12858a65","type":"text","text":"# 논문 요약","x":155,"y":-280,"width":210,"height":80},
		{"id":"49b4099e4d49f2f3","type":"text","text":"### Funky hybrid stuffs\nhybrid fuzzing의 접근 방식은 fuzzer가  막혔을 때 symbolic tracing을 적용하는 것이다.\n일반적인 아이디어는 구체적인 입력이 주어졌을 때 해당 경로와 관련된 제약 조건을 수집하고 새로운 상태 전이를 생성할 수 있는 분기가 만나면 해당 제약 조건을 부정하여 해당 분기를 우회할 수 있는 입력을 얻는 것이다.\n이러한 방식은 concolic execution의 재등장을 의미한다.\n\n더 많은 정보는 UCSB의 Driller \\[10] paper\n또 다른 최근의 promising tool은 Georgia Tech 의 QSYM\\[11]\n\np. 15","x":720,"y":1829,"width":840,"height":408},
		{"id":"7ca027b3bd4bb0c9","type":"text","text":"### Input structure awareness\n\n이러한 구분을 넘어서 fuzzer는 입력 구조에 대해 알고 있거나 그렇지 않을 수 있다.  가장 유명한 input-aware fuzzer는 Peach\\[6]이다.\nPeach를 사용하면 XML 모델을 사용하여 입력 구조를 설명하고, 그런 다음 퍼저가 이에 따라 test case를 생성한다.\n최근에 나온 AFL의 변형인 AFLSmart\\[7]는 American Fuzzy Lop과 Peach를 결합하여 사용하는 방법과 작동방식 살펴보자\n\np. 12","x":-280,"y":1277,"width":840,"height":323},
		{"id":"792d7993dbf83354","type":"file","file":"toor/picture/Pasted image 20231114154653.png","x":-1510,"y":1469,"width":420,"height":377},
		{"id":"e40473d6fbc4c026","type":"text","text":"### Other notable fuzzers\n다른 주목할만한 grey-box coverage 기반의 퍼징 도구는 다음이 있다.\n- LLVM libFuzzer\\[8] : LLVM 툴체인에서 제공하는 fuzzer이다.\n- Google honggfuzz\\[9] : 강력한 feedback 기반 fuzzer로 (커버리지 뿐만 아니라 카운팅도 포함) 하드웨어 기반 엔진을 사용한다. 이는 인텔 프로세서에서 노출된 여러 하드웨어 시설을 활용하여 정보를 얻을 수 있다.\n\np. 13","x":-280,"y":1657,"width":840,"height":343},
		{"id":"dc205d813a85cd0c","type":"text","text":"### AFL 이란?\nAmerican Fuzzy Lop은 가장 인기 있는 fuzzer 중 하나이다. 이는 OpenSSH, PHP, MySQL, Firefox 등과 같이 매우 퍼져있는 소프트웨에서 중요한 취약점을 발견하는 데 사용되었다. 이는 edge coverage를 기반으로 한 피드백을 사용한다.\n\nbasic code coverage log는 기본 블록이 실행된 내용을 보여준다. (예, A B C),\nedge code coverage log는 기본 블록간의 전환을 보여준다.(예, A->C A->B),\n이러한 전환은 튜플로 참조된다. (예, A->C는 (A,C)로 표시된다.)\n\np. 18","x":-280,"y":2526,"width":840,"height":374},
		{"id":"ac1702efc34a79ff","type":"text","text":"계측 코드의 역할은 edge coverage의 측정과 hit counts 를 측정한다.","x":277,"y":3154,"width":281,"height":66},
		{"id":"66ac3df4d262b36a","type":"text","text":"block을 구분 짓는 기준은 jmp 혹은 call로 보면 될 것 같다. ida가 구분짓는 거랑 비슷한 듯","x":-433,"y":2428,"width":453,"height":98},
		{"id":"7556a0619716e27a","type":"file","file":"toor/picture/Pasted image 20231111173146.png","x":800,"y":2270,"width":640,"height":364},
		{"id":"74ed50c2a3d31790","type":"file","file":"toor/picture/Pasted image 20231111173217.png","x":800,"y":2666,"width":640,"height":366},
		{"id":"0f539b9bae3111ec","type":"text","text":"### AFL Instrumentation\n\nAFL의 whitepaper\\[12]에서 가져온 예시이다.\n```\ncur_location = <COMPILE_TIME_RANDOM>; \nshared_mem[cur_location ^ prev_location]++; \nprev_location = cur_location >> 1;\n```\n\n여기서 shared_mem은 fuzzer와 기기화된 대상 프로그램 간에 공유되는 64KB의 SHM이다. 충돌이 가능하다.\n\np. 21","x":-280,"y":2978,"width":840,"height":400},
		{"id":"539bf5e4b99eb3cd","type":"text","text":"### AFL Queue Evaluation\n우리는 입력이 큐에 오직 추가되고 제거되지는 않는다고 했기 때문에 가장 최근의 입력 중 하나의 edge coverage가 이전 입력의 coverage의 superset인 경우가 발생할 수 있다.\n그러나 AFL은 멍청하지 않다. 주기적으로 큐에 있는 test case를 평가한다. 실행 대기 시간과 파일 크기에 비례하는 점수를 할당하고, 그런 다음 각 튜플에 대해 가장 낮은 점수를 가진 test case를 선택한다.\n\np. 34","x":-278,"y":4565,"width":840,"height":292},
		{"id":"29ef691a3031969a","type":"text","text":"superset : 상위 집합, 즉 최근의 coverage가 이전의 coverage를 모두 포함한다는 의미이다.","x":-678,"y":4575,"width":315,"height":104},
		{"id":"c78be5a7a4793449","type":"text","text":"virgin_bits와 비교하여 fuzzer는 입력이 새로운 로컬 상태를 유발하는지 여부를 알 수 있으며, 그렇다면 해당 입력은 나중에 추가 처리를 위해 큐에 삽입되고, virgin_bits가 업데이트된다.\n\np. 29","x":-278,"y":3869,"width":840,"height":131},
		{"id":"d714059d1409dc07","type":"file","file":"toor/picture/Pasted image 20231111184407.png","x":-278,"y":3739,"width":838,"height":130},
		{"id":"e62ea25673292d09","type":"file","file":"toor/picture/Pasted image 20231111222039.png","x":702,"y":3920,"width":700,"height":564},
		{"id":"233d5f7a29101794","type":"text","text":"### AFL Heuristics\nFuzzer는 대상 프로그램의 모든 실행에서 관찰된 것을 튜플의 컬렉션으로 유지한다.\n(결과기록)","x":-278,"y":3389,"width":840,"height":171},
		{"id":"df241e8f82ddc0d1","type":"text","text":"### AFL Queue\n입력 큐는 항상 확장되며 새 입력은 교체가 아닌 보충으로 추가된다.\n이는 프로그램의 가능한 상호 베타적인 특성을 점진적으로 탐험할 수 있게 한다.\n이는 평균적으로 대부분의 프로그램에서 큐가 1000에서 10000 사이의 요소 크기에 도달한다는 것을 의미한다.\n\np.31","x":-278,"y":4000,"width":840,"height":280},
		{"id":"a67c5c0e9b3f1756","type":"text","text":"### AFL Instrumentation\n프로그램은 컴파일 타임에 instrumentation을 삽입하기 위해 afl-gcc 및 afl-g++로 컴파일 될 수 있다. \nLLVM 모드를 사용하는 경우 afl-clang-fast 및 afl-clang-fast++ wrapper도 사용할 수 있다. \n이 wrapper는 사용자 정의 LLVM 패스를 이용하여 더 빠른 instrumentation code를 빌드한다.\n\nLLVM 모드에서 AFL을 사용하는 경우 ASAN과 같은 다른 clang 도구도 데이터 추적 및 검증에 사용할 수 있다.\n\np. 22","x":800,"y":3049,"width":840,"height":340},
		{"id":"6bea9aefa5b07321","type":"text","text":"### AFL Mutator\nfuzzer의 입력 mutation은 다음과 같은 주요 challenge가 있다.\\[13]\n- mutation이 너무 빈약해서 fuzzer가 좋은 coverage에 도달하지 못한 경우\n- mutation이 너무 공격적인 경우 아마도 fuzzer가 초기 구문 분석 단계에서 많은 실패하는 testcase를 생성할 것이다.\n\nAFL은 target input에 대해 결정론적인 단계를 적용한 후, 나중 단계에서 결정론적이지 않은 fuzzing과 다른 입력과 재결합을 할 것이다.\n이는 초기에는 결정론적인 방식을 통해 안정성을 유지하고 나중에는 무작위적이고 창의적인 mutation을 활용하는 방식이다.\n\np. 36","x":-283,"y":4911,"width":843,"height":469},
		{"id":"26722fefac4e9920","type":"text","text":"### AFL Forkserver\nexecve의 loader 호출은 퍼저에게는 불필요한 오버헤드이다.\nAFL은 이를 알고있다.\\[14]\nELF의 코드의 작은 조각이 주입되어 자식 프로세스가 main에서 멈추게 한다. 각 요청된 실행을 pipe를 통해 해당 자식 프로세스의 fork한다.\n이러한 방법으로 AFL은 로딩 및 dynamic linking(LD_BIND_NOW를 사용)의 오버헤드를 피할 수 있다.\n\np. 40","x":-283,"y":5440,"width":843,"height":360},
		{"id":"361369d2502c4d97","type":"text","text":"### AFL Command line\n```\nafl-fuzz -i -input_directory -o afl_out -- ./program\n```\n다음과 같은 명령어로 fuzzing을 실행할 수 있다,\n-i : input case를 넣어야 하는 디렉토리를 나타낸다.\n-o : 변이된 case를 저장하는 디렉토리를 나타낸다.\n\\-- ./program : fuzzing을 하고자 하는 program\n\np. 41","x":-283,"y":5910,"width":843,"height":330},
		{"id":"542ab4ab2db588e1","type":"text","text":"## AFL Status Screen","x":775,"y":5880,"width":305,"height":60},
		{"id":"9a4c05a348b3fa83","type":"file","file":"toor/picture/Pasted image 20231112144606.png","x":660,"y":5940,"width":474,"height":300},
		{"id":"4d05f01e6ee6797f","type":"text","text":"### AFL Qemu mode\nsource code를 사용할 수 없는 경우에는?\ntarget program이 QEMU안에서 실행되고 생성된 중간 표현식(TCG)를 기계어로 변환하여 이를 이용하는 방법을 사용한다.\nhttps://github.com/andreafioraldi/afl 에 TCG 블록 체이닝 캐시를 부모에서 구현하며\\[15] 스레드 안전한 방식으로 구현한 QEMU 3.1.0 버전을 찾을 수 있다.\nAFL을 QEMU 모드에서 시작하려면 명령 줄에 -Q 매개변수를 추가하면 된다.\n\np. 45","x":-283,"y":6320,"width":843,"height":320},
		{"id":"5d22afadca5a6638","type":"text","text":"### AFL LLVM Mode\nafl-gcc에서는 생성된 어셈블리 파일에 instrumentation code가 삽입된다. \n그래서 compiler 최적화를 적용하기 어려워져 성능이 저하될 수 있다. 또한 afl-gcc의 instrumentation는 x86 아키텍처에 종속되어있다.\n이와 달리 LLVM 모드에서는 instrumentation을 LLVM IR에 적용하며, 이 문제를 극복한다.\n/llvm_mode/README.llvm 를 참조해자.\n관련된 compiler는 afl-clang-fast 이다.\n\np. 46","x":-283,"y":6720,"width":843,"height":340},
		{"id":"a56765b9b113c334","type":"text","text":"### Trimming\n파일 크기는 fuzzing에 중대한 영향을 미친다. 때로는 좋은 초기 set으로 시작하는 것은 충분하지 않으며, fuzzer는 큐에서 가져온 입력 파일의 크기를 증가시킬 수 있다.\n이러한 AFL의 경향을 방지하기 위해 자체적으로 큐에서 가져온 입력을 fuzzing할 때 일부를 삭제하고 이로써 instrumentation 출력에 영향을 주는지 여부를 확인한다.\n만약 삭제가 trace_bits checksun에 영향을 미치지 않는다면 해당 입력은 디스크에 저장된다.\n\np. 49","x":-282,"y":7100,"width":843,"height":303},
		{"id":"e9bf23d2f8e0f1f4","type":"text","text":"### AFL Deferred instrumentation\n많은 어플리케이션의 초기 작업은 시간이 많이 소요된다. forkserver의 stop-at-main에 접근하는 것은 충분하지 않을 수 있다. \nLLVM 모드를 사용하면 다음과 같이 코드에 이 코드 스니펫을 추가하여 메인 이후에 다른 entry point를 정의할 수 있다.\n```\n#ifdef __AFL_HAVE_MANUAL_CONTROL\n  __AFL_INIT(); \n#endif\n```\n\np. 47","x":-282,"y":7453,"width":843,"height":407},
		{"id":"06ebb192eb3aac52","type":"text","text":"### Parallel fuzzing\nAFL은 기본적으로 단일 코어에서 작동한다. CPU의 모든 성능을 활용하려면 여러 AFL 인스턴스를 실행해야 한다. 그러나 동일한 입력을 여러 번 fuzzing하는 것을 피하려면 AFL이 다중 인스턴스 간에 큐에서 흥미로운 testcase를 동기화하도록 설정해야 한다.\n이를 위해서는 각각의 fuzzer에게 역할과 이름을 지정하고 동일한 출력 디렉토리('-o afl_out')를 지정해야 한다.\n\np. 50","x":-282,"y":8400,"width":843,"height":320},
		{"id":"d7dca42ca602ed17","type":"text","text":"### AFL Persistent mode\nFork() 가 너무 heavy한가? 만약 우리가 fuzzing을 하는 application이 상태를 유지하지 않는다면 우리는 afl-clang-fast 의 지속모드 기능을 허용할 수 있다.\n하나의 오래된 프로세스가 여러 입력을 테스트하는데 재사용된다.\n```\nwhile (__AFL_LOOP(1000)) { \n  /* 입력 데이터 읽기 */ \n  /* 퍼징 대상 라이브러리 코드 호출 */ \n  /* 상태 재설정 */ \n}\n```\n\np. 48","x":-282,"y":7920,"width":843,"height":410},
		{"id":"46251fa904d89e2b","type":"text","text":"parallel : 병렬","x":-560,"y":8535,"width":211,"height":50},
		{"id":"1d55e65071f0178b","type":"text","text":"### Parallel fuzzing\nAFL에서는 두 가지 역할이 있다: master(-M name) , slave(-S name)\n\n마스터 instance는 이전에 설명한 모든 단계를 수행한다. 반면에 슬레이브 인스턴스는 결정론적인 stage 없이 havoc과 splice만을(splice는 항상 실행) 수행한다. \n```\nafl-fuzz -i initial_dir -o afl_out _M afl_master -- ./program\n```\n예를 들면 너는 master만으로 충분하다. 어떤 경우에는 결정론적 stage가 흥미롭지 않기 때문에 slave만 필요한 경우도 있다,\n\np. 51","x":720,"y":8355,"width":843,"height":410},
		{"id":"ccaa10de14294afb","type":"file","file":"toor/picture/Pasted image 20231113231215.png","x":-171,"y":8930,"width":622,"height":343},
		{"id":"826c9a0f784f6df9","type":"text","text":"## AFL Output directory","x":-35,"y":8880,"width":350,"height":50},
		{"id":"637082c7dcc96727","type":"text","text":"## Fuzzing Overview American Fuzzy Lop -**-> Useful strategies**","x":-127,"y":9400,"width":535,"height":90},
		{"id":"385532170e67d33f","type":"text","text":"### ASAN / MSAN\ncrash는 반드시 보안 이슈를 의미하는게 아니고 그 반대로 보안 이슈가 crash를 의미하는 것은 아니다.\ncrash를 일으키는 이 버그를 생각해봐라\n\np. 59","x":-171,"y":11536,"width":622,"height":224},
		{"id":"e3ae6ae37d1887d1","type":"file","file":"toor/picture/Pasted image 20231113235759.png","x":-171,"y":11760,"width":622,"height":183},
		{"id":"fb14fb3ab441f24b","type":"text","text":"### Useful additional tools\n\n  ● afl-cov to visualize coverage explored by AFL \n\t  https://github.com/mrash/afl-cov \n  ● crashwalk for crashes deduplication \n\t  https://github.com/bnagy/crashwalk \n  ● afl-ddmin-mod for a sophisticated minimization tool (slower than afl-tmin) \n\t  https://github.com/MarkusTeufelberger/afl-ddmin-mod\n\np. 65","x":-171,"y":12000,"width":622,"height":340},
		{"id":"6a339bd4eb62211c","type":"text","text":"### Testcase minimization\nafl-tmin tool은 fuzzer 외부에서 testcase를 보다 효율적으로 최소화하는데 사용될 수 있다.\n이 과정은 다음과 같다.\n1. 대량의 데이터 블록을 '0'으로 채우기\n2. 이진 탐색의 크기를 줄이며 블록 삭제 수행\n3. 알파벳 정규화, 고유 문자를 계산하고 '0'으로 대체\n4. '0'이 아닌 바이트의 바이트별 정규화\n시작 입력과 정확히 동일한 비트맵을 생성하는 변형만 유지된다. 이렇게 함으로써 최소화된testcase를 얻을 수 있다.\n\np. 54","x":-170,"y":9580,"width":622,"height":440},
		{"id":"208446f63f246d02","type":"text","text":"### Corpus minimization\nafl-cmin은 큐에있는 모든 testcase의 다양한 최소화 유형에 사용된다. 큐에서 더 이상 필요하지 않은 testcase를 제거한다.(큐에 새로운 testcase가 superset coverage를 가지고 있을 때도 큐에 유지된다고 했었지?)\n어떻게 afl-cmin을 실행해야 할까? 경험상으로는 master instance가 첫 번째 사이클을 수행할 때까지 기다린다.(한 사이클은 큐에 있는 모든 입력이 이미 퍼징되었고 AFL이 큐를 반복하는 시점이다.) 일반적으로 slave instance는 하나의 마스터 사이클 동안 많은 사이클을 수행한다.\n\np. 55","x":-170,"y":10080,"width":622,"height":440},
		{"id":"1dbc7124cafe1037","type":"text","text":"### Corpus minimization\nfuzzer를 중지하고나서 큐에 afl-cmin을 실행하고(실행 전에 저장하기) 선택적으로 모든 파일에 afl-tmin을 실행할 수 있다.(parallelization을 고려하여 매우 시간이 많이 걸릴 수 있다.)\nfuzzer를 중지한 후 큐를 초기 입력 디렉터리로 지정하여 재시작할 수 있다.\n```\nafl-fuzz -i - -o afl_out -- ./program\n``` \n\np. 56","x":542,"y":10109,"width":622,"height":381},
		{"id":"56534342f4594875","type":"text","text":"### LibTokenCap\n만약 흥미로운 키워드를 알지 못했다면?\nLibTokenCap을 사용하여 strcmp(), memcmp() 및 관련 함수를 설치하여 구문 토큰을 자동으로 추출할 수 있다.\n```\nif (strcmp(input, \"pippo\") == 0) goto new_path;\n```\n위와 같은 코드에서 pippo는 읽기 전용 섹션에 있기 때문에 log에 기록될 것이다.\n'LD_PRELOAD=./libctokencap.so' 를 사용하여 이 라이브러리를 로드하고 'AFL_TOKEN_FILE'을 출력 파일로 설정하여 AFL이 구문 토큰을 추출하도록 설정할 수 있다.\n\np. 58","x":-170,"y":10952,"width":622,"height":488},
		{"id":"f67f0fcc87676e52","type":"text","text":"### Dictionary\n사용자는 fuzzing 중에 사용할 몇 가지 사전 키워드를 지정할 수 있다. '-x' 매개변수를 사용하여 흥미로운 키워드 목록이 포함된 파일을 지정할 수 있다.\n예를 들면, HTTP 파서를 퍼징하는 경우 HTTP, GET, Host: 등을 흥미로운 키워드로 지정할 수 있다. AFL은 이러한 키워드를 결정론적인 stage와 havoc stage 양쪽엣 모두 삽입된다.\n\np. 57","x":-170,"y":10560,"width":622,"height":338},
		{"id":"f410873ce6ca3e51","type":"text","text":"### References\n\\[1] SAGE - https://dl.acm.org/citation.cfm?id=2094081 \n\\[2] Radamsa - https://gitlab.com/akihe/radamsa \n\\[3] Compare Coverage - https://github.com/googleprojectzero/CompareCoverage \n\\[4] Vuzzer - http://sharcs-project.eu/m/filer_public/48/8c/488c5fb7-9aad-4c87-ab9c-5ff251ebc73d/vuzzer_ndss17.pdf \n\\[5] Angora - https://arxiv.org/abs/1803.01307 \n\\[6] Peach - http://www.peach.tech/resources/peachcommunity/ \n\\[7] AFLSmart - https://github.com/aflsmart/aflsmart \n\\[8] libFuzzer - https://llvm.org/docs/LibFuzzer.html \n\\[9] honggfuzz - https://github.com/google/honggfuzz \n\\[10] Driller - https://www.cs.ucsb.edu/~vigna/publications/2016_NDSS_Driller.pdf \n\\[11] QSYM - https://github.com/sslab-gatech/qsym \n\\[12] AFL whitepaper - http://lcamtuf.coredump.cx/afl/technical_details.txt \n\\[13] Binary fuzzing strategies - https://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html \n\\[14] Fuzzing random programs without execve - https://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html \n\\[15] Improving AFL's QEMU mode performance - https://abiondo.me/2018/09/21/improving-afl-qemu-mode/ \n\\[16] Memcheck: a memory error detector - http://valgrind.org/docs/manual/mc-manual.html \n\\[17] AddressSanitizer - https://clang.llvm.org/docs/AddressSanitizer.html \n\\[18] MemorySanitizer - https://clang.llvm.org/docs/MemorySanitizer.html","x":-286,"y":12400,"width":852,"height":720},
		{"id":"04d362a78da7bfaa","type":"text","text":"# END","x":64,"y":13200,"width":152,"height":77},
		{"id":"a19344323ca4de43","type":"text","text":"### ASAN / MSAN\n다음의 상황은 보안 이슈이지만 crash는 아니다.\n\np. 60","x":566,"y":11568,"width":622,"height":160},
		{"id":"70442a1417f0edb2","type":"file","file":"toor/picture/Pasted image 20231114000018.png","x":566,"y":11728,"width":621,"height":196},
		{"id":"6137658449f569d0","type":"file","file":"toor/picture/Pasted image 20231114000634.png","x":1383,"y":11894,"width":497,"height":540},
		{"id":"cbff2d61371008a6","type":"text","text":"### ASAN / MSAN\n이 유형의 버그를 감지하는데 개발자가 사용하는 매우 유용한 도구 중 하나는 Valgrind의 memcheck 플러그인이다.\\[16] 그러나 이 도구는 비용이 많이든다.\nLLVM 툴체인은 동적 instrumentation 대신 compile-time instrumentation을 기반으로 하는 유사한 기능을 제공한다. AddressSanitizer\\[17](ASAN)은 빠른 메모리 오류 감지 도구이며 MemorySanitizer\\[18](MSAN)은 초기화되지 않은 읽기를 탐지하는 도구이다.\n\np. 61","x":1320,"y":11456,"width":622,"height":384},
		{"id":"4fc03a63e16caf6f","type":"text","text":"### ASAN/MSAN\n이러한 기능들은 다음 환경 변수를 설정하여 컴파일 중에 활성화 할 수 있다.\n```\nAFL_USE_ASAN=1 AFL_USE_MSAN=1\n```\n그러나 이러한 기능들은 fuzzing의 오버헤드가 크다. ASAN을 사용할 때 RAM의 폭발을 피하려면 대상 프로그램을 32bit로 컴파일 해라.\n\np. 63","x":2040,"y":11450,"width":622,"height":396},
		{"id":"31b5da147358580b","type":"text","text":"### LibDislocator\nASAN 비용이 부담스러운가? AFL은 힙 기반 메모리 오류 감지를 위한 \"poor man's library\"를 제공한다. 이는 LD_PRELOAD를 통해 malloc(), calloc(), free() 와 같은 libc 함수를 대체한다. (tokencap 처럼)\n이 라이브러리는 느리고 메모리를 많이 사용한다. (할당된 모든 버퍼는 PROT_NONE을 가진 mmapped 영역 앞에 배치되어 r/w 오버플로우를 감지한다.) 또한 heap canaries가 사용되어 비정상 쓰기를 감지한다.(하지만 읽기는 아님)\n\np. 64","x":2720,"y":11478,"width":622,"height":340},
		{"id":"86d95bd598621dc5","type":"text","text":"### AFL Mutator - Deterministic - 정해짐\n\ndeterministic stages는 아래와 같다.\n- bit flips(자동 추가 감지)\n- 간단한 산술 연산\n- 흥미로운 정수(0, 1, INT_MAX, ...)\n\np. 37","x":1207,"y":4937,"width":840,"height":310},
		{"id":"39f8588bd2f2b20d","type":"text","text":"### AFL Mutator - Havoc - 랜덤\ndeterministic이 아닌 havoc는 무작위 위치에서 다음과 같은 작업을 수행한다.\n- bit flip(spooky! == 예측하기 어려운)\n- 흥미로운 정수 삽입\n- 랜덤 엔디언 덧셈, 뺄셈\n- 랜덤 값으로 설정된 byte\n- 블록 삭제 / 복제 / 메모리 설정\n\np. 38","x":1207,"y":5247,"width":840,"height":343},
		{"id":"3c97a87c70b1a2e6","type":"text","text":"### AFL Mutator - Splice\n이것은 모든 이전 스테이지에서 새로운 흥미로운 파생된 입력을 찾지 못했을 때 호출되는 마지막 수단 스테이지이다. \n이 스테이지에서는 현재 mutation중인 입력과 최소 두 위치에서 다른 큐의 다른 입력을 재결합한다.(완전 다른 큐)\n재결합된 이 입력값은 havoc stage를 통과한다. 일반적으로 이 단계에서는 새로운 튜플의 약 20%를 발견할 수 있다. 예를 들어 HTTP 파서의 double free 취약점을 생각해보면, 이 단계가 이를 찾아내기 위한 유일하게 효과적인 단계일 수 있다.\n\np. 39","x":1207,"y":5590,"width":840,"height":355},
		{"id":"c8714b7c429ff572","type":"text","text":"결정론적 알고리즘 : 예측한 그대로 동작하는 알고리즘으로 직관적인 알고리즘으로 볼 수 있을 것 같다.","x":2127,"y":5038,"width":378,"height":108},
		{"id":"04aa2300a7b3ddd4","type":"text","text":"### AFL Queue Evaluation\nfrom 화이트페이퍼:\n1. 아직 임시 작업 집합에 없는 다음 튜플을 찾는다.\n2. 이 튜플에 대한 이긴 큐 엔트리를 찾는다.\n3. 작업 집합에 이 엔트리의 trace에 있는 모든 튜플을 등록한다.\n4. 집합에 누락된 튜플이 있다면 \\#1로 이동한다.\n\n찾은 모든 이긴 큐 엔트리는 선호되는것으로 표시한다.\n\np. 35","x":632,"y":4519,"width":840,"height":384},
		{"id":"d0358f67a8d2bf5c","type":"text","text":"### Funky hybrid stuffs\n특정 입력을 생성하여 검사를 우회하는 것은 fuzzer에게 간단하지 않을 수 있다. 다음 프로그램을 고려해보자.\n```\nint main(){\n    int x;\n    read(0, &x, sizeof(x));\n\n    if (x == 0xABADCAFE) \n        crash();\n}\n\n```\n\n이 경우는 경로가 하나뿐이며 이러한 경우에는 grey-box 와 black box가 동일하다.\n\np. 14\n","x":720,"y":1277,"width":840,"height":516},
		{"id":"a7084a62e4b3c9f6","type":"text","text":"# American Fuzzy Lop","x":-45,"y":2162,"width":370,"height":80},
		{"id":"877d5666ba36a61d","type":"text","text":"### AFL Heuristics\n로컬 상태는 다음중 하나로 정의된다:\n- 입력이 'trace_bits'에 새로운 튜플을 등록함\n- 입력이 이전에 관찰된 튜플의 'hit_count'를 증가시킴\n\nhit_count는 각 튜플이 만날 때마다 증가한다.('shared_mem\\[...]++'). 경로 폭발을 피하기 위해 'hit_count'는 다음과 같은 버킷으로 나누어진다: 1,2,3,4-7,8-15,16-31,32-127,128+\n\n따라서 이전 'hit_count'가 3이고 새로운 것이 4인 경우 입력이 고려되며, 이전이 4이고 새로운 것이 5인 경우 고려되지 않는다.\n\np. 30","x":702,"y":3415,"width":840,"height":453}
	],
	"edges":[
		{"id":"44ffafd2c65f8cde","fromNode":"8f8345ae12858a65","fromSide":"bottom","toNode":"38d02793c9646d4d","toSide":"top"},
		{"id":"916200a6f7e7ef36","fromNode":"38d02793c9646d4d","fromSide":"bottom","toNode":"d0101f7a1e1d0b7a","toSide":"top"},
		{"id":"271e1c2232775f29","fromNode":"d0101f7a1e1d0b7a","fromSide":"bottom","toNode":"df5a86a41b99a02f","toSide":"top"},
		{"id":"0e081138464a2c8b","fromNode":"df5a86a41b99a02f","fromSide":"bottom","toNode":"02de7dff04174f4f","toSide":"top"},
		{"id":"6c609e8742443883","fromNode":"df5a86a41b99a02f","fromSide":"bottom","toNode":"dae874f42c7b8919","toSide":"top"},
		{"id":"027b83853b30207c","fromNode":"df5a86a41b99a02f","fromSide":"bottom","toNode":"cc8a6d7e843b1dfb","toSide":"top"},
		{"id":"8d39700f1d7a3986","fromNode":"cc8a6d7e843b1dfb","fromSide":"bottom","toNode":"7ca027b3bd4bb0c9","toSide":"top"},
		{"id":"ddceaaace0dc4213","fromNode":"7ca027b3bd4bb0c9","fromSide":"bottom","toNode":"e40473d6fbc4c026","toSide":"top"},
		{"id":"ae611f5fc568514c","fromNode":"e40473d6fbc4c026","fromSide":"right","toNode":"d0358f67a8d2bf5c","toSide":"left"},
		{"id":"a5730a14be0b6b15","fromNode":"d0358f67a8d2bf5c","fromSide":"bottom","toNode":"49b4099e4d49f2f3","toSide":"top"},
		{"id":"6acb12444df0afa3","fromNode":"e40473d6fbc4c026","fromSide":"bottom","toNode":"a7084a62e4b3c9f6","toSide":"top"},
		{"id":"fe10881c119b397a","fromNode":"a7084a62e4b3c9f6","fromSide":"bottom","toNode":"dc205d813a85cd0c","toSide":"top"},
		{"id":"5572a83f0ad2f547","fromNode":"dc205d813a85cd0c","fromSide":"right","toNode":"7556a0619716e27a","toSide":"left"},
		{"id":"1666af2c9b6c2fb5","fromNode":"dc205d813a85cd0c","fromSide":"right","toNode":"74ed50c2a3d31790","toSide":"left"},
		{"id":"a34b89448862abe6","fromNode":"dc205d813a85cd0c","fromSide":"bottom","toNode":"0f539b9bae3111ec","toSide":"top"},
		{"id":"1b88ded47ddaa812","fromNode":"0f539b9bae3111ec","fromSide":"right","toNode":"a67c5c0e9b3f1756","toSide":"left"},
		{"id":"83d0efbdbc076695","fromNode":"a67c5c0e9b3f1756","fromSide":"right","toNode":"06eadf9f49c12016","toSide":"left"},
		{"id":"a4fbbe412130b05d","fromNode":"a67c5c0e9b3f1756","fromSide":"right","toNode":"58530c47b4c14cd7","toSide":"left"},
		{"id":"fbba68f88e28b599","fromNode":"06eadf9f49c12016","fromSide":"right","toNode":"723e8aaf6f3ebad4","toSide":"left"},
		{"id":"0f5b490b97ff9bfe","fromNode":"06eadf9f49c12016","fromSide":"right","toNode":"08f8a2263c13f249","toSide":"left"},
		{"id":"751d20adfe3d2b88","fromNode":"06eadf9f49c12016","fromSide":"right","toNode":"cc9eec796de8c58b","toSide":"left"},
		{"id":"82e7dda767bc62ff","fromNode":"06eadf9f49c12016","fromSide":"right","toNode":"92213d2d60138dc3","toSide":"left"},
		{"id":"c030ffa3b7349d5a","fromNode":"06eadf9f49c12016","fromSide":"right","toNode":"a8ede895e5dec0ef","toSide":"left"},
		{"id":"743acb84acddd31a","fromNode":"233d5f7a29101794","fromSide":"left","toNode":"bb85d7b6000a7c78","toSide":"right"},
		{"id":"4a9b325e45f9ba00","fromNode":"0f539b9bae3111ec","fromSide":"bottom","toNode":"233d5f7a29101794","toSide":"top"},
		{"id":"fa9ba83ac78f6579","fromNode":"c78be5a7a4793449","fromSide":"right","toNode":"877d5666ba36a61d","toSide":"left"},
		{"id":"93b20cca1520f14a","fromNode":"c78be5a7a4793449","fromSide":"bottom","toNode":"df241e8f82ddc0d1","toSide":"top"},
		{"id":"f38b5696ea9d243d","fromNode":"df241e8f82ddc0d1","fromSide":"right","toNode":"e62ea25673292d09","toSide":"left"},
		{"id":"099d7e93465a5d1f","fromNode":"e62ea25673292d09","fromSide":"right","toNode":"217b3b28cd099f19","toSide":"left"},
		{"id":"e4a1c7a2f8ec52ca","fromNode":"df241e8f82ddc0d1","fromSide":"bottom","toNode":"539bf5e4b99eb3cd","toSide":"top"},
		{"id":"cdf0c358dd4888d8","fromNode":"539bf5e4b99eb3cd","fromSide":"left","toNode":"29ef691a3031969a","toSide":"right"},
		{"id":"2df416f028ce9d05","fromNode":"539bf5e4b99eb3cd","fromSide":"right","toNode":"04aa2300a7b3ddd4","toSide":"left"},
		{"id":"3b6344e25f793a97","fromNode":"dae874f42c7b8919","fromSide":"left","toNode":"bb85d7b6000a7c78","toSide":"top"},
		{"id":"732de2c6c37e6f2b","fromNode":"0f539b9bae3111ec","fromSide":"left","toNode":"a939ae6ade3c443e","toSide":"right"},
		{"id":"cc4f63587c00c477","fromNode":"04aa2300a7b3ddd4","fromSide":"top","toNode":"a939ae6ade3c443e","toSide":"bottom"},
		{"id":"5a4d5decb8040231","fromNode":"539bf5e4b99eb3cd","fromSide":"bottom","toNode":"6bea9aefa5b07321","toSide":"top"},
		{"id":"c4dbcc75ff1e1bb7","fromNode":"6bea9aefa5b07321","fromSide":"right","toNode":"86d95bd598621dc5","toSide":"left"},
		{"id":"0771e8d6935caee0","fromNode":"6bea9aefa5b07321","fromSide":"right","toNode":"39f8588bd2f2b20d","toSide":"left"},
		{"id":"52d38c5676ecd153","fromNode":"6bea9aefa5b07321","fromSide":"bottom","toNode":"26722fefac4e9920","toSide":"top"},
		{"id":"69a07bca253ca4a7","fromNode":"6bea9aefa5b07321","fromSide":"right","toNode":"3c97a87c70b1a2e6","toSide":"left"},
		{"id":"32e3a87e08379572","fromNode":"26722fefac4e9920","fromSide":"bottom","toNode":"361369d2502c4d97","toSide":"top"},
		{"id":"f3d914552508dda7","fromNode":"361369d2502c4d97","fromSide":"right","toNode":"9a4c05a348b3fa83","toSide":"left"},
		{"id":"73bc05c13ec027ee","fromNode":"361369d2502c4d97","fromSide":"bottom","toNode":"4d05f01e6ee6797f","toSide":"top"},
		{"id":"472f7fdcc908de93","fromNode":"4d05f01e6ee6797f","fromSide":"bottom","toNode":"5d22afadca5a6638","toSide":"top"},
		{"id":"b4db12b9c33cd407","fromNode":"5d22afadca5a6638","fromSide":"bottom","toNode":"e9bf23d2f8e0f1f4","toSide":"top"},
		{"id":"7c50763e57a19460","fromNode":"e9bf23d2f8e0f1f4","fromSide":"bottom","toNode":"d7dca42ca602ed17","toSide":"top"},
		{"id":"9b5626b078a5104f","fromNode":"a56765b9b113c334","fromSide":"left","toNode":"6220ab3d472fa0f2","toSide":"right"},
		{"id":"be0b68af5531828d","fromNode":"d7dca42ca602ed17","fromSide":"bottom","toNode":"a56765b9b113c334","toSide":"top"},
		{"id":"f8b8369eec15e7e8","fromNode":"a56765b9b113c334","fromSide":"bottom","toNode":"06ebb192eb3aac52","toSide":"top"},
		{"id":"33f1daaa0d962f2e","fromNode":"06ebb192eb3aac52","fromSide":"left","toNode":"46251fa904d89e2b","toSide":"right"},
		{"id":"aa83bb31fb2e8d55","fromNode":"06ebb192eb3aac52","fromSide":"right","toNode":"1d55e65071f0178b","toSide":"left"},
		{"id":"af930cfbf943c70e","fromNode":"1d55e65071f0178b","fromSide":"right","toNode":"3c97a87c70b1a2e6","toSide":"right"},
		{"id":"30b61ab5812242fb","fromNode":"06ebb192eb3aac52","fromSide":"bottom","toNode":"826c9a0f784f6df9","toSide":"top"},
		{"id":"5e17f7bb4e426c98","fromNode":"ccaa10de14294afb","fromSide":"bottom","toNode":"637082c7dcc96727","toSide":"top"},
		{"id":"1cc104b41ae8dc11","fromNode":"637082c7dcc96727","fromSide":"bottom","toNode":"6a339bd4eb62211c","toSide":"top"},
		{"id":"688ce055bbe87cde","fromNode":"6a339bd4eb62211c","fromSide":"bottom","toNode":"208446f63f246d02","toSide":"top"},
		{"id":"075e861dc3d9ad14","fromNode":"208446f63f246d02","fromSide":"right","toNode":"1dbc7124cafe1037","toSide":"left"},
		{"id":"6ac7eec13b772b8a","fromNode":"208446f63f246d02","fromSide":"bottom","toNode":"f67f0fcc87676e52","toSide":"top"},
		{"id":"5976470ce4c5aad2","fromNode":"f67f0fcc87676e52","fromSide":"bottom","toNode":"56534342f4594875","toSide":"top"},
		{"id":"6d7f3461c859292a","fromNode":"56534342f4594875","fromSide":"bottom","toNode":"385532170e67d33f","toSide":"top"},
		{"id":"fa61c1ff6d683072","fromNode":"385532170e67d33f","fromSide":"right","toNode":"a19344323ca4de43","toSide":"left"},
		{"id":"deb9de87b9453915","fromNode":"a19344323ca4de43","fromSide":"right","toNode":"cbff2d61371008a6","toSide":"left"},
		{"id":"356512d9769defec","fromNode":"cbff2d61371008a6","fromSide":"bottom","toNode":"6137658449f569d0","toSide":"top"},
		{"id":"4f4ea9b02f361a0f","fromNode":"cbff2d61371008a6","fromSide":"right","toNode":"4fc03a63e16caf6f","toSide":"left"},
		{"id":"39f6c762578b33ce","fromNode":"4fc03a63e16caf6f","fromSide":"right","toNode":"31b5da147358580b","toSide":"left"},
		{"id":"a96ea24babe5873d","fromNode":"e3ae6ae37d1887d1","fromSide":"top","toNode":"fb14fb3ab441f24b","toSide":"top"},
		{"id":"80f61545372aaf48","fromNode":"fb14fb3ab441f24b","fromSide":"bottom","toNode":"f410873ce6ca3e51","toSide":"top"},
		{"id":"422aff00efbc5857","fromNode":"f410873ce6ca3e51","fromSide":"bottom","toNode":"04d362a78da7bfaa","toSide":"top"},
		{"id":"89c1129ce8be3034","fromNode":"02de7dff04174f4f","fromSide":"left","toNode":"5a3af1928ea0f645","toSide":"right"},
		{"id":"ae6dd920807ab018","fromNode":"5a3af1928ea0f645","fromSide":"bottom","toNode":"792d7993dbf83354","toSide":"top"},
		{"id":"4ec97530f5456ff6","fromNode":"86d95bd598621dc5","fromSide":"right","toNode":"c8714b7c429ff572","toSide":"left"},
		{"id":"1fab7acea90a4883","fromNode":"723e8aaf6f3ebad4","fromSide":"right","toNode":"3a300778e8a58232","toSide":"left"},
		{"id":"14a5c6bd7f8fea40","fromNode":"08f8a2263c13f249","fromSide":"right","toNode":"72e30b4da58405c6","toSide":"left"},
		{"id":"8e6cf304efb71850","fromNode":"cc9eec796de8c58b","fromSide":"right","toNode":"2d15cce6082d0ec5","toSide":"left"},
		{"id":"ebfab014dd911f2e","fromNode":"72e30b4da58405c6","fromSide":"right","toNode":"519ec65d30eaa00c","toSide":"right"},
		{"id":"ed73449abc076c5a","fromNode":"92213d2d60138dc3","fromSide":"right","toNode":"519ec65d30eaa00c","toSide":"left"},
		{"id":"e990eefe0dbec7fd","fromNode":"519ec65d30eaa00c","fromSide":"bottom","toNode":"dd49b6ecac47e56b","toSide":"top"},
		{"id":"e09e8bc374c41e24","fromNode":"a8ede895e5dec0ef","fromSide":"right","toNode":"dd49b6ecac47e56b","toSide":"left"}
	]
}