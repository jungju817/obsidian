{
	"nodes":[
		{"id":"cf408a43a9f8516c","type":"text","text":"## honggfuzz 란?\n\nhonggfuzz는 커버리지 기반의 뮤테이션을 수행하는 grey box fuzzer이다. ","x":-134,"y":-62,"width":294,"height":142},
		{"id":"58356679753d8a44","type":"text","text":"## honggfuzz 설치\n\n우선 관련된 라이브러리들을 설치한다.\n```\n$ sudo apt-get install libbfd-dev libunwind-dev\n```\n\n그리고 github에서 clone한 후 설치한다.\n\n```\n$ git clone --depth 1 --recursive https://github.com/google/honggfuzz\n$ cd honggfuzz/\n$ make\n$ sudo make install\n$ which honggfuzz \n/usr/local/bin/honggfuzz\n```\n\nhonggfuzz가 잘 설치되었다.\n\n","x":-640,"y":-182,"width":400,"height":382},
		{"id":"df4083bbe5b339f0","type":"file","file":"toor/picture/Pasted image 20231213223935.png","x":-640,"y":200,"width":400,"height":107},
		{"id":"1774fed5904ec9e1","type":"text","text":"## Example","x":-57,"y":340,"width":140,"height":50},
		{"id":"b822ba96219db8e4","type":"text","text":"## target build\n\nhonggfuzz를 실습해보기 위한 퍼징 대상으로 OpenSSL을 선정하였다. 우선 관련 라이브러리를 설치한다.\n\n```\n$ sudo apt-get install texinfo flex zlib1g-dev\n```\n\nOpenSSL의 깃허브에서 최신 버전을 가져온다. OpenSSL 3.0 버전이다.\n\n```\n$ git clone --depth=1 https://github.com/openssl/openssl.git\n$ mv openssl openssl-master\n```\nHonggfuzz의 examples 의 openssl에 셸 스크립트가 존재한다. vifh 열고 hfuzz-clang의 경로를 본인의 환경에 맞게 변경해준다.\n```\ncd ./honggfuzz/examples/openssl\nvi compile_hfuzz_openssl_master.sh\n```","x":-217,"y":440,"width":460,"height":420},
		{"id":"8e6b0944c9b86ff0","type":"text","text":"## 요구사항\n\nPOSIX 호환 운영 체제, MacOSX, Android 또는 Windows\n하드웨어 기반의 code coverage guided fuzzing을 위한 GNU/linux와 최신 커널(>= 4.2)\n\n","x":-166,"y":-340,"width":466,"height":140},
		{"id":"ea306b044751e0f4","type":"text","text":"## fuzzing 대상\n\ninput corpus\n\tImage 형식 : Tavis Ormandy의 Image Testsuite 는  다양한 그래픽 라이브러리의 취약점을 찾아내는데 효과적이었다.\n\tPDF","x":340,"y":-200,"width":640,"height":129},
		{"id":"0bcd49d0a2311626","type":"text","text":"## fuzzing 방식\n\n초기 입력으로 corpus가 주어지면, 대상 파일들을 식별하여 unique basic block 또는 instruction/branch 카운터를 증가하는 방향으로 작동하며, 메모리 상에서 동적으로 corpus를 처리한다. 그리고 해당 corpus 중에서 임의로 파일을 선별 추출한 후 이를 다시 mutate시켜서 다음 fuzzing round 수행을 실시한다. 만약 이렇게 새롭게 생성한 파일이 코드 경로를 새롭게 발견했다면, 해당 corpus를 적절하게 추가한 것이다. 이후 리눅스의 ptrace API를 통해 시그널 핸들러로부터 SIGABRT, SIGILL, SIGBUS, SIGSEGV 및 SIGABRT 등의 시그널이 발생하는지 모니터링한다.","x":340,"y":-51,"width":640,"height":151},
		{"id":"3bf84295b4526798","type":"text","text":"## 사용 방법\n\n```\nhonggfuzz --input [input directory] --output [output directoy] -- [실행파일] ___FILE___\n```\n","x":340,"y":120,"width":640,"height":220},
		{"id":"d4b3a3cd5fec15a2","type":"text","text":"instruction : 얼마나 많은 명령어를 실행했나\n\nbranch : 얼마나 많은 분기문을 통과했나","x":1020,"y":-20,"width":311,"height":89},
		{"id":"5e288858e7ad71d9","type":"text","text":"## Clang 11 설치\n\n컴파일시 계측 코드를 넣는 것은 hfuzz-clang이 수행하는데, 결국 clang 컴파일러가 설치되어 있어야 가능하다. llvm과 clang 11을 설치하자.\n\n```\n$ sudo apt-get install llvm-11 clang-11\n```\n\n설치 후에 경로를 잡아준다.\n\n```\n$ export PATH=/usr/lib/llvm-11/bin:$PATH\n$ export LD_LIBRARY_PATH=/usr/lib/llvm-11/lib:$LD_LIBRARY_PATH\n```","x":-640,"y":-500,"width":400,"height":300},
		{"id":"16b41aaeec3c3207","type":"file","file":"toor/picture/Pasted image 20231214201414.png","x":-217,"y":860,"width":460,"height":109},
		{"id":"d75de6bf0c11f68c","type":"text","text":"컴파일 할 때 Sanitizer를 적용할 수 있다. \\[enable-asan|enable-msan|enable-ubsan] 중에서 선택할 수 있다. Address Sanitizer를 적용하기 위해 enable-asan 옵션을 준다.\n```\ncd ../../../openssl\n../honggfuzz/examples/openssl/compile_hfuzz_openssl_master.sh enable-asan\nmake -j$(nproc\n```\n\n뭔가 빌드가 안됨\nhttps://cpuu.postype.com/post/9145704#responses\n","x":-217,"y":969,"width":460,"height":231},
		{"id":"2476f6568ad62095","type":"text","text":"## 옵션\n\n```\n --help|-h\n        도움말 출력\n --input|-i VALUE\n        초기 파일 corpus가 있는 디렉토리의 경로를 지정한다.\n --output|-o VALUE\n        output data가 쓰일 디렉토리 경로를 지정한다.\n --persistent|-P\n        영속적인 퍼징을 활성화한다. 이는 퍼징 세션이 일회성이 아닌 계속해서 지속되도록 하는 옵션이다.\n --instrument|-z\n        default mode로 compile time 도구를 활성화 한다.\n --minimize|-M\n        입력 corpus를 최소화하며, --output을 사용하지 않으면 --input 디렉토리에서 일부 corpus file 이 삭제될 수도 있다.\n --noinst|-x\n        정적 모드만 활성화하고, 다른 hw/sw 적 피드백을 비활성화 한다.\n --keep_output|-Q\n        자식의 stdin, stderr를 닫지 않고 유지한다.\n --timeout|-t VALUE\n        시간 초과를 초단위로 지정한다. (기본값 : 1초)\n --threads|-n VALUE\n        동시 퍼징 스레드 수를 지정한다. (기본값:CPU개수 / 2)\n --stdin_input|-s\n        STDIN에 대한 퍼징 입력을 제공한다.(___FILE___대신에)\n --mutations_per_run|-r VALUE\n        각 실행에 대한 최대 mutate 수를 지정한다. (기본값 : 6)\n --logfile|-l VALUE\n        로그 파일을 지정한다.\n --version|-!\n        버전 정보를 출력하고 종료한다.\n --verbose|-v\n        ANSI 콘솔을 비활성화하고 간단한 로그 출력을 사용한다.\n --verifier|-V\n        충돌확인기를 활성화한다.\n --debug|-d\n        디버그 메시지를 표시한다(레벨 >= 4)\n --quiet|-q\n        경고 및 더 심각한 메시지만 표시한다(레벨<=1)\n --extension|-e VALUE\n        입력 파일 확장자(예를 들면 'swf')를 지정한다.(기본값:'fuzz')\n --workspace|-W VALUE\n        crash 및 런타임 파일을 저장할 작업 디렉토리를 지정한다.(기본값 : '.')\n --crashdir VALUE\n        crash가 저장될 디렉토리를 지정한다.(기본값: 작업 디렉토리)\n --covdir_all|-o VALUE\n        사용하지 않음\n --covdir_new VALUE\n        새로운 커버리지(드라이 런 퍼징 단계 이후)가 이 디렉토리에 기록된다.\n --dict|-w VALUE\n        Dictionary file을 지정하다.\n --stackhash_bl|-B VALUE\n        Stackhashes blocklist file을 지정한다.\n --mutate_cmd|-c VALUE\n        퍼징 파일을 생성하는 외부 명령을 지정한다.\n --pprocess_cmd VALUE\n        내장 뮤테이터에 의해 생성된 파일에 대한 외부 후처리 명령을 지정한다.\n --ffmutate_cmd VALUE\n        유효한 커버리지 피드백을 가진 파일을 변형하는 외부 명령을 지정한다.\n --run_time VALUE\n        퍼징 세션이 지속되는 시간을 초 단위로 지정한다. (default: 0 [no limit])\n --exit_on_time VALUE\n        새로운 커버리지를 찾지 못한 경우 퍼징 세션을 중지하는 시간으 초 단위로 지정한다. (default: 0 [no limit])\n --iterations|-N VALUE\n        퍼징 반복 횟수를 지정한다. (default: 0 [no limit])\n --rlimit_as VALUE\n        프로세스당 RMIMIT_AS(MiB)를 지정한다. (default: 0 [default limit])\n --rlimit_rss VALUE\n        프로세스당 RLIMIT_RSS(MiB)를 지정한다. (default: 0 [default limit]). It will also set *SAN's soft_rss_limit_mb\n --rlimit_data VALUE\n        프로세스당 RLIMIT_DATA(MiB)를 지정한다. (default: 0 [default limit])\n --rlimit_core VALUE\n        프로세스당 RLIMIT_CORE(MiB)를 지정한다. (default: 0 [no cores are produced])\n --rlimit_stack VALUE\n        프로세스당 RLIMIT_STACK(MiB)를 지정한다. (default: 0 [default limit])\n --report|-R VALUE\n        이 파일에 보고서를 작성한다. (default: '<workdir>/HONGGFUZZ.REPORT.TXT')\n --max_file_size|-F VALUE\n        퍼저가 처리하는 파일의 최대 크기를 바이트 단위로 지정한다. (default: 1048576 = 1MB)\n --clear_env\n\t    이진 파일을 실행하기 전에 모든 환경 변수를 지운다.\n --env|-E VALUE\n        이 환경 변수를 전달한다. 여러 번 사용할 수 있다.\n --save_all|-u\n\t    모든 테스트 케이스를 저장한다. 고유한 것 뿐만 아니라 현재 타임 스탬프를 파일 이름에 추가한다.\n --save_smaller|-U\n        더 작은 테스트 케이스를 저장하고 첫 번째 파일 이름에 .orig 접미사를 추가한다.\n --tmout_sigvtalrm|-T\n        시간 초과를 충돌로 처리한다. 시간 초과하는 프로세스를 종료하는데 SIGVTALRM을 사용한다. (default: use SIGKILL)\n --sanitizers|-S\n        사용하지않음\n --sanitizers_del_report VALUE\n        사용 후 sanitizer 보고서를 삭제한다.\n --monitor_sigabrt VALUE\n        사용하지않음\n --no_fb_timeout VALUE\n        프로세스가 시간 초과한 경우 피드백을 건너뛴다. (default: false)\n --exit_upon_crash\n        첫 번째 충돌을 볼 때 종료한다.\n --exit_code_upon_crash VALUE\n        첫 번째 충돌을 볼 때 사용할 종료 코드를 지정한다.\n --socket_fuzzer\n        소켓을 통해 외부 퍼저를 인스트루먼트한다.\n --netdriver\n        netdriver를 사용한다. 대부분의 경우 바이너리 시그니처를 통해 자동으로 감지된다.\n --only_printable\n        출력 가능한 문자만 생성한다.\n --export_feedback\n        커버리지 피드백 구조를 ./hfuzz-feedback으로 내보낸다.\n --const_feedback VALUE\n        퍼징된 프로그램에서 정수/문자열 값을 사용하여 입력 파일을 동적 사전을 통해 변형한다. (default: true)\n --pin_thread_cpu VALUE\n        단일 실행 스레드를 연속된 이 CPU에 pin 한다. (default: 0 = no CPU pinning)\n --dynamic_input VALUE\n        동적 파일 코퍼스가 있는 디렉토리의 경로를 지정한다.\n --statsfile VALUE\n        통계 파일을 지정한다.\n --linux_symbols_bl VALUE\n        심볼 블록리스트 필터 파일을 지정한다.(one entry per line)\n --linux_symbols_wl VALUE\n        심볼 허용 목록 필터 파일을 지정합니다. (one entry per line)\n --linux_symbols_al VALUE\n        심볼 허용 목록 필터 파일을 지정합니다. (one entry per line)\n --linux_addr_low_limit VALUE\n        충동리 보고되지 않는 주소 제한이다. (default: 0)\n --linux_keep_aslr\n        ASLR 무작위화를 비활성화하지 않는다. MSAN과 함께 사용될 수 있다.\n --linux_perf_ignore_above VALUE\n        이 주소를 초과하는 IP를 보고하지 않도록 perf이벤트를 무시한다.\n --linux_perf_instr\n        PERF_COUNT_HW_INSTRUCTIONS perf를 사용한다.\n --linux_perf_branch\n        PERF_COUNT_HOW_BRANCH_INSTRUCTIONS perf를 사용한다.\n --linux_perf_bts_edge\n        고유 엣지를 계산하기 위해 Intel BTS를 사용한다.\n --linux_perf_ipt_block\n        고유 블록을 계산하기 위해 Intel Processor Trace를 사용한다. (requires libipt.so)\n --linux_perf_kernel_only\n        Intel PT 및 Intel BTS를 사용하여 커널 전용 커버리지를 수집한다.\n --linux_ns_net VALUE\n        Linux Net 네임스페이스 격리를 사용한다. (yes/no/maybe [default:no])\n --linux_ns_pid\n        Linux PID 네임스페이스 격리를 사용합니다.\n --linux_ns_ipc\n        Linux IPC 네임스페이스 격리를 사용합니다.\n```","x":1051,"y":140,"width":669,"height":2280}
	],
	"edges":[
		{"id":"a868c0f285652b27","fromNode":"cf408a43a9f8516c","fromSide":"right","toNode":"ea306b044751e0f4","toSide":"left"},
		{"id":"76a8560700ec7516","fromNode":"cf408a43a9f8516c","fromSide":"right","toNode":"0bcd49d0a2311626","toSide":"left"},
		{"id":"563165fb2512ebae","fromNode":"cf408a43a9f8516c","fromSide":"right","toNode":"3bf84295b4526798","toSide":"left"},
		{"id":"0aff10010a221ee3","fromNode":"cf408a43a9f8516c","fromSide":"bottom","toNode":"1774fed5904ec9e1","toSide":"top"},
		{"id":"5e415746e22ef877","fromNode":"cf408a43a9f8516c","fromSide":"left","toNode":"58356679753d8a44","toSide":"right"},
		{"id":"aa3559a586801598","fromNode":"1774fed5904ec9e1","fromSide":"bottom","toNode":"b822ba96219db8e4","toSide":"top"},
		{"id":"97a02978bb7814d4","fromNode":"0bcd49d0a2311626","fromSide":"right","toNode":"d4b3a3cd5fec15a2","toSide":"left"},
		{"id":"ba7256fdea88b3dc","fromNode":"5e288858e7ad71d9","fromSide":"bottom","toNode":"58356679753d8a44","toSide":"top"},
		{"id":"ceaaa535555397bb","fromNode":"3bf84295b4526798","fromSide":"right","toNode":"2476f6568ad62095","toSide":"left"}
	]
}