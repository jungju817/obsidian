{
	"nodes":[
		{"id":"93b256c87f74aba8","type":"group","x":-123,"y":2980,"width":1963,"height":5060,"color":"2","label":"BACKGROUND"},
		{"id":"01c7af533f5b04cc","type":"group","x":-123,"y":11440,"width":1839,"height":3380,"color":"5","label":"EXPERIMENT"},
		{"id":"0f22ad8653ef5c2e","type":"group","x":-123,"y":680,"width":2066,"height":2195,"color":"1","label":"INTRODUCTION"},
		{"id":"ada1543002108a76","type":"group","x":-123,"y":8200,"width":2040,"height":2080,"color":"3","label":"MODEL OVERVIEW"},
		{"id":"433ed6b5b5e912fc","type":"group","x":-123,"y":10380,"width":943,"height":940,"color":"4","label":"IMPLEMENTATION"},
		{"id":"451ca654dda3ae90","type":"group","x":-123,"y":14920,"width":943,"height":700,"color":"6","label":"DISCUSSION"},
		{"id":"630d68ecaaf98907","type":"text","text":"```\nC. Lava-M 데이터 세트에 대한 실험 \n이 섹션에서는 Lava-M 데이터 세트에 대한 PTfuzz, AFL 및 QAFL의 실험 결과를 비교할 것입니다. Lava는 대상 프로그램에 실제 버그를 주입하여 실측 corpus를 생성하는 기술입니다[42]. 저자는 일반적으로 볼 수 있는 4개의 GNU 프로그램(base64, md5sum, uniq 및 who)을 주입하여 Lava-M 데이터 세트를 만들었습니다. VUzzer[8]와 같은 최근 연구에서는 다양한 퍼저의 성능을 비교하기 위해 Lava-M 데이터 세트를 벤치마크로 사용하는 경향이 있습니다. 저희는 base64, md5sum, uniq 및 who에 대해 별도로 실험을 수행하고 실험 결과는 표 5에 나와 있습니다. 특히 표에서 대상 프로그램은 AFL이 원시 바이너리를 퍼징할 수 없기 때문에 AFL에 대해 compile time 계측되며 PTfuzz 및 QAFL에는 계측되지 않습니다. \n표에서 볼 수 있듯이 PTfuzz는 base64 및 uniq에서 AFL 및 QAFL보다 더 많은 충돌을 노출합니다. 실행 속도의 경우 PTfuzz는 모든 대상 프로그램에서 QAFL보다 성능이 뛰어나지만 AFL보다 느립니다. 또한 PTfuzz는 모든 실험에서 AFL 및 QAFL보다 더 많은 edge를 커버할 수 있으므로 정확한 커버리지 피드백을 통해 PTfuzz가 대상 프로그램을 더 정밀하게 퍼징할 수 있습니다. md5sum의 실험에서는 프로그램이 더 많은 다른 입력이 실행되지 않고 첫 번째 입력에서 충돌했기 때문에 PTfuzzz, AFL 및 QAFL에서 퍼징할 수 없었습니다. 그리고 VUzzzer에서도 동일한 현상이 발생하므로 md5sum의 실험 결과에서 \"-\"를 표시합니다. \n표에 따르면 PTfuzz는 LAVA-M 데이터 세트에서 충돌을 찾는 데 잘 작동하지 않습니다. AFL과 QAFL도 마찬가지입니다. 그 이유는 LAVA-M에 주입된 버그가 하드 코딩된 마법 바이트에 대한 입력에서 복사된 값에 대한 조건부 검사로 모두 보호되기 때문입니다. 따라서 VUzzer와 같은 정적 분석 도구가 없으면 PTfuzz는 주입된 버그를 보호하는 검사에 사용된 예상 값을 쉽게 복구할 수 없습니다.  \n따라서 결론적으로, 우리는 이 절에서 널리 사용되는 벤치마크 Lava-M 데이터 세트에 대한 실험을 수행합니다. AFL 및 QAFL과 비교하여, 우리는 이 상황에서 PTfuzz가 더 나은 퍼징 성능을 가지고 있음을 증명할 수 있습니다. 그리고 우리의 PTfuzz는 md5sum을 제외한 대부분의 대상 프로그램을 퍼징할 수 있으므로, 우리는 PTfuzz가 대부분의 퍼징 상황으로 확장될 수 있다는 결론을 내릴 수 있습니다.\n```","x":-103,"y":14120,"width":903,"height":680},
		{"id":"e696ec23b35ada65","type":"text","text":"# 6. DISCUSSION\n\n```\nA. 제한 사항 \nPTfuzz가 AFL 및 QAFL보다 상대적으로 더 나은 퍼징 성능을 가지고 있지만, 우리 접근 방식의 몇 가지 제한 사항이 있습니다. \n- 하드웨어 및 OS 요구 사항. 인텔 프로세서 트레이스는 인텔 코어 프로세서(브로드웰 아키텍처) 이후에만 제공되는 새로운 기능이므로 PTfuzz는 이전 버전의 인텔 CPU가 있는 컴퓨터에서는 실행할 수 없습니다. 또한 프로세서 트레이스 출력 공간(ToPA [21]) 구현은 perf_event [36]에서 mmap_page라는 기능을 사용하며, 이 기능은 커널 4.1.x 이후에만 사용할 수 있습니다. 따라서 PTfuzz를 실행하려면 새로운 버전의 커널이 필요합니다. 그러나 이 ToPA 구현 문제는 메모리 공간을 ToPA로 수동으로 지정하면 해결할 수 있으며, 이는 mmap_page를 사용하는 것과 완전히 동일합니다. \n- 디코더 구현. V절에 나와 있는 것처럼 PTfuzz는 퍼징 작업에서 AFL보다 느립니다. PTfuzz의 코드를 분석하면 기록된 프로세서 트레이스 정보의 디코더가 파이프라인과 같은 디코딩을 수행하여 엄청난 속도를 높일 수 있음을 알 수 있습니다. 즉, 본 구현에서 PTfuzz는 테스트 케이스가 실행을 마친 후에만 ToPA에서 테스트 케이스의 추적 데이터를 디코딩합니다. 따라서 실행 시작과 실행 완료 사이에는 디코더가 할 일이 없습니다. 그리고 실행 종료 후 대신 테스트 케이스가 실행 중일 때 디코딩을 수행하여 PTfuzz를 개선할 수 있습니다. \n- 리눅스 플랫폼에서만 가능합니다. 현재 PTfuzz는 리눅스 시스템에 의존하기 때문에 리눅스 프로그램만 퍼징할 수 있습니다. 그러나 프로세서 트레이스는 최근 윈도우즈 지원을 추가하여 윈도우즈에서 PTfuzz를 운영하는 데 도움을 주고 있습니다. 따라서 향후에도 동일한 방식으로 윈도우즈 플랫폼에 PTfuzz를 이식하고 윈도우즈 애플리케이션을 퍼징할 계획입니다\n```","x":-103,"y":14940,"width":903,"height":660},
		{"id":"961343f38b31a2a1","type":"text","text":"![](https://i.imgur.com/qYv6hHz.png)","x":940,"y":14342,"width":757,"height":236},
		{"id":"5a813b3e7b37eb4a","type":"text","text":"# 7. CONCLUSION\n\n```\n이 논문에서는 소프트웨어의 버그와 취약성을 노출시키기 위해 그레이박스 퍼징에 중점을 둡니다. 한편, 저희는 이전 그레이박스 퍼징을 살펴보고 몇 가지 일반적인 단점을 찾습니다. 일부 퍼징은 이진 퍼징만 지원할 수 없고, 일부는 코드 커버리지가 낮고, 일부는 큰 오버헤드로 어려움을 겪습니다. 이러한 한계를 해결하기 위해 인텔 프로세서 트레이스 기술을 지원하는 그레이박스 퍼징 기법을 도입하고 PTfuzz라는 프로토타입을 구현합니다. 저희는 비교적 빠른 실행 속도로 PT를 사용하여 프로그램 실행 시 기본 블록 전환을 정확하게 기록하고 이전 퍼징보다 높은 코드 커버리지를 달성합니다. 그리고 실험 결과는 PTfuzz가 대부분의 3가지 지표, 충돌, 속도 및 분기에서 AFL과 QAFL을 능가한다는 것을 보여줍니다. 그 결과 PTfuzz가 퍼징 작업에 훨씬 더 효과적이며 프로그램의 더 깊은 버그와 취약성을 노출할 수 있다는 강력한 증거입니다\n```","x":-103,"y":15740,"width":903,"height":360},
		{"id":"c3d47770f424e0ae","type":"text","text":"ABSTRACT\n```\nAFL(American Fuzzy lop)과 같은 그레이박스 퍼징은 소프트웨어 취약성을 찾는 데 매우 효율적인 최첨단 퍼징 기술입니다. 그레이박스 퍼징은 프로그램 실행 중에 수집된 분기 정보를 피드백으로 활용하여 시드 선택을 안내합니다. 현재 그레이박스 퍼징은 일반적으로 분기 정보를 수집하기 위해 컴파일 시간 계측(AFL)과 에뮬레이션[QEMU 에뮬레이션(QAFL)으로 확장된 AFL]의 두 가지 방법을 사용합니다. 컴파일 시간 계측은 효율적이지만 바이너리 프로그램을 지원하지는 않습니다. 한편, 에뮬레이션은 바이너리 프로그램을 지원하지만 효율성은 매우 낮습니다. 본 논문에서는 하드웨어 메커니즘(Intel Processor Trace)을 활용하여 분기 정보를 수집하는 PTfuzzz라는 그레이박스 퍼징 접근 방식을 제안합니다. 저희의 접근 방식은 에뮬레이션 방법과 마찬가지로 바이너리 프로그램을 지원하는 반면 컴파일 시간 계측 방법과 비슷한 성능을 얻습니다. 저희의 실험은 PTfuzz가 수정 없이 원래 바이너리 프로그램을 퍼징할 수 있음을 보여주며, QAFL에 비해 3배의 성능 향상을 얻습니다\n```","x":-103,"y":109,"width":903,"height":440},
		{"id":"951689b30415e770","type":"text","text":"DBI(Dynamic Binary Instrumentation)\n\n동적 바이너리 계측은 런타임에 실행 코드를 삽입하여 바이너리 응용 프로그램의 동작을 분석하는 방법이다.\n\n장점 : \n- 동적으로 생성된 코드를 처리할 수 있다.\n- 동적으로 탈부착 가능\n- disassem 할 필요 없음\n- binary 수정할 필요 없음\n- symbol 필요없음\n\n단점 : \n- 런타임시 계측 비용 발생 , 걍 존나 느림\n- DBI library와 tool에 의존적임\n- 구현하기 어려움, 런타임에 실행 코드를 다시 작성하는 것은 쉽지 않음\n","x":2051,"y":1340,"width":789,"height":540},
		{"id":"c56332715bd12fdc","type":"text","text":"암튼 둘다 쓰래기임 ㅇㅇ","x":2720,"y":2000,"width":293,"height":60},
		{"id":"8200e6fac8017ed1","type":"text","text":"Static rewriting (Static Binary Instrumentation)\n\n정적으로 바이너리를 재작성하는 방식으로 바이너리를 실행시키기 직전에 바이너리를 변형시키는 방식이다.\n\n장점 : \n- DBI에 비해 비교적 빠름\n- binary가 독립적으로 실행 가능\n\n단점:\n- 동적으로 생성된 코드가 지원되지 않음\n- 전체 실행을 계측해야한다\n- \n","x":2900,"y":1340,"width":789,"height":540},
		{"id":"989a6f4bbb2088d7","type":"text","text":"### 최근 fuzzer의 공통적인 한계\n\n그레이박스 퍼징에 대한 최근 연구들은 몇 가지 공통적인 한계를 가지고 있다.\n\n1. binary 전용 퍼징 지원이 없다.\n   대부분의 그레이박스 퍼징은 소스 코드를 필요로하고 실제로 대부분 업체는 소스코드를 제공하지 않는다. \n   \n2. 느린 피드백 메커니즘\n   소스 코드 의존성을 해결하기 위해 dynamic binary 계측, static 재작성, 에뮬레이션과 같은 여러 피드백 메커니즘이 도입되었지만 싹다 성능이 구림.\n\n3. 부정확한 coverage feedback\n   AFL은 코드 커버리지를 측정하기 위해 비트멥을 사용하는데 이 비트맵의 키가 되는 해시값이 해시 충돌이 발생할 수 있다. 그러면 퍼징 루프는 일부 중요한 시드를 잃을 수 도 있고, 불완전할 수 있다. ","x":-1160,"y":1518,"width":797,"height":442},
		{"id":"a56b26a9652a6575","type":"text","text":"```\n그러나 그레이박스 퍼징에 대한 최근 연구들은 몇 가지 공통적인 한계를 가지고 있다. 우리는 다음과 같이 이전 연구들의 세 가지 단점을 나열할 수 있다.\n```","x":-103,"y":1620,"width":903,"height":164},
		{"id":"5cd2e38fbd96195f","type":"text","text":"# 1. INTRODUCTION\n```\n컴퓨터나 스마트폰의 소프트웨어는 이미 웹 브라우저, 플레이어 및 문서 프로세서와 같은 일상 생활의 일부가 되었습니다. 그러나 소프트웨어의 취약점은 여전히 일상화되어 있어 개인 사용자 또는 기업 사용자가 위험에 처해 있습니다. 그 결과 소프트웨어 보안에 대한 연구가 증가하고 있습니다.\nSymbolic 실행 및 퍼징은 소프트웨어 테스트 및 디버깅 기술의 주요 두 부분입니다. Symbolic 실행 엔진은 소스 코드에 직접 적용되어 취약점을 효과적으로 감지할 수 있습니다. 그러나 Symbolic 실행은 대상 프로그램에서 많은 수의 경로를 트리거하고 결국 경로 폭발을 초래합니다. 이와 대조적으로, 퍼징은 일반 입력의 가능한 값을 탐색하여 경로 폭발 위험을 피합니다. \n그리고 퍼징 기술은 프로그램에서 얻은 정보에 따라 분류할 수 있으며, 화이트박스, 그레이박스 및 블랙박스 로 구분됩니다. 화이트박스 퍼징은 전통적인 프로그램 분석 기술을 사용하여 대상의 속성을 찾을 수 있으며, 이는 시간이 많이 걸릴 수 있습니다. 한편, 블랙박스 퍼징은 대상 프로그램에 대한 정보를 전혀 가지고 있지 않습니다. 그레이박스 퍼징은 추가 정보를 채택하여 퍼징의 효율성을 향상시키면서 블랙박스의 단순성을 유지하려고 합니다. 또한, 전통적인 퍼징은 버그를 감지하는 데 비교적 구식입니다. 아무런 지침 없이 블라인드 퍼징과 입력 시드의 무작위 mutate는 프로그램에서 원하는 브랜치에 부딪힐 가능성이 매우 낮아 일부 취약점은 실행 경로에 깊숙이 묻혀 노출되기 어렵습니다. \n그레이박스 퍼징은 전통적인 퍼징 기술의 훌륭한 확장입니다. 많은 오버헤드 없이 프로그램을 분석하는 것이 효과적인 퍼징 시도입니다. 그레이박스 퍼징은 경량 계측기 또는 기타 메커니즘을 사용하여 메인 퍼징 루프에 대한 코드 커버리지와 같은 프로그램 실행 피드백을 제공합니다. 위에서 언급한 바와 같이, 초기 입력 시드는 mutate되어 프로그램 경로를 연습하기 위한 테스트 케이스를 생성합니다. 예를 들어, 코드 커버리지 피드백을 활용하는 퍼저에서 특정 테스트 케이스가 새로운 경로에 도달하면 퍼저는 연속 퍼징 루프를 위한 새로운 입력 시드로 유지하여 훨씬 더 많은 시드를 생성합니다. 그레이박스 퍼징 기술에 대한 최근 연구가 많은 관심을 끌고 있습니다. 아메리칸 퍼지 루프(AFL)는 이 분야의 선구자적인 작업입니다. 코드 커버리지 피드백 정보를 제공하기 위해 간단하지만 견고한 컴파일 시간 계측을 채택합니다. \n이하생략 - 안중요\n```","x":-103,"y":700,"width":903,"height":840},
		{"id":"9a1635fcd3f9698e","type":"text","text":"# 요약","x":-833,"y":1420,"width":144,"height":59},
		{"id":"75566fc4417b4377","type":"text","text":"## The purpose of This Study\n\n- 1장 내용, 초록\n- 5장 내용\n\n## Lit. Review\n\n- 2장, 리뷰하고 어떻게 사용할지 정리\n\n### 소제목 모음\n\n#### 소제목 \n#### 소제목 2\n\n## Methods\n\n- 3장, 어떻게, 방법,\n\n## Results & Discussion\n\n- 4장, 5장 결과, 논의\n\n## Critique\n\n- 이 논문을 가지고 어떻게 써먹을 것인지","x":-2400,"y":1308,"width":673,"height":790},
		{"id":"fed585567e1d50b2","type":"text","text":"### 논문의 주요 내용\n\n본 논문은 하드웨어 메커니즘인 Intel Processor Trace를 활용하여 분기 정보를 수집하는 PTfuzz라는 그레이 박스 퍼징 접근 방식을 제안한다.\n\n해당 접근 방식은 에뮬레이션 방법과 마찬가지로 바이너리 프로그램을 지원하고 반면 컴파일 시간 계측 방법과 비슷한 성능(속도)를 얻는다. QAFL(Qemu)에 비해 3배의 성능 향상을 얻는다.","x":-1160,"y":189,"width":797,"height":280},
		{"id":"ac54bf873d892019","type":"text","text":"# PTfuzz: Guided Fuzzing With Processor Trace Feedback","x":-103,"y":-80,"width":903,"height":109},
		{"id":"8f84973825b753ff","type":"text","text":"# 3. MODEL OVERVIEW\n\n```\n이 섹션에서는 모델과 PTfuzz의 퍼징 단계를 소개합니다. 그레이박스 퍼징으로서 PTfuzz는 AFL의 퍼징 아키텍처를 따릅니다. 초기 시드 파일로 시작하여 가능한 한 많은 프로그램 경로를 연습하기 위해 새로운 시드를 생성하려고 노력합니다. 그림 1과 같이 PTfuzz에는 주로 두 가지 관련 부분이 포함됩니다: 메인 퍼징 루프와 PT 인프라. \n메인 퍼징 루프는 부모 스레드로 작동하며 작업에는 다음이 포함됩니다. \n- configuration. 이 부분에는 화면 디스플레이 초기화, 입력 시드 파일 위치 찾기, 신호 설정, 시간 설정 및 기타 구성이 포함됩니다. 이 구성 단계는 이후의 퍼징 단계에 필수적입니다. \n- COFI 맵을 미리 구축하고 MSR 레지스터를 작성합니다. 대상 바이너리가 로드되고 명령어가 덤프되어 디코딩 목적으로 II-C 섹션에서 언급한 COFI 맵을 구성합니다. 그리고 특정 MSR 레지스터는 PT 프로세스를 위한 IP 필터링을 설정하기 위해 작성됩니다. \n- load seed. 입력 시드는 큐에 순차적으로 나열됩니다. 마지막 시드의 실행이 완료될 때마다 자동으로 큐의 다음 시드가 로드됩니다. \n- mutate. mutate는 여러 테스트 케이스를 생성하기 위해 시드의 특정 부분을 변경하는 것을 의미합니다. 그리고 결정론적 돌연변이와 비결정론적 돌연변이로 분류할 수 있습니다. 결정론적 돌연변이에는 길이와 스텝오버가 다른 순차적 비트 플립, 작은 숫자를 추가 또는 차감하고 알려진 정수를 삽입하는 것이 포함됩니다. 그리고 비결정론적 돌연변이에는 스택형 비트 플립, 삽입, 삭제 및 스플라이싱이 포함됩니다. 예를 들어 시드가 있고 그 내용은 \"10011\"입니다. 프로그램 파서는 다음 코드를 실행하기 위해 \"10010\"을 읽어야 합니다. 분명히 이 시드는 프로그램 파서를 통과할 수 없습니다. 첫 번째 비트에서 비트 플립이 이루어지면 이 시드는 테스트 케이스 '10010'으로 변하며 이 테스트 케이스는 프로그램 파서를 통과하고 다음 코드가 실행됩니다. \n- 실행. mutate 또는 테스트 케이스가 생성된 후 프로그램 실행을 위한 입력으로 간주됩니다. \n- 포크(Fork). 실행 초기에 자식 스레드가 호출되어 포크(Fork)에 의한 프로세서 트레이스 인프라로 수행됩니다. 그리고 이 자식 스레드는 실행이 완료된 후에 다시 생성되며 디코딩된 tracing data는 부모 스레드로 전송됩니다. \n- 저장하거나 폐기합니다. 테스트 케이스의 실행이 끝나면 메인 퍼징 루프는 PT 인프라에서 제공하는 정보를 기반으로 저장할지 폐기할지 결정해야 합니다. 저장된 테스트 케이스는 지속적인 퍼징을 위해 시드 큐에 넣어집니다. \n- 표시 및 보고합니다. 퍼징이 실행 중일 때는 퍼징 상태를 모니터링하기 위해 화면 표시가 필요합니다. 또한 퍼징이 종료된 후에는 메인 퍼징 루프에 의해 실행 중인 모든 정보에 대한 상세 보고서가 생성됩니다.\n\n위에서 언급한 바와 같이 프로세서 트레이스 인프라는 fork()를 통해 메인 퍼징 루프에 의해 생성됩니다. 그리고 주로 이러한 작업을 완료합니다. \n- PT 사용. 프로그램 실행의 지속적인 추적을 수행하려면 프로세서 트레이스를 사용해야 합니다. fork() 작업 후 PT 인프라는 프로그램 실행 초기에 PT를 사용하도록 설정합니다. \n- 추적 데이터를 기록합니다. PT를 사용하도록 설정한 후 프로그램 실행 정보를 non-stop으로 캡처합니다. 그리고 PT 인프라는 PT를 사용하도록 설정한 후 추적 데이터를 저장할 특정 메모리 공간을 지정합니다. 따라서 PT는 이 특정 공간에 추적 데이터를 쓸 수 있습니다. \n- 추적 데이터를 디코딩합니다. 우리의 목적은 프로그램 실행에서 기본 블록 전이를 찾는 것이므로 PT 인프라는 II-C 섹션에 설명된 대로 원시 추적 데이터를 디코딩하고 TNT, TIP 및 FUP 패킷을 캡처합니다. 그리고 기본 블록 전이는 비트맵에 기록되어 메인 퍼징 루프가 액세스하여 결정을 내릴 수 있습니다. \n- 비활성화 PT. 실행이 끝나면 PT가 비활성화되고 PT에 의해 기록되는 것이 없습니다. \n \n그리고 나서 모델의 실행 단계를 자세히 설명하겠습니다. 그림 2에 표시된 바와 같이, 구체적으로 PTfuzz는 다음과 같이 작동합니다. \n- (1) 메인 퍼징 루프는 화면 초기화, 입력 시드 파일 위치 찾기, 신호 설정, 타이머 설정 및 기타 관련 이벤트를 표시합니다. \n- (2) 대상 바이너리는 메모리에 로드되고 텍스트 섹션의 명령어는 COFI 맵을 구축하기 위해 덤프됩니다. 그리고 CPU의 MSR 레지스터는 IP 필터링이 설정되도록 수정됩니다. \n- (3) 시드 큐에 하나의 시드가 로드되고 mutate 준비가 됩니다. \n- (4) 이 시드는 결정론적 및 비결정론적 돌연변이를 수행하기 위해 돌연변이 엔진에 주어져 여러 테스트 케이스가 생성됩니다. \n- (5) 돌연변이로 인한 테스트 케이스는 하나씩 실행을 위해 대상 프로그램에 입력됩니다. \n- (6) 실행 초기에 메인 퍼징 루프는 fork()로 자식 스레드를 호출하므로 프로세서 트레이스 인프라는 활성화됩니다. \n- (7) PT 인프라는 포크된 직후 PT를 활성화합니다. \n- (8) PT 추적 데이터는 특정 메모리 공간에 기록됩니다. \n- (9) 추적 데이터를 디코딩하여 기본 블록 전이를 노출시키고 비트맵을 업데이트하여 메인 퍼징 루프가 액세스하여 의사 결정을 내릴 수 있도록 합니다. \n- (10) 실행이 완료된 후 PT가 비활성화됩니다. \n- (11) 이 자식 프로세스는 거두어져 PT 인프라가 활성화되지 않습니다. \n- (12) PT 피드백에 따라 테스트 케이스에 의해 트리거된 새로운 기본 블록 전이가 있는 경우 메인 퍼징 루프는 이 특정 테스트 케이스를 저장하고 시드의 큐에 넣으며, 새로운 전이가 감지되지 않으면 이 테스트 케이스는 폐기됩니다. \n\n(12) 단계 후 메인 퍼징 루프는 큐에 다음 시드를 로드하고 퍼징의 다음 루프를 시작합니다. PTfuzz는 사용자가 제공한 초기 시드부터 시작해야 합니다. 그리고 이 논문에서는 초기 시드를 선택하는 방법에 대해 논의하지 않을 것입니다. 또한 PTfuzz는 프로그램 충돌, 실행 속도 및 히트 브랜치 수를 시간 내에 보고할 수 있습니다. 마지막으로 PTfuzz는 사용자의 중지로 끝납니다\n\n```","x":-103,"y":8220,"width":903,"height":2040},
		{"id":"b1fd8a8eea027f8e","type":"text","text":"![](https://i.imgur.com/s8fkESS.png)","x":940,"y":9022,"width":957,"height":616},
		{"id":"6007dd2a540f6069","type":"text","text":"# 4. IMPLEMENTATION\n\n```\n섹션 III에서 설명한 모델 개요를 기반으로 프로토타입 PTfuzz를 구현합니다. 구현에 대한 몇 가지 세부 사항은 다음에서 설명하겠습니다. \n- COFI 맵 구축. 섹션 II-C에 설명된 바와 같이 COFI(Change of Flow Instruction)는 프로세서 트레이스의 제어 흐름 시퀀스입니다. 대상 프로그램이 로드되면 이를 덤프하여 텍스트 섹션의 모든 명령과 IP 주소 범위를 추출할 수 있습니다. 구현에서는 Python-CLE을 채택하여 바이너리를 로드하고 CAPSTONE를 채택하여 텍스트 섹션을 덤프합니다. PT 트레이스 패킷을 디코딩하려면 COFI 맵이 필요하며, 이를 사전 구축하면 PTfuzz는 상당한 디코딩 시간을 절약하고 실행 오버헤드를 크게 줄일 수 있습니다. \n- MSR 작성 및 IP 필터링 설정. 인텔의 프로그래밍 가이드 [21]에 설명된 바와 같이 특정 MSR 레지스터를 설정하여 PT 패킷 생성을 필터링할 수 있습니다. PTfuzz에서는 일부 라이브러리 또는 시스템 호출을 포함하지 않고 대상 바이너리의 IP 범위에서만 PT 패킷을 디코딩하기만 하면 됩니다. 따라서 저희는 msr - tools 3을 따라 MSR 레지스터를 작성하고 PT 패킷 생성을 대상 바이너리로 제한합니다. 이렇게 하면 PTfuzzz를 디코딩하면 수많은 관련 없는 PT 패킷을 피할 수 있고 뚜렷한 성능 향상을 얻을 수 있습니다. \n- 퍼징에서 PT를 활성화 및 비활성화합니다. 인텔의 시스템 프로그래밍 가이드에 설명된 바와 같이 모델별 레지스터(MSR)의 특정 비트를 1로 설정하여 인텔 PT[21]를 활성화해야 합니다. PT를 활성화한 후 CPU의 모든 실행 정보를 추적합니다. 그러나 MSR을 설정하는 것은 사용자 수준의 구획에서 직접 수행할 수 없습니다. 따라서 PTfuzz에서는 이러한 MSR 설정 작업을 수행하기 위해 시스템 호출 ioctl()을 사용합니다. 자세히 말하면 메인 퍼징 루프에서 하위 스레드를 호출하여 ioctl()로 PT를 활성화하고 프로그램 실행 추적을 시작합니다. 하위 스레드는 퍼징 반복이 끝나면 ioctl()로 PT를 비활성화합니다. \n- 프로세서 트레이스 출력. Simple-PT [35]와 같은 PT에 대한 이전 작업은 할 수 없습니다. 그래서 PTfuzz에서는 perf_event [36]에서 mmap_page 기능을 사용합니다. 이 기능은 추적 데이터를 저장하기 위해 특정 메모리 공간을 구성합니다. 그리고 PTfuzz는 이 메모리에 추적 정보를 기록합니다. 메모리에 액세스하는 것은 파일보다 훨씬 빠를 수 있고 메인 퍼징 루프와의 상호 작용은 시기적으로 적절합니다. \n- PT 정보 디코딩. PT 정보가 메모리에 기록된 후 기본 블록 전이를 찾기 위해 디코딩해야 합니다. 그리고 인텔은 자체 PT Decoder Library [37]을 제안했습니다. 그러나 이는 범용 디코더이며 기본 블록 전이를 추적하는 API를 제공하지 않기 때문에 우리의 요구에 잘 맞지 않습니다. 그래서 우리는 시스템 프로그래밍 가이드 [21]을 기반으로 PTfuzz를 위한 새로운 디코더를 작성합니다. 우리의 디코더는 프로그램 실행에서 기본 블록 전이에만 집중하는 특수한 용도입니다. 지정된 메모리 공간의 정보에 액세스하고 추적 데이터를 디코딩하여 메인 퍼징 루프에 필요한 것을 찾습니다\n```","x":-103,"y":10400,"width":903,"height":900},
		{"id":"383e56995edcefc6","type":"text","text":"![](https://i.imgur.com/tSLPnWT.png)","x":896,"y":8360,"width":1001,"height":414},
		{"id":"b0f85c024bb7dcfc","type":"text","text":"# PTfuzz의 퍼징 단계\n\nPTfuzz는 그레이박스 퍼징으로서 AFL의 퍼징 구조를 따른다. 초기 시드 파일로 시작하여 가능한 한 많은 프로그램 경로를 연습하기 위해 새로운 시드를 생성하려고 노력한다. 그림1과 같이 PTfuzz는 메인 퍼징 루프와 PT 인프라를 포함한다.\n\n메인 퍼징 루프는 부모 스레드로 작동하며 작업에는 다음이 포함됩니다. \n```\n- configuration\n- COFI 맵을 미리 구축하고 MSR 레지스터를 작성합니다. \n- load seed.  \n- mutate.  \n- 실행. \n- 포크(Fork). PT infra를 수행한다, 디코딩된 tracing data는 부모 스레드로 전송된다. \n- 저장하거나 폐기합니다.  \n- 표시 및 보고합니다. \n```\n\nPT infra는 다음과 같은 작업을 한다.\n\n```\n- PT 사용. fork() 작업 후 PT 인프라는 프로그램 실행 초기에 PT를 사용하도록 설정합니다. \n- 추적 데이터를 기록합니다. PT를 사용하도록 설정한 후 프로그램 실행 정보를 non-stop으로 캡처합니다. 그리고 PT 인프라는 PT를 사용하도록 설정한 후 추적 데이터를 저장할 특정 메모리 공간을 지정합니다. 따라서 PT는 이 특정 공간에 추적 데이터를 쓸 수 있습니다. \n- 추적 데이터를 디코딩합니다. 기본 블록 전이는 비트맵에 기록되어 메인 퍼징 루프가 액세스하여 결정을 내릴 수 있습니다. \n- 비활성화 PT. 실행이 끝나면 PT가 비활성화되고 PT에 의해 기록되는 것이 없습니다. \n```\n\n결론적으로 PTfuzz는 다음과 같이 작동한다.\n```\n- (1) 메인 퍼징 루프는 화면 초기화, 입력 시드 파일 위치 찾기, 신호 설정, 타이머 설정 및 기타 관련 이벤트를 표시합니다. \n- (2) 대상 바이너리는 메모리에 로드되고 텍스트 섹션의 명령어는 COFI 맵을 구축하기 위해 덤프됩니다. 그리고 CPU의 MSR 레지스터는 IP 필터링이 설정되도록 수정됩니다. \n- (3) 시드 큐에 하나의 시드가 로드되고 mutate 준비가 됩니다. \n- (4) 이 시드는 결정론적 및 비결정론적 돌연변이를 수행하기 위해 돌연변이 엔진에 주어져 여러 테스트 케이스가 생성됩니다. \n- (5) 돌연변이로 인한 테스트 케이스는 하나씩 실행을 위해 대상 프로그램에 입력됩니다. \n- (6) 실행 초기에 메인 퍼징 루프는 fork()로 자식 스레드를 호출하므로 프로세서 트레이스 인프라는 활성화됩니다. \n- (7) PT 인프라는 포크된 직후 PT를 활성화합니다. \n- (8) PT 추적 데이터는 특정 메모리 공간에 기록됩니다. \n- (9) 추적 데이터를 디코딩하여 기본 블록 전이를 노출시키고 비트맵을 업데이트하여 메인 퍼징 루프가 액세스하여 의사 결정을 내릴 수 있도록 합니다. \n- (10) 실행이 완료된 후 PT가 비활성화됩니다. \n- (11) 이 자식 프로세스는 거두어져 PT 인프라가 활성화되지 않습니다. \n- (12) PT 피드백에 따라 테스트 케이스에 의해 트리거된 새로운 기본 블록 전이가 있는 경우 메인 퍼징 루프는 이 특정 테스트 케이스를 저장하고 시드의 큐에 넣으며, 새로운 전이가 감지되지 않으면 이 테스트 케이스는 폐기됩니다. \n```\n\n(12) 단계 이후 메인 퍼징 루프는 다음 시드를 로드하고 퍼징의 다음 루프를 시작한다.","x":-1160,"y":8375,"width":797,"height":1465},
		{"id":"dd160934de686702","type":"text","text":"# 구현\n\nPTfuzz의 구현에 대한 세부사항은 다음과 같다.\n\n```\n- COFI 맵 구축. 대상 프로그램이 로드되면 이를 덤프하여 텍스트 섹션의 모든 명령과 IP 주소 범위를 추출할 수 있다. 구현에서는 Python-CLE을 채택하여 바이너리를 로드하고 CAPSTONE를 채택하여 텍스트 섹션을 덤프합니다. PT 트레이스 패킷을 디코딩하려면 COFI 맵이 필요하며, 이를 사전 구축하면 PTfuzz는 상당한 디코딩 시간을 절약하고 실행 오버헤드를 크게 줄일 수 있습니다. \n- MSR 작성 및 IP 필터링 설정. 특정 MSR 레지스터를 설정하여 PT 패킷 생성을 필터링할 수 있다. PTfuzz에서는 일부 라이브러리 또는 시스템 호출을 포함하지 않고 대상 바이너리의 IP 범위에서만 PT 패킷을 디코딩하기만 하면 된다. 따라서 우리는 msr - tools 3을 따라 MSR 레지스터를 작성하고 PT 패킷 생성을 대상 바이너리로 제한합니다. 이렇게 하면 PTfuzzz를 디코딩하면 수많은 관련 없는 PT 패킷을 피할 수 있고 뚜렷한 성능 향상을 얻을 수 있습니다. \n- 퍼징에서 PT를 활성화 및 비활성화합니다. 모델별 레지스터(MSR)의 특정 비트를 1로 설정하여 인텔 PT[21]를 활성화해야 한다. 그러나 MSR을 설정하는 것은 사용자 수준의 구획에서 직접 수행할 수 없어서 이러한 MSR 설정 작업을 수행하기 위해 시스템 호출 ioctl()을 사용한다. 하위 스레드는 퍼징 반복이 끝나면 ioctl()로 PT를 비활성화합니다. \n- 프로세서 트레이스 출력. Simple-PT [35]와 같은 PT에 대한 이전 작업은 할 수 없습니다. 그래서 PTfuzz에서는 perf_event [36]에서 mmap_page 기능을 사용합니다. 이 기능은 추적 데이터를 저장하기 위해 특정 메모리 공간을 구성합니다. 그리고 PTfuzz는 이 메모리에 추적 정보를 기록합니다. 메모리에 액세스하는 것은 파일보다 훨씬 빠를 수 있고 메인 퍼징 루프와의 상호 작용은 시기적으로 적절합니다. \n- PT 정보 디코딩. 디코딩을 위해서는 인텔은 자체 PT Decoder Library [37]을 제안했다. 그러나 이는 우리의 요구에 잘 맞지 않는다. 그래서 우리는 시스템 프로그래밍 가이드 [21]을 기반으로 PTfuzz를 위한 프로그램 실행에서 기본 블록 전이에만 집중하는 특수한 새로운 디코더를 작성한다.\n```","x":-1160,"y":10364,"width":797,"height":836},
		{"id":"12e995161c7eaddc","type":"text","text":"# EXPERIMENT\n\n소스 코드가 제공될 경우에 AFL과 비교해서는 7%정도 느리다. 이는 디코더 때문인데 7%정도는 넘어갈 수 있다.\n\n소스 코드가 제공되지 않는 경우 모든 fuzzer보다 월등히 높은 성능이다.\n\n10개의 프로그램을 대상으로 다른 퍼저와 함께 퍼징 한 결과 모든 target에 대해서 같거나 혹은 더 많은 취약점을 찾을 수 있다. 즉 코드 커버리지는 훨씬 좋다는 것이다.","x":-1160,"y":11520,"width":797,"height":310},
		{"id":"0bb7e76f9bb94d12","type":"text","text":"```\nC. 인텔 프로세서 트레이스 \n이 섹션에서는 인텔 프로세서 트레이스를 간략하게 소개합니다. 브로드웰 아키텍처와 차세대 코어 프로세서를 통해 인텔은 프로그램 실행에 대한 추적 데이터를 캡처하는 인텔 아키텍처의 확장인 프로세서 트레이스[14]라는 새로운 하드웨어 기능을 제안했습니다. 인텔 PT는 잘 설계된 하드웨어 설비로, 추적되는 프로그램에 최소한의 성능 오버헤드만 발생시킵니다. 인텔 라스트 브랜치 레코드와 같은 이전 하드웨어 기능도 프로그램 추적을 수행하지만 출력은 메인 메모리 대신 특수 레지스터에 저장됩니다. 인텔 PT는 메모리 공간을 활용하여 추적 데이터를 저장하므로 연속 PT 추적은 메인 메모리 크기로만 제한됩니다. 따라서 PT의 이 출력 기능으로 지속적인 퍼징 작업과 프로그램 실행을 수행할 수 있습니다. \n구체적으로 PT의 출력은 데이터 패킷 형식으로 수집됩니다[21]. 패킷은 기능에 따라 기본 실행 정보 패킷과 제어 흐름 정보 패킷의 두 가지 유형으로 분류할 수 있습니다. 패킷 스트림 바운더리(PSB), TSC(Time-Stamp Counter) 및 기타 관련 패킷은 일반적인 프로그램 실행 상태를 보여주는 기본 실행 정보입니다. 그리고 PT의 초기 구현에서 제어 흐름 추적 패킷은 소프트웨어 디코더에 의해 처리되도록 제공됩니다. 제어 흐름 정보는 실행 시간 동안의 시간, 프로그램 흐름 및 기타 정보를 포함합니다.\n기본 블록은 점프나 브랜치가 없는 연속적인 코드 섹션입니다. 본 논문에서는 기본 블록 간의 전이를 포착하기 위해서 점프 대상, 브랜치 테이크/not테이크 된 것과 같은 프로그램 흐름 정보에 집중해야 합니다. 그리고 메모리 공간의 프로그램 흐름 추적 데이터를 디코딩하기 위해서는 특별히 설계된 디코더가 필요합니다. 인텔 PT는 프로그램 흐름을 변경할 수 있는 명령어를 COFI(Change of Flow Instructions)로 지정합니다. COFI 명령어에는 직접 전송 COFI, 간접 전송 COFI 및 파 전송 COFI의 세 가지 유형이 도입됩니다. \n\n또한 Intel PT는 COFI instruction을 추적하기 위해 4개의 특정 패킷을 도입합니다:  \n• TNT(Taken Not-Taken) 패킷. TNT 패킷의 특정 비트는 조건부 점프에서 분기가 취해지는지 여부를 나타낼 수 있습니다. 따라서 조건부 분기의 방향을 추적하는 데 사용됩니다.  \n• TIP(Target IP) 패킷. TIP는 점프 명령 또는 이적 명령의 IP(Target Instruction Pointer)를 기록합니다. IP 값은 이 패킷의 특정 비트에 저장됩니다. 세부적으로 TIP는 다양한 응용 시나리오에 따라 TIP, TIP.PGE, TIP.PGD 및 TIP.FUP으로 분류할 수 있습니다.  \n• FUP(Flow Update Packet). 인터럽트나 트랩과 같은 비동기 이벤트가 발생하면 소스 IP 주소를 제공하기 위해 FUP가 필요한데, 이는 이러한 이벤트에서 TIP가 작동하지 않기 때문입니다.  \n• MODE packet. MODE는 중요한 프로그램 실행 정보를 제공하며 실행 모드를 나타내는 광범위한 형식을 가지고 있습니다\n\n그래서 TNT, TIP, FUP 패킷들의 도움으로 우리는 프로그램 실행에서 기본적인 블록 전이를 포착하는 디코더를 작성할 수 있습니다. 좀 더 구체적으로 우리는 basic 블록의 주소를 기록해야 합니다. 그리고 COFI 명령이 발생하면 basic 블록 간의 제어 흐름 전이를 비트맵에 기록해야 합니다.  \n예를 들어, A에서 B로 간접 점프 명령(예: JMP(FF/4), CALL(FF/2))이 있을 때 디코더는 이것이 TIP 패킷에 속한다는 것을 인식하고 그 안의 IP 주소를 읽을 수 있습니다. 그러면 비트맵 [(A ⊕ B)%BITmap_SIZE]가 1씩 증가하고 우리는 전이 기록을 완료합니다\n```","x":-103,"y":5720,"width":903,"height":1080},
		{"id":"10373e8fa71b9675","type":"text","text":"```\nB. GREYBOX FUZING의 피드백 \n이 절에서는 이전의 그레이박스 퍼징 기법에 대해 자세히 논의할 것입니다. 각 퍼징에 채택된 피드백 메커니즘에 따라 분류하고 몇 가지 공통적인 제한 사항을 지적할 것입니다. 이러한 제한 사항은 우리가 PTFUZZING을 제안하는 원동력입니다.\n\n그레이박스 퍼저의 경우 내장된 피드백 메커니즘이 퍼징 성능을 결정하는 핵심 요소입니다. 저희는 표 1에서 다양한 피드백 메커니즘을 마무리하고 이에 대한 논의는 다음과 같습니다.\n\n- Compile-time instrumentation\n컴파일 시간 계측은 특수 컴파일러를 사용하여 소스 코드와 계측기를 바이너리로 컴파일하는 접근 방식입니다. Vulcan[16], alto[17], Diablo[18]와 같은 이전 작업은 이 분야를 선도하는 작업입니다. AFL, AFLFast 및 Syzkaller[19]와 같은 퍼저는 피드백 메커니즘을 활용하기 위해 컴파일 시간 계측을 채택합니다. 비교적 빠르고 안정적이지만 컴파일 시간 계측의 단점도 분명합니다. 위에서 언급한 바와 같이, 이들은 기본 블록 간의 전환을 기록하여 메인 퍼징 루프에 코드 커버리지 피드백을 제공합니다. 그러나 기본 블록의 주소는 실행 시간에 정확한 주소가 아니라 무작위로 할당된 값입니다. 이것이 정확한 피드백 메커니즘이 아니라고 주장하는 이유입니다. 또한 대상 프로그램을 컴파일하려면 소스 코드가 필요합니다. 따라서 바이너리 전용 퍼징을 컴파일 시간 계측에서는 사용할 수 없습니다. \n\n- Dynamic binary instrumentation\n동적 바이너리 계측은 계측 코드를 통해 실행 시간에 바이너리의 동작을 분석할 수 있습니다. 계측 코드는 주입된 후 원래 코드의 일부로 작동합니다. PIN[10]과 Dynamio[20]이 가장 유명한 작업입니다. 퍼징에서 이러한 종류의 피드백 메커니즘을 활용하면 바이너리 전용 퍼징을 처리할 수 있으며 런타임 계측기 때문에 정확합니다. 그러나 동적 바이너리 계측의 가장 큰 문제는 상당한 오버헤드입니다. 퍼징 작업에서 컴파일 시간 계측보다 느립니다. \n\n- Static rewriting\n정적 재작성은 각 기본 블록에 대한 콜백과 프로그램 진입 지점에 초기화 콜백을 삽입하여 바이너리를 계측합니다[11]. AFL-dyninst는 정적 재작성을 사용하고 이 기술을 사용하여 바이너리를 퍼징합니다. 따라서 정적 재작성은 바이너리 전용 퍼징 작업을 처리할 수 있으며 비교적 빠를 수 있습니다. 그러나 정적 재작성은 불안정하고 위험이 많다는 주요 단점이 있습니다[13]. \n\n- Emulation\nQEMU와 같은 에뮬레이션은 동적 이진 변환을 통해 CPU를 에뮬레이트하며 사용자 모드와 시스템 에뮬레이션이 모두 가능합니다. 그리고 퍼저는 QEMU의 도움으로 사용자 수준의 프로세스를 실행하고 프로그램 실행 흐름을 캡처할 수 있습니다. QAFL과 TriforceAFL은 QEMU를 활용하며 정확한 런타임 피드백으로 바이너리 전용 소프트웨어를 퍼징할 수 있습니다. 그러나 QEMU의 아키텍처로 인해 이러한 접근 방식은 QEMU를 실행하지 않는 것에 비해 2-5배의 높은 오버헤드로 어려움을 겪습니다. 이는 퍼징 바이너리에 견딜 수 없는 오버헤드이며 실제 실무에 적용할 수 없습니다.\n\n- Intel Branch Trace Store\n인텔 브랜치 트레이스 스토어(Intel Branch Trace Store)는 프로세서의 하드웨어 기능입니다. BTS 메커니즘을 통해 사용자는 지정된 버퍼에 브랜치 트레이스를 저장할 수 있습니다. 또한 소스 코드에 의존하지 않고 런타임 정보를 제공할 수 있습니다. BTS는 PT와 유사하지만 CPU에 BTS 플래그를 설정하면 프로세서의 성능을 크게 저하시킬 수 있습니다[21]. 즉, 이렇게 큰 실행 오버헤드를 가진 퍼저를 활용할 수 없습니다. \n\n- Intel Processor Trace\n인텔 프로세서 트레이스(Intel Processor Trace)도 프로세서의 하드웨어 기능이지만 BTS보다 훨씬 진보되어 있습니다. PT는 프로그램 제어 흐름 정보를 정확하게 추적할 수 있으며 이를 기반으로 기본 블록 전환을 기록할 수 있습니다. 가장 중요한 것은 표 1에서 볼 수 있듯이 PT는 많은 성능 오버헤드 없이 작업을 완료할 수 있다는 것입니다. \n\n결론적으로 인텔 프로세서 트레이스 피드백으로 확장된 퍼저는 이진 전용 퍼징에서 기본 블록 전환을 정확하게 기록하는 작업을 완료할 수 있습니다. 또한 매우 빠를 수 있습니다. PT를 기반으로 PT 퍼징은 이전 작업의 문제를 성공적으로 처리합니다. \n```","x":-103,"y":4070,"width":903,"height":1560},
		{"id":"98f5e23cbb36bd18","type":"text","text":"# 결국 얘가 중요한 거임","x":-1340,"y":5687,"width":378,"height":60},
		{"id":"c60fcea2282250f9","type":"text","text":"![](https://i.imgur.com/vgiY7wi.png)","x":860,"y":4480,"width":937,"height":740},
		{"id":"91857625f708f0c4","type":"text","text":"# feedback 매커니즘 성능\n\n성능 지표는 다음과 같다. 표 참고\n\n암튼 결론적으로는 Intel Processor Trace가 짱이라는 것이다.","x":-1160,"y":4573,"width":797,"height":207},
		{"id":"4724d5b970f09823","type":"text","text":"# Intel Processor Trace\n\n인텔은 프로그램 실행에 대한 추적 데이터를 캡처하는 인텔 아키텍처의 확장인 프로세서 트레이스(PT)라는 새로운 하드웨어 기능을 제안했다. 인텔 PT는 잘 설계된 하드웨어 설비로, trace되는 프로그램에 최소한의 성능 오버헤드만 발생시킨다. 인텔 PT는 메모리 공간을 활용하여 tracing data를 저장하므로 연속 PT 추적은 메인 메모리 크기로 제한된다. 따라서 PT의 이 output 기능으로 지속적인 퍼징 작업과 프로그램 실행을 수행할 수 있다.\n\n구체적으로 PT의 output은 데이터 패킷 형식으로 수집된다. 패킷은 기능에 따라 기본 실행 정보 패킷, 제어 흐름 정보 패킷으로 나뉜다. PSB(packet stream boundary), TSC(time-stamp counter) 및 기타 관련 패킷은 일반적인 프로그램 실행 상태를 보여주는 기본 실행 정보이다. 그리고 PT의 초기 구현에서 제어 흐름 추적 패킷은 소프트웨어 디코더에 의해 처리되도록 제공된다. 제어 흐름 정보는 실행 시간 동안의 시간, 프로그램 흐름 및 기타 정보를 포함한다.\n\n메모리 공간의 프로그램 흐름 추적 데이터를 디코딩하기 위해서는 특별히 설계된 디코더가 필요하다. 인텔 PT는 프로그램 흐름을 변경할 수 있는 명령어를 COFI로 지정한다. COFI 명령어에는 직접 전송 COFI, 간접 전송 COFI 및 파 전송 COFI의 세 가지 유형이 도입된다.\n\nIntel PT는 COFI instruction을 추적하기 위해 4개의 특정 패킷을 도입한다.\n\n1. TNT(Taken Not-Taken) 패킷. 조건부 점프에서 분기가 취해지는지 여부를 나타낸다.\n2. TIP(Target IP) 패킷. 점프 혹은 이적 명령의 Instruction Pointer를 기록한다. 세부적으로 다양한 응용 시나리오에 따라 TIP, TIP.PGE, TIP.PGD 및 TIP.FUP으로 분류할 수 있다.\n3. FUP(Flow Update Packet). 인터럽트나 트랩과 같은 비동기 이벤트가 발생하면 소스 IP 주소를 제공하기 위해 FUP가 필요한데, 이는 이러한 이벤트에서 TIP가 작동하지 않기 때문이다.\n4. MODE packet. MODE는 중요한 프로그램 실행 정보를 제공하며 실행 모드를 나타내는 광범위한 형식을 가진다. \n\n그래서 TNT, TIP, FUP 패킷들의 도움으로 우리는 프로그램 실행에서 기본적인 블록 전이를 포착하는 디코더를 작성할 수 있다. 구체적으로 우리는 basic block의 주소를 기록해야 한다. 그리고 COFI 명령이 발생하면 basic block 간의 제어 흐름 전이를 비트맵에 기록해야 한다.","x":-1160,"y":5747,"width":797,"height":913},
		{"id":"36a17f1152d9f595","type":"text","text":"# 2. BACKGROUND\n```\nA. 비트맵 \n1) 비트맵의 정의 \n위에서 언급한 바와 같이, AFL, AFL, Syzkaller와 같은 그레이박스 퍼저는 코드 커버리지 피드백을 활용하여 테스트 케이스를 새 시드로 저장해야 하는지 아니면 폐기해야 하는지 결정합니다. 테스트 케이스가 새 프로그램 경로를 연습하면, 더 많은 테스트 케이스를 생성하기 위해 시드로 저장됩니다. 하지만 테스트 케이스가 새 경로를 연습하는지 여부를 결정하는 방법은 무엇일까요? 몇 가지 선택 사항이 있습니다. 총 블록(TBL), 새 블록(NBL), 총 분기(TBR) 및 새 분기(NBR) 커버리지입니다. (본 논문에서는 분기와 기본 블록 전이가 동일합니다. ) total은 적중 블록 또는 분기의 전체 수를 나타내고, new은 새로운 블록 또는 분기가 필요하다는 것을 나타냅니다. 예를 들어, TBL에서 테스트 케이스 T 1이 기본 블록 A에 hit하고, T 2가 블록 A와 B에 hit하면, T 2가 새 경로를 연습하는 것으로 결정할 수 있습니다. NBL에서 T 3이 basic 블록 A에 hit하고, T 4가 블록 B에 hit하면, T 4가 새 경로를 연습하는 것으로 결정할 수 있습니다. 그러나 T 3과 T 4의 적중 블록 수는 같기 때문에, T 4는 TBL에서 새 경로를 연습하는 것으로 간주되지 않습니다. TBR과 NBR도 마찬가지입니다. AFL의 Zalewski[6]는 4가지 방법에 대한 실험을 수행한 결과, NBR의 성능이 가장 우수하다는 것을 발견했습니다. 따라서 AFL에서는 테스트 케이스가 새 분기에 hit하면, 새 경로를 연습하는 것으로 간주되어 시드로 저장됩니다. 그리고 모든 적중 분기는 비트맵이라는 특정 메모리 공간에 기록됩니다. 예를 들어, A에서 B로 분기가 있는 경우, AFL은 먼저 비트맵[(A ⊕B)%BITMAP_SIZE]에 있는 값을 읽어 0인지 확인한 다음, 값에 1을 더합니다. 따라서 처음에 0s로 설정된 비트맵을 읽기만 하면, AFL은 적중 분기가 새 것인지 아닌지를 알고 테스트 케이스를 저장하거나 폐기하기로 결정합니다. 따라서 분기의 충돌과 중첩으로 인해 AFL과 AFLfast의 경우 지표가 상대적으로 낮을 수 있습니다. V절의 이후 실험에서는 AFL이 적중한 분기의 값이 낮다는 것도 입증할 것입니다. 따라서 우리는 AFL과 AFLfast와 같은 퍼저는 부정확한 피드백으로 인해 코드 coverage가 낮다는 결론을 얻을 수 있습니다. 그리고 그들은 깊이 묻혀 있는 버그와 프로그램의 취약성을 노출할 수 없습니다. \n\n2) 비트맵의 값은 무엇을 나타내는가? \n또한 비트맵에 기록된 히트 브랜치의 수는 다양한 퍼징 기법의 코드 커버리지를 비교하는 데 유용한 지표입니다[15]. 즉, 히트 브랜치가 많을수록 코드 커버리지가 증가합니다. 그러나 Zaleewski[6] 자신은 AFL에서 충돌하거나 중첩되는 브랜치의 수는 총 20,00개의 히트 브랜치가 있을 때 14%이고, 50,000개일 때 30%라고 주장했습니다. 따라서 브랜치의 충돌과 중첩으로 인해 AFL과 AFLFast의 경우 지표가 상대적으로 낮을 수 있습니다. 또한 V절의 이후 실험에서 AFL이 히트 브랜치의 값이 낮다는 것을 입증할 것입니다. 따라서 우리는 AFL과 AFLfast와 같은 퍼징은 부정확한 피드백으로 인해 코드 커버리지가 낮다는 결론을 얻을 수 있습니다. 그리고 이들은 프로그램의 깊이 묻혀 있는 버그와 취약점을 노출할 수 없습니다. \n```","x":-103,"y":3000,"width":903,"height":970},
		{"id":"a35498817b9e9407","type":"text","text":"# 이 논문(PTfuzz)의 요약\n\n1. binary 전용 퍼징이다.\n2. 빠른 피드백 메커니즘이다.\n3. 정확한 커버리지 피드백이다.\n   기존 랜덤 ID 할당은 코드 커버리지를 부정확하게 측정한다. PTfuzz는 basic 블록의 실제 런타임 주소를 사용하여 basic 블록 간의 전환을 추적하고 실행 중인 코드의 실제 제어 흐름 정보를 제공할 수 있다,","x":-1160,"y":2307,"width":797,"height":293},
		{"id":"d4594b408b4da369","type":"text","text":"```\nD. 심볼릭 실행 및 퍼징 \n소프트웨어의 취약점은 여전히 일반적인 것으로, 개별 사용자 또는 기업 사용자를 위험에 빠뜨립니다. 소프트웨어의 취약점과 버그를 탐지하기 위해 소스 코드를 검사하고 알려진 특정 패턴을 일치시킬 수 있으며, 이는 정적 분석 접근 방식입니다. 그러나 기능적 정확성 버그와 같은 많은 클래스의 취약점은 코드를 실행하지 않고는 찾기 어렵습니다. 그리고 코드 실행으로 버그를 노출하는 것을 동적 접근 방식이라고 합니다. 코드 실행의 문제와 관련하여, 심볼릭 실행과 더 가벼운 퍼징 기법에 대한 많은 논의가 있었습니다[7]. \n심볼릭 실행과 퍼징은 소프트웨어 테스트 및 디버깅 기술의 주요 두 부분입니다. 심볼릭 실행 엔진은 소스 코드에 직접 적용할 수 있습니다. 이들은 프로그램 분석을 사용하여 애플리케이션을 해석하고, 심볼 변수로 사용자 입력을 모델링하고, 조건부 점프에 의해 생성된 제약 조건을 추적하고 제약 조건 해결을 채택하여 특정 프로그램 경로를 커버하는 흥미로운 입력을 생성합니다. 베리테스트[22], 피말라이스[23], 제약 조건 없는 실행[24]과 같은 심볼릭 실행 엔진은 요즘 큰 관심을 받고 있습니다. 한편, 최근 컴퓨팅 성능이 향상됨에 따라 콘콜릭 실행(동적 심볼 실행이라고도 함)이 인기를 얻고 있습니다. 그리고 고성능 도구가 많이 있습니다: EXE[2], KLEE[3], 메이헴[4] 및 S2E[5]. 유망한 특성에도 불구하고, 심볼릭 콘콜릭 실행은 모두 심볼릭 실행의 내부 작업 구조로 인해 잘 알려진 경로 폭발 문제를 겪고 있습니다. 또한 심볼릭 실행 도구는 심볼릭 값과 엄청난 양의 제약 조건 해결을 가진 프로그램을 자동으로 분석할 수 있습니다. 대상 프로그램에서 많은 경로를 트리거하고 경로 폭발을 초래합니다. 한편, 퍼징은 버그와 취약점을 노출하는 효율적인 테스트 기술입니다. 초기 입력 시드가 주어지면 가능한 한 많은 프로그램 경로를 연습하고 커버하기 위해 간단한 mutate로 많은 새로운 테스트 사례를 생성할 수 있습니다. 오늘날 대부분의 취약성은 집중적인 프로그램 분석을 활용하지 않는 특히 경량 퍼저에 의해 노출됩니다[6].\n\n이와 대조적으로, 퍼징은 일반 입력의 가능한 값을 탐색하고 특정 값을 포착하여 프로그램 구획 간의 실행 흐름을 유도함으로써 경로 폭발 위험을 피합니다. 다우싱[25], 브로그[26], 플레이어[27] 및 버즈퍼즈[28]와 같은 기존 퍼저는 정확한 정보가 부족하여 퍼징은 다양한 조건부 점프를 해결할 수 없고 프로그램에서 더 깊은 실행을 할 수 없습니다. 드릴러[1]는 symbolic 실행과 퍼징을 모두 결합하여 위의 문제를 해결하기 위한 하이브리드 접근 방식을 제안했습니다. \n한편, 퍼징 기술은 프로그램에서 얻은 지식에 따라 분류할 수 있습니다. 일반적으로 화이트박스 퍼저는 대상 프로그램에 대한 전체 정보를 가지고 있으며 기존 프로그램 분석 기술을 사용하여 대상의 속성을 파악할 수 있습니다. SmartFuzzz[29], 버즈퍼즈[28], 뷰저[8] 및 TaintScope[30]을 포함한 화이트박스 퍼저는 예상 성능을 달성하고 실제 시나리오에 적용할 수 있습니다. 그레이박스 퍼저는 특정 피드백 정보를 사용하여 '블라인드' 퍼징 프로세스를 향상시킵니다. 이러한 종류의 퍼징은 추가 정보를 채택하여 퍼징의 효과를 향상시키면서 블랙박스의 단순성을 유지하려고 합니다. AFL[31] 및 AFLFast[7]은 그레이박스 퍼저를 가장 성공적으로 표현한 것입니다. 한편, 블랙박스 퍼저는 대상 프로그램에 대한 정보가 전혀 없습니다. 최근 새로운 아이디어가 블랙박스 퍼저에 투입되고 라담사[32], zzuf[33] 및 피치[34]가 이 분야에서 주목할 만한 작업을 했습니다. 이러한 종류의 퍼저 분류는 대상 프로그램과의 상호 작용을 기반으로 하며 커널을 퍼징하는 데 사용할 수 있는지 여부에 따라 비커널 및 커널 퍼저로 분류할 수도 있습니다[19].\n```","x":-103,"y":6960,"width":903,"height":1060},
		{"id":"56aae6111ff0cba9","type":"text","text":"```\nBinary 전용 퍼징 지원은 없다. \nAFL, AFLFast 및 VUzzer와 같은 그레이박스 퍼징은 모두 대상 프로그램의 소스 코드에 의존합니다. AFL 및 AFLFast는 기본 블록 전이 및 코드 범위를 추적하기 위해 비트맵을 사용합니다(비트맵에 대한 자세한 내용은 II-A 섹션에서 제공됨). 각 기본 블록에는 컴파일타임 계측에서 무작위로 할당된 id가 있습니다. 그리고 이러한 종류의 계측은 소스 코드 없이는 수행할 수 없습니다. VUzzer의 경우도 마찬가지인데, 정적 및 동적 분석에서 제어 및 데이터 흐름 기능을 가진 프로그램을 분석하기 때문입니다. VUzzer는 일반적인 애플리케이션 인식 퍼징 기술입니다. Binary 전용 지원이 없는 퍼징은 컴파일타임 계측 또는 소스 코드를 사용할 수 없는 상황에 채택할 수 없습니다. 안타깝게도 많은 소프트웨어 공급업체에서 소프트웨어의 소스 코드를 제공하지 않는 것을 선호합니다. 따라서 Binary 전용 지원이 없는 퍼징은 취약점과 버그를 감지하는 데 아무런 가치가 없습니다.\n\n느린 피드백 메커니즘. \n컴파일타임 계측 및 소스 코드 의존성 문제를 해결하기 위해 dynamic binary 계측(Intel PIN[10]), static rewriting(AFL-dyninst[11]), 에뮬레이션(QEMU[12])과 같은 여러 피드백 메커니즘이 퍼징에 도입됩니다. 앞서 언급했듯이 AFL은 QEMU 에뮬레이션으로 확장됩니다(이 논문에서는 QAFL이라고 함). TriforceAFL과 같은 이후 작업에서도 QEMU를 퍼징 운영 체제에 채택합니다. 그러나 AFL의 Zalewski[13]는 퍼징에서 QEMU의 일반적인 성능 비용이 2-5배라고 지적했습니다. 이러한 비용의 이유는 본 논문에서 연구 범위를 벗어납니다. 확실히 느린 피드백 메커니즘으로 인한 이러한 성능 오버헤드는 퍼징 실무에서 참을 수 없습니다. 이러한 느린 메커니즘을 개선하려는 시급한 요구가 있습니다. \n\n부정확한 커버리지 피드백. \n위에서 언급한 바와 같이 AFL 및 AFLFast와 같은 그레이박스 퍼징은 기본 블록 전이를 추적하고 코드 커버리지를 측정하기 위해 비트맵을 사용합니다. 비트맵의 각 히트 바이트는 기본 블록 전이를 추적하고 코드 커버리지를 나타냅니다. 블록 A에서 블록 B로의 전이를 위한 해시 값이 계산되어 비트맵의 키로 사용되며, 이 값은 (A ⊕ B)%BITmap_SIZE(⊕은 XOR 연산을 의미함)입니다. 그러나 이 방식에서는 해시 충돌이 발생할 수 있습니다. A에서 B로의 전이 edge와 C에서 D로의 다른 edge가 있다고 가정해 보겠습니다. A와 C의 ID가 임의로 같은 값으로 할당되고 B와 D도 동일한 경우, 이 두 개의 다른 블록 전이는 동일한 것으로 간주되며, 이를 충돌 또는 중첩이라고 부릅니다. 이러한 상황에서 A에서 B로의 전이가 새로운 것이 아니고 C에서 D로의 전이를 트리거할 수 있는 새로운 경로라면, C에서 D로의 전이를 트리거할 수 있는 테스트 케이스는 새로운 시드로 저장되지 않습니다. 따라서 퍼징 루프는 일부 중요한 시드를 잃을 수도 있고, 불완전할 수도 있으며, 프로그램의 깊은 경로에 도달할 수 없습니다. 또한 AFL은 작은 비트맵(64KB)을 사용하므로 성능을 향상시키기 위해 캐시에 상주할 수 있습니다.\n```","x":1020,"y":1232,"width":903,"height":941},
		{"id":"832fd42f1b647395","type":"text","text":"# 비트맵\n\n비트맵이란 새 분기가 hit되었다는 것을 측정하기 위한 메모리 공간으로 예를 들어 A에서 B로 분기가 일어나면 (A xor B)%BITMAP_SIZE에 있는 공간의 값을 읽어서 0인지 확인하고 1을 더한다. 이로 인해 비트맵을 읽기만 해도 적중 분기가 새 분기인지 아닌지 판단하며 test case를 저장할지 폐기할 지를 정한다. 하지만 분기의 충돌과 중첩으로 지표가 상대적으로 낮을 수 있다.(AFL에서 해시 충돌이 일어남)\n","x":-1160,"y":3137,"width":797,"height":263},
		{"id":"8672365b62df3227","type":"text","text":"![](https://i.imgur.com/VgU5WgH.png)","x":940,"y":11540,"width":444,"height":580},
		{"id":"05c8ce7f0d738d1f","type":"text","text":"```\nA. 소스 코드 사용 가능한 퍼징 \n이 절에서는 PTfuzz와 AFL에 대한 실험 결과를 자세히 비교할 것입니다. 위에서 논의한 바와 같이, AFL로 프로그램을 퍼징하기 전에 AFL만의 특별한 컴파일러인 afl-clangfast로 프로그램을 컴파일해야 합니다. 컴파일러 도구들은 기본 블록의 주소로 값을 임의로 할당했습니다. 하지만 PTfuzz는 이러한 단계를 거칠 필요가 없습니다. 따라서 10개의 프로그램은 PTfuzz가 아닌 AFL에서 실행할 때 사용되는 프로그램입니다. 표 3과 같이 PTfuzz는 대상 프로그램 10개 중 7개(cxfilt, nm, size, gif2tiff, tiffino, mpg321 및 tcpdump)에서 AFL보다 더 고유한 충돌 수를 발견하고, 2개의 프로그램(readelf 및 string)에서 동일한 충돌 수를 발견합니다. 그러나 초당 실행된 테스트 케이스의 경우 PTfuzz의 속도가 AFL보다 약 7% 느리고, 이는 PT 디코더를 구현했기 때문입니다. (이 문제에 대해 자세히 논의하고 6절에서 이에 대한 향후 작업을 제공합니다. ) 그러나 퍼징 작업에서는 7%의 오버헤드가 비교적 허용됩니다. 성공한 브랜치에서 PTfuzz는 10개의 프로그램 모두에서 AFL보다 더 많은 브랜치를 가지고 있습니다. 그리고 이 지표는 PTfuzz가 프로그램에서 더 많은 코드와 경로를 커버할 수 있고 더 깊은 버그를 노출할 수 있음을 보여줍니다.\n또한 PTfuzz로 입력 파일과 매개 변수가 모두 동일하면 AFL은 gif2tiff를 정상적으로 퍼징할 수 없으며 화면에 \"Odd, check syntax\"만 표시됩니다. AFL [43]의 문서에 따르면 이 정보는 AFL의 퍼징이 잘못되었음을 나타내며 즉시 퍼징을 중지해야 합니다. 이 문제는 gif2tiff를 컴파일할 때 AFL이 사용하는 계측기 때문이라고 가정합니다. AFL의 특수 컴파일러 afl-clang-fast는 프로그램의 일부 내부 기능을 파괴할 수 있으며 AFL로 퍼징할 수 없습니다. 더 중요한 것은 이는 AFL이 사용 가능한 모든 소스 코드 퍼징 작업에 사용될 수 없다는 확실한 증거이지만 PTfuzz는 이 문제를 잘 처리할 수 있다는 것입니다. PTfuzz와 AFL의 비교는 PTfuzz가 더 많은 프로그램 충돌을 발견하고 더 높은 코드 커버리지를 달성하며 취약성을 노출하는 데 더 효과적이라는 강력한 증거입니다. 이 결과의 주요 이유는 AFL의 컴파일 시간 계측기의 내부 단점을 극복하고 무작위로 할당된 값 대신 기본 블록에 대한 실제 런타임 주소를 활용하기 때문입니다. 그리고 PTfuzz는 프로그램 실행에서 기본 블록 전환을 정확하게 캡처하고 기본 퍼징 루프에 유용한 피드백을 제공할 수 있습니다. 결론적으로 PTfuzz는 충돌 노출 능력과 코드 커버리지에서 AFL보다 성능이 뛰어나며, 오버헤드가 7%로 코드 최적화를 통해 제거할 수 있습니다.\n```","x":-103,"y":12330,"width":903,"height":750},
		{"id":"edb1642129396c3a","type":"text","text":"![](https://i.imgur.com/NOyn2Z9.png)","x":940,"y":12494,"width":507,"height":422},
		{"id":"c00ef3491782a98f","type":"text","text":"```\nB. Binary-Only FUzzing \n이 절에서는 PTfuzz, AFL 및 QAFL에 있는 10개 프로그램의 바이너리에 대해 소스 코드 없이 실험을 수행합니다. 그리고 여전히 표 4에 3개의 지표, 충돌, 속도 및 분기를 나열합니다. 이 바이너리는 다른 컴퓨터에서 일반 gcc 컴파일러로 컴파일되고 우리 데스크톱에는 소스 코드 없이 10개의 바이너리만 있습니다. \n먼저 이 표에서 PTfuzz와 AFL의 비교에 대해 알아보겠습니다. AFL의 특수 컴파일러로는 10개의 프로그램을 컴파일할 수 없기 때문에 소스 코드를 사용할 수 있는 경우의 실험과 동일하지 않습니다. 보시다시피 AFL은 이러한 바이너리 전용 퍼징 작업에서 아무것도 할 수 없으며 소스 코드를 사용할 수 없을 때는 무의미합니다. 그러나 PTfuzz는 예외 없이 이러한 모든 바이너리를 퍼징할 수 있습니다. 이와 같은 바이너리 전용 퍼징 시나리오에서는 PTfuzz가 AFL보다 확실히 성능이 뛰어납니다. \n그런 다음 PTfuzzz와 QAFL의 비교에 대해 알아보겠습니다. 일반적으로 PTfuzz는 10개 프로그램 중 8개 프로그램(cxxfilt, nm, objump, size, gif2tiff, tiffinfo, mpg321 및 tcpdump)에서 QAFL보다 더 많은 충돌을 노출하고 2개 프로그램(readelf 및 strings)에서는 동일한 충돌을 노출합니다. 실행 속도에 대해서는 PTfuzz가 10개 실험 모두에서 QAFL보다 빠릅니다. 특히 objdump의 경우 PTfuzz가 실행 중인 QAFL보다 약 24배 빠릅니다. 그리고 PTfuzz가 10개 프로그램에서 QAFL보다 더 많은 분기를 쳤는데, 이는 PTfuzz가 QAFL보다 퍼징에서 항상 더 높은 코드 커버리지를 가지고 있음을 의미합니다. \n또한 mpg321과 tcpdump를 퍼징하면 포크 서버가 실행된 후 QAFL이 정지됩니다. (포크 서버를 시작하는 것은 AFL 및 QAFL 퍼징의 기본 단계입니다.) 우리는 이 문제는 QAFL의 실행 속도가 느리기 때문이며 이후 단계로 계속 진행할 수 없다고 가정합니다. 그러나 우리의 PTfuzz는 fuzing 작업에서 이러한 상황에 직면하지 않았습니다. 이 문제는 또한 QAFL의 실행 속도가 느리다는 것을 증명합니다.\n따라서 바이너리 전용 퍼징에서 AFL 및 QAFL과 비교하여 PTfuzz가 여러 면에서 성능이 우수하다는 것을 알 수 있습니다. PTfuzz는 AFL처럼 대상 프로그램을 특별히 컴파일할 필요가 없기 때문에 AFL이 퍼징할 수 없는 바이너리를 퍼징할 수 있습니다. 또한 PTfuzz는 QAFL보다 훨씬 빠르게 실행되고 더 많은 충돌을 노출하며 더 많은 프로그램 경로를 커버합니다. 여기에 대한 내부적인 이유는 QAFL에 채택된 QEMU 에뮬레이션을 포기하고 바이너리를 빠르고 정확하게 퍼징할 수 있는 프로세서 트레이스에 집중하기 때문입니다. 따라서 바이너리 전용 퍼징 작업에서 PTfuzz는 AFL 및 QAFL보다 더 깊은 버그와 취약점을 발견할 수 있는 훨씬 더 많은 잠재력을 얻습니다.\n```","x":-103,"y":13200,"width":903,"height":780},
		{"id":"529b1e91a7a83765","type":"text","text":"![](https://i.imgur.com/bCfEzAX.png)","x":940,"y":13376,"width":756,"height":429},
		{"id":"ff0fc84b756787b8","type":"text","text":"# 5. EXPERIMENT\n\n```\n이 섹션에서는 AFL 및 QAFL과 비교하여 PTfuzz의 실험 결과에 대해 논의합니다. AFL은 컴파일 시간 계측 기능을 갖춘 애플리케이션 인식 퍼저에서 탁월한 작업입니다. 이에 비해 PTfuzz 는 이진 전용 퍼징이 가능하고 AFL보다 상대적으로 높은 코드 커버리지를 가지고 있음을 보여줍니다. 그리고 QAFL은 이진 전용 지원을 가진 퍼징 기술을 나타냅니다. QAFL과 비교하여 PTfuzz가 퍼징 작업에서 상대적으로 더 빠르다는 것을 보여줄 수 있습니다. \n실험 설정: 실험은 인텔 코어 i7 3.4GHz 8 코어 CPU와 Ubuntu 16.04를 실행하는 8GB RAM이 있는 데스크톱에서 수행됩니다. 그리고 대상 프로그램은 의도적으로 선택됩니다. 저희는 GNU Binutils[38]의 cxxfilt, nm, objdump, readelf, size 및 문자열을 가지고 있으며 Lava-M 데이터 세트의 base64, md5sum, uniq를 가지고 있습니다. Binutils는 널리 사용되는 이진 도구 모음입니다. 그리고 저희는 TIFF[39]의 이미지 처리 도구 giftiff와 tiffinfo를 가지고 있습니다. 또한 mpg321[40]과 tcpdump[40]가 포함되어 있습니다. 따라서 저희는 총 10개의 대상 프로그램이 포함되어 실험을 수행할 수 있습니다. 표 2는 이러한 프로그램에 대한 입력 매개 변수를 보여줍니다. 각 프로그램에 대해 24시간 동안 개별적으로 PTfuzz, AFL 및 QAFL로 퍼징합니다. 또한 저희는 각 실험에 대한 3개의 지표를 기록합니다. \n- 이는 프로그램을 실행할 때 고유한 충돌 수입니다. 그리고 충돌은 테스트된 프로그램이 치명적인 신호를 수신하게 하는 고유한 테스트 사례(예: SIGSEGV, SIGILL, SIGABT)에서 발생합니다. 이는 퍼저의 퍼징 성능이 양호한지 여부를 결정하기 위해 [7], [8], [41] 및 [42]에서 널리 사용되는 지표입니다. \n- 속도. 저희는 각 퍼저의 실행 속도를 exe/s로 측정하여 퍼징 오버헤드를 보여줍니다.\n- Branchs. II-A절에서 언급했듯이 히트 브랜치 수(기본 블록 전이)는 퍼저에 대한 코드 커버리지를 측정하는 중요한 지표입니다. 브랜치가 많을수록 코드 커버리지가 높아집니다. 그리고 더 많은 프로그램 코드를 커버하는 것은 분명히 더 깊이 묻힌 취약점과 버그로 이어질 것입니다.  \n\n그리고 실험 결과와 자세한 논의는 다음과 같습니다.\n```","x":-103,"y":11460,"width":903,"height":740},
		{"id":"8c4bd8ff1c16d280","type":"text","text":"이 논문의 주요 기고문은 다음과 같이 요약된다.","x":123,"y":2492,"width":452,"height":71},
		{"id":"748d0193e944ee09","type":"text","text":"```\n이 논문에서는 이전 그레이박스 퍼징 기술의 위와 같은 단점을 해결하기 위해 인텔 프로세서 트레이스 피드백으로 안내되는 개선된 퍼징인 PTfuzz를 제안합니다. 인텔 PT[14]는 인텔 프로세서의 새로운 기능입니다. 조건부 점프 및 무조건 점프와 같은 프로그램 제어 흐름 정보의 정확하고 자세한 추적을 노출할 수 있습니다. 특히 PT는 모든 기본 블록의 정확한 주소를 추적할 수 있습니다. 따라서 PTfuzz에서는 AFL 아이디어에 따라 PT의 이 기능을 사용하여 기본 블록 간의 전환을 측정하고 퍼징 루프에 대한 정확한 커버리지 피드백 정보를 제공합니다. 한편 PTfuzz는 프로세서에서 실행 정보를 직접 수집하고 소스 코드에 전혀 의존하지 않기 때문에 모든 이진 전용 소프트웨어를 퍼징할 수 있습니다. 저희는 섹션 V에서 PTfuzz의 성능 오버헤드를 추가로 보여줍니다. 저희의 실험은 PT가 QAFL 및 Triforce AFL과 같은 이전 작업보다 훨씬 빠른 피드백 메커니즘임을 보여줍니다\n```","x":-103,"y":1900,"width":903,"height":340},
		{"id":"24887a337d72381c","type":"text","text":"```\n바이너리 전용 퍼징입니다. \n저희는 바이너리 전용 소프트웨어를 퍼징하고 소스 코드가 필요하지 않은 새로운 그레이박스 퍼징을 제안합니다. 소스 코드를 사용할 수 없는 상황에서는 컴파일 시간 계측 및 철저한 프로그램 분석이 불가능하며 AFL, AFLFast 및 VUzzer와 같은 퍼징은 사용할 수 없습니다. 저희의 접근 방식은 이러한 상황과 퍼징 바이너리를 평소처럼 우아하게 처리할 수 있습니다. \n\n빠른 피드백 메커니즘입니다. \n저희는 훨씬 빠른 피드백 메커니즘을 도입합니다. 위에서 언급한 바와 같이, 이전 작업들은 소스 코드 의존성 문제를 해결하기 위해 열심히 노력했지만, 모두 상당한 성능 오버헤드, 특히 QAFL 및 TriforceAFL에 어려움을 겪고 있습니다. 저희는 CPU에서 직접 빠른 하드웨어 피드백을 활용하고, QAFL보다 훨씬 빠른 방식으로 바이너리 전용 퍼징을 처리합니다. 저희의 실험에 따르면 퍼징의 성능 오버헤드는 QAFL보다 훨씬 작습니다. \n\n정확한 커버리지 피드백. \n저희는 코드 커버리지 피드백을 위한 보다 정확한 측정을 제안합니다. basic 블록의 컴파일 시간 계측 및 랜덤 ID 할당은 코드 커버리지를 부정확하게 측정합니다. 저희는 basic 블록의 실제 런타임 주소를 사용하여 basic 블록 간의 전환을 추적하고 실행 중인 코드의 실제 제어 흐름 정보를 제공할 수 있습니다. \n\nPTfuzz. 저희는 이러한 통찰력을 기반으로 PTfuzz라는 프로토타입을 구현합니다(https://github.com/hunterht-2018/ptfuzzer) . 그리고 저희의 실험은 PTfuzz가 바이너리 전용 퍼징을 빠르고 정확하게 처리할 수 있음을 보여줍니다\n```","x":1017,"y":2200,"width":903,"height":655},
		{"id":"e824a17bfc4647c7","x":-1560,"y":10677,"width":354,"height":63,"type":"text","text":"python-CLE 제대로 알아보기"}
	],
	"edges":[
		{"id":"38ed2a6cc6bd4747","fromNode":"ac54bf873d892019","fromSide":"bottom","toNode":"c3d47770f424e0ae","toSide":"top"},
		{"id":"43869d8ee6f8da9c","fromNode":"c3d47770f424e0ae","fromSide":"bottom","toNode":"5cd2e38fbd96195f","toSide":"top"},
		{"id":"23409f06d855f7ce","fromNode":"a56b26a9652a6575","fromSide":"right","toNode":"56aae6111ff0cba9","toSide":"left"},
		{"id":"20f20996f70c78f7","fromNode":"5cd2e38fbd96195f","fromSide":"bottom","toNode":"a56b26a9652a6575","toSide":"top"},
		{"id":"177abff02a84003d","fromNode":"a56b26a9652a6575","fromSide":"bottom","toNode":"748d0193e944ee09","toSide":"top"},
		{"id":"02f0efe0ff75f1fe","fromNode":"748d0193e944ee09","fromSide":"bottom","toNode":"8c4bd8ff1c16d280","toSide":"top"},
		{"id":"50e60aa1a5a93112","fromNode":"8c4bd8ff1c16d280","fromSide":"right","toNode":"24887a337d72381c","toSide":"left"},
		{"id":"aad5453db7f74c6e","fromNode":"8c4bd8ff1c16d280","fromSide":"bottom","toNode":"36a17f1152d9f595","toSide":"top"},
		{"id":"b7a5d3552e1ed80e","fromNode":"10373e8fa71b9675","fromSide":"right","toNode":"c60fcea2282250f9","toSide":"left"},
		{"id":"fa10fd77dbbc7385","fromNode":"0bb7e76f9bb94d12","fromSide":"bottom","toNode":"d4594b408b4da369","toSide":"top"},
		{"id":"dab77a3662481a3e","fromNode":"6007dd2a540f6069","fromSide":"bottom","toNode":"ff0fc84b756787b8","toSide":"top"},
		{"id":"1e54a72624630912","fromNode":"ff0fc84b756787b8","fromSide":"right","toNode":"8672365b62df3227","toSide":"left"},
		{"id":"68619a8b9e2a1535","fromNode":"ff0fc84b756787b8","fromSide":"bottom","toNode":"05c8ce7f0d738d1f","toSide":"top"},
		{"id":"2a2dd3710cee5756","fromNode":"05c8ce7f0d738d1f","fromSide":"right","toNode":"edb1642129396c3a","toSide":"left"},
		{"id":"5e26a2527a54a07e","fromNode":"c00ef3491782a98f","fromSide":"bottom","toNode":"630d68ecaaf98907","toSide":"top"},
		{"id":"11909a20423858c0","fromNode":"630d68ecaaf98907","fromSide":"right","toNode":"961343f38b31a2a1","toSide":"left"},
		{"id":"3cdb26b082e91285","fromNode":"630d68ecaaf98907","fromSide":"bottom","toNode":"e696ec23b35ada65","toSide":"top"},
		{"id":"daf3c18241381e15","fromNode":"e696ec23b35ada65","fromSide":"bottom","toNode":"5a813b3e7b37eb4a","toSide":"top"},
		{"id":"bc160351412682da","fromNode":"36a17f1152d9f595","fromSide":"bottom","toNode":"10373e8fa71b9675","toSide":"top"},
		{"id":"37b1e53e8b2ace21","fromNode":"10373e8fa71b9675","fromSide":"bottom","toNode":"0bb7e76f9bb94d12","toSide":"top"},
		{"id":"c99277101c956104","fromNode":"d4594b408b4da369","fromSide":"bottom","toNode":"8f84973825b753ff","toSide":"top"},
		{"id":"23fe6f161f82058a","fromNode":"8f84973825b753ff","fromSide":"right","toNode":"383e56995edcefc6","toSide":"left"},
		{"id":"ccdbebbdcd08fca6","fromNode":"8f84973825b753ff","fromSide":"right","toNode":"b1fd8a8eea027f8e","toSide":"left"},
		{"id":"6e48d862171c8bb0","fromNode":"8f84973825b753ff","fromSide":"bottom","toNode":"6007dd2a540f6069","toSide":"top"},
		{"id":"f73ebcf431dc0be5","fromNode":"c00ef3491782a98f","fromSide":"right","toNode":"529b1e91a7a83765","toSide":"left"},
		{"id":"1be7d9e9edb026c7","fromNode":"05c8ce7f0d738d1f","fromSide":"bottom","toNode":"c00ef3491782a98f","toSide":"top"},
		{"id":"03ebbb195007e33c","fromNode":"fed585567e1d50b2","fromSide":"right","toNode":"c3d47770f424e0ae","toSide":"left"},
		{"id":"950d4aef0b584da2","fromNode":"951689b30415e770","fromSide":"bottom","toNode":"c56332715bd12fdc","toSide":"top"},
		{"id":"e27ff9eb1045a995","fromNode":"8200e6fac8017ed1","fromSide":"bottom","toNode":"c56332715bd12fdc","toSide":"top"},
		{"id":"f05f7cf1dc7e9d74","fromNode":"989a6f4bbb2088d7","fromSide":"bottom","toNode":"a35498817b9e9407","toSide":"top"},
		{"id":"0c40e6385a09064a","fromNode":"a35498817b9e9407","fromSide":"bottom","toNode":"832fd42f1b647395","toSide":"top"},
		{"id":"2c20a85dfa0c0715","fromNode":"91857625f708f0c4","fromSide":"right","toNode":"c60fcea2282250f9","toSide":"top"},
		{"id":"1fd3f69ec1c52869","fromNode":"832fd42f1b647395","fromSide":"bottom","toNode":"91857625f708f0c4","toSide":"top"},
		{"id":"cd9f482bca0026e8","fromNode":"91857625f708f0c4","fromSide":"bottom","toNode":"4724d5b970f09823","toSide":"top"},
		{"id":"d523a223c3b272c3","fromNode":"b0f85c024bb7dcfc","fromSide":"right","toNode":"383e56995edcefc6","toSide":"left"},
		{"id":"2efb6e3e0df1e063","fromNode":"4724d5b970f09823","fromSide":"bottom","toNode":"b0f85c024bb7dcfc","toSide":"top"},
		{"id":"9c2881afeabc5164","fromNode":"b0f85c024bb7dcfc","fromSide":"bottom","toNode":"dd160934de686702","toSide":"top"},
		{"id":"36e2b398506f3c9c","fromNode":"dd160934de686702","fromSide":"bottom","toNode":"12e995161c7eaddc","toSide":"top"}
	]
}