### General-purpose Register
Aarch64 아키텍처는 64비트 ARM 아키텍처로, 다양한 용도로 사용되는 여러 레지스터를 제공한다. 프로세서 상태, 데이터, 벡터 연산 등 다양한 기능을 지원한다.

대부분의 Aarch64 명령어는 레지스터에서 작동하는데, 31개의 범용 레지스터를 제공한다. 각 레지스터는 64bit X레지스터(X0 .. X30) 또는 32bit W레지스터(W0..W30)로 사용할 수 있다. W0 이 X0의 하위 32bit이다.

![](https://i.imgur.com/OFrzPDS.png)
X 레지스터를 사용하면 64bit 연산이되고 W 레지스터를 사용하면 32bit 연산이 된다.
다음은 32bit 정수 덧셈 연산이다.

```
ADD W0, W1 ,W2
```
다음은 64bit 정수 덧셈 연산이다.
```
ADD X0, X1, X2
```

[[GPRs 레지스터 역할.canvas]]


프레임 포인터(x29)는 ETW 및 기타 서비스에서 사용하는 빠른 스택 워크와의 호환성을 위해 필요하다. 스택의 이전 {x29, x30} 쌍을 가리켜야 한다.

스크래치 레지스터(Scratch Pad Register)
이 레지스터들은 함수내에서 훼손될 가능성이 있는 레지스터들을 말한다. 그렇기 때문에 함수가 호출될 경우 호출 직전에 Stack에 따로 저장을 해주어야 한다.


### SIMD & floating-point registers
부동 소수점 및 벡터 연산에 사용되는 별도의 32개 레지스터 세트가 있는데, 이러한 레지스터는 128bit 이지만 범용 레지스터와 마찬가지로 여러 가지 방법으로 엑세스 할 수 있다. Bx는 8bit, Hx는 16bit, Qx는 128bit 이다. 
![](https://i.imgur.com/ZPrtPHq.png)
레지스터에 사용하는 이름에 따라 계산 크기가 정해진다. 다음은 32bit 부동 소수점 추가를 수행한다.

```
FADD S0, S1, S2
```

아래 예는 64bit 실수형 덧셈을 수행한다. 
```
FADD D0, D1, D2
```

이러한 레지스터는 V 레지스터라고도 한다.(Vector Register) V형식을 사용하면 레지스터가 벡터로 처리된다. 즉, 단일 값이 아닌 여러 개의 독립적인 값을 포함하는 것처럼 처리된다. 다음은 벡터 부동소수점 덧셈을 수행한다.

```
FADD V0.2D, V1.2D, V2.2D
```
다음은 벡터 정수 덧셈을 수행하는 것을 보여준다.
```
ADD V0.2D, V1.2D, V2.2D
```

[[FPRs 레지스터 역할.canvas]]

### Special registers

#### PC (Program Counter)
64bit
PC 레지스터는 다음에 실행할 인스트럭션의 위치를 저장하는 레지스터다.


#### ELR (Exception Link Register)
ELR 레지스터는 익셉션 복귀 시 돌아갈 실행 위치를 저장하는 레지스터다.
프로세서에 의해 현재 익셉션 레벨에 해당하는 레지스터 값이 PC에 복사된다.
복귀할 익셉션 레벨이 없는 EL0을 제외한 익셉션 레벨마다 존재하며, 이름은 ELR_ELn이다. 

#### SPSR (Saved Process Status Register)
SPSR 레지스터는 특정 시점의 프로세서 상태를 저장하는 레지스터다.
익셉션이 발생하면 프로세서에 의해 프로세서 상태 PSTATE로부터 SPSR에 저장된다.
익셉션에서 복귀할 때 프로세서에 의해 SPSR에서 PSTATE로 복원된다.

말이 ㅈㄴ 어려운데 그냥 익셉션 발생시 현재 프로그램 상태를 저장하고 익셉션 처리 루틴에서  원래 상태로 복구하는데 사용된다.

SPSR은 익셉션을 취할 수 없는 EL0을 제외한 익셉션 레벨마다 존재하며, 이름은 SPSR_ELn이다.

![](https://i.imgur.com/FR081Hm.png)


#### XZR, WZR (Zero Register)
ZR은 소스 레지스터로 사용되며 0이 읽히고, 목적 레지스터로 사용되면 결과 값이 버려진다.(쓰기를 무시한다)
XZR은 64비트, WZR은 32비트 크기로 사용한다. 

#### SP, WSP (Stack Pointer)
SP는 스택의 현 위치를 가리키는 레지스터이다.
EL0를 포함한 익셉션 레벨마다 존재하며, 이름은 SP_ELn이다.
SP는 64비트, WSP는 32비트 크기의 스택 포인터이다.
EL0을 제외한 그 밖의 익셉션 레벨에서는 해당 레벨의 SP_ELn과 SP_EL0 중에서 선택적으로 스택 포인터를 사용할 수 있다는 점이다.
![](https://i.imgur.com/KQGtpdJ.png)

![](https://i.imgur.com/odhbblR.png)
SPsel 레지스터의 SP비트 값에 따라 사용되는 스택 포인터가 정해진다.

SPsel 레지스터의 SP 비트에 1을 설정하면 엑셉션 레벨에 따른 SP_ELn을 사용하고, 0을 설정하면 익셉션 레벨과 상관없이 SP_EL0를 사용한다. 이 설정에 따라 익셉션 발생 시 이동하는 벡터 위치도 달라진다.
t를 thread의 약어이며, SP0의 스택을 사용한다는 뜻이다
h는 handler의 약어이며, SPn의 스택을 사용한다는 뜻이다
리눅스 커널은 SPsel을 설정하지 않고 필요에 따라 해당 EL의 레벨을 직접 지정하는 방식을 구현하고 있다.

### System register
Aarch64 아키텍처에서 시스템의 세부 속성을 설정하려면 시스템 레지스터를 사용해야 한다.
시스템 레지스터에 MSR와 MRS 명령어를 사용해 접근(읽기/쓰기)할 수 있다.
시스템 레지스터의 이름으로 시스템 레지스터에 접근할 수 있는 가장 낮은 익셉션 레벨을 알 수 있다.

시스템 레지스터는 Aarch64 아키텍처를 이루는 다양한 기능을 설정하기 위해 사용됩니다. 그렇다면 시스템 레지스터를 읽거나 쓰려면 어느 명령어를 실행해야 할까? 다음 명령어를 보자.

```
MRS x0, TTBR0_EL1 // TTBR0_EL1을 x0 레지스터에 읽기 

MSR TTBR0_EL1, x0 // x0 레지스터의 값을 TTBR0_EL1에 이동
```
MSR 명령어는 'Move to system coprocessor register from ARM register'의 약자로 범용 레지터의 값을 시스템 코프로세서로 이동시키는 명령어입니다. 이어서 MRS 명령어는 'Move to ARM register from system coprocessor register'의 약자로 시스템 코프로세서의 값을 범용 레지스터로 이동하는 명령어입니다.

시스템 레지스터의 이름을 보면 익셉션 레벨을 나타내는 접미사가 보입니다. TTBR0_EL1는 TTBR0 다음에 EL1란 접미사가 붙습니다. 시스템 레지스터에 접근할 수 있는 최소한의 익셉션 레벨을 나타낸다.

아래는 자주 사용되는 시스템 레지스터이다.

![](https://i.imgur.com/m3jcAP8.png)
