{
	"nodes":[
		{"id":"41e62007634186fd","type":"text","text":"```C\nvoid //2_여기\nTIFFPrintDirectory(TIFF* tif, FILE* fd, long flags) \n//여기서 fd는 stdout\n{\n    TIFFDirectory *td = &tif->tif_dir;\n    char *sep;\n    uint16 i;\n    long l, n;\n  \n// 생략\n \n    /*\n    ** Custom tag support.\n    */\n    {\n        int  i;\n        short count;\n  \n        count = (short) TIFFGetTagListCount(tif);\n        for(i = 0; i < count; i++) {\n            uint32 tag = TIFFGetTagListEntry(tif, i);\n            const TIFFField *fip;\n            uint32 value_count;\n            int mem_alloc = 0;\n            void *raw_data; //raw data\n  \n            fip = TIFFFieldWithTag(tif, tag);\n            if(fip == NULL)\n                continue;\n  \n            if(fip->field_passcount) {//else로 분기\n                if (fip->field_readcount == TIFF_VARIABLE2 ) {\n                    if(TIFFGetField(tif, tag, &value_count, &raw_data) != 1)\n                        continue;\n                } else if (fip->field_readcount == TIFF_VARIABLE ) {\n                    uint16 small_value_count;\n                    if(TIFFGetField(tif, tag, &small_value_count, &raw_data) != 1)\n                        continue;\n                    value_count = small_value_count;\n                } else {\n                    assert (fip->field_readcount == TIFF_VARIABLE\n                        || fip->field_readcount == TIFF_VARIABLE2);\n                    continue;\n                }\n            } else {//여기로 분기\n                if (fip->field_readcount == TIFF_VARIABLE\n                    || fip->field_readcount == TIFF_VARIABLE2)\n                    value_count = 1; //실행\n                else if (fip->field_readcount == TIFF_SPP)\n                    value_count = td->td_samplesperpixel;\n                else\n                    value_count = fip->field_readcount;\n                if (fip->field_tag == TIFFTAG_DOTRANGE // 분기\n                    && strcmp(fip->field_name,\"DotRange\") == 0) {// 실행 x\n                    /* TODO: This is an evil exception and should not have been\n                       handled this way ... likely best if we move it into\n                       the directory structure with an explicit field in\n                       libtiff 4.1 and assign it a FIELD_ value */\n                    static uint16 dotrange[2];\n                    raw_data = dotrange;\n                    TIFFGetField(tif, tag, dotrange+0, dotrange+1);\n                } else if (fip->field_type == TIFF_ASCII // 분기\n                       || fip->field_readcount == TIFF_VARIABLE\n                       || fip->field_readcount == TIFF_VARIABLE2\n                       || fip->field_readcount == TIFF_SPP\n                       || value_count > 1) {\n                    if(TIFFGetField(tif, tag, &raw_data) != 1) //실행\n                        continue;\n                } else {\n                    raw_data = _TIFFmalloc(\n                        _TIFFDataSize(fip->field_type)\n                        * value_count);\n                    mem_alloc = 1;\n                    if(TIFFGetField(tif, tag, raw_data) != 1) {\n                        _TIFFfree(raw_data);\n                        continue;\n                    }\n                }\n            }\n  \n            /*\n             * Catch the tags which needs to be specially handled\n             * and pretty print them. If tag not handled in\n             * _TIFFPrettyPrintField() fall down and print it as\n             * any other tag.\n             */\n            if (!_TIFFPrettyPrintField(tif, fip, fd, tag, value_count, raw_data))\n                _TIFFPrintField(fd, fip, value_count, raw_data); //1호출, fd는 stdout\n\n            //생략\n```","x":-200,"y":266,"width":840,"height":1894},
		{"id":"d70ddfce34d53ae1","type":"text","text":"```C\nstatic void\ntiffinfo(TIFF* tif, uint16 order, long flags, int is_image)\n{\n    TIFFPrintDirectory(tif, stdout, flags); // 시작\n    if (!readdata || !is_image)\n        return;\n    if (rawdata) {\n        if (order) {\n        //생략\n```","x":-80,"y":-100,"width":520,"height":277},
		{"id":"9635e8febeec811a","type":"text","text":"field를 출력하는 함수를 실행한다.\n여기서  raw_data 는 다음과 같다.\n\n여기서 봐야 할 곳은 분명 65만큼 할당을 받았지만 그 65바이트를 모두 채운 바람에 다음 chunk의 prev_size 부분을 덮었다.(그런데 값을 봐서는 prev_size는 아님) ","x":640,"y":1160,"width":440,"height":260},
		{"id":"6e3bb7245150fa4a","type":"file","file":"K0n9/4. fuzzing/picture/Pasted image 20231105020355.png","x":1174,"y":1176,"width":499,"height":148},
		{"id":"d52d777f3e90d4da","type":"text","text":"### tiffinfo (tiffinfo.c)","x":-400,"y":29,"width":250,"height":60},
		{"id":"a3ea40f178daf279","type":"text","text":"### TIFFPrintDirectory (tif_print.c)","x":-642,"y":407,"width":342,"height":53},
		{"id":"4eeb862006b487e5","type":"text","text":"```C\nstatic void //1_여기\n_TIFFPrintField(FILE* fd, const TIFFField *fip, // fd는 stdout\n        uint32 value_count, void *raw_data)\n{\n    uint32 j;\n\t// 생략\n        else if(fip->field_type == TIFF_ASCII) { // field_type 이 ASCII인경우\n            fprintf(fd, \"%s\", (char *) raw_data); // 여기서 터짐\n            break;\n        }\n        // 생략\n```","x":-200,"y":2240,"width":680,"height":293},
		{"id":"b1e6e386a7aaa9a7","type":"file","file":"K0n9/4. fuzzing/picture/Pasted image 20231105020943.png","x":882,"y":2413,"width":685,"height":241},
		{"id":"8f16b96505733b5d","type":"text","text":"정상적인 test case를 가져와 crash를 비교해보았다. 정상적인 test case는 \n```\nGraphicsMagick 1.2 unreleased Q16 http://www.GraphicsMagick.org/\n```\n와 같은 문자열을 가지고 있다. 이는 64바이트로 문자열 마지막 공백포함 65바이트 딱 맞는 크기이다. 하지만 그림을 보면 알겠지만 crash에는 unreleased와 Q16에 어떤 값이 추가되었다. 그래서 해당 문자열이 길어지고 길어진 만큼 뒷 부분이 잘려서 overwrite는 발생하지 않았지만 문자열 끝 공백이 없어져서 out of bound read 가 발생했다.","x":882,"y":2654,"width":685,"height":246},
		{"id":"912ef615139a74d1","type":"text","text":"```C\nfprintf(fd, \"%s\", (char *) raw_data*);\n```\n에서 터지게 된다. 여기서 출력의 되는 부분은 다음과 같다.\n이 CVE는 out-of-bound read이다. 즉 허용되지 않는 영역에 읽기를 한 것이다. chunk의 크기는 65여서 overwrite는 하지 않고 딱 65만큼 채웠다. 하지만 마지막을 공백으로 하지 않아서 다음 chunk의 prev_size 부분에 있는 값과 연결이 되어버린다. 이 상태에서 fprintf를 할 경우 red zone에서 읽기 시도를 하기 때문에 오류가 발생하고 아래와 같이 이상한 문자가 같이 출력된다.","x":976,"y":2066,"width":497,"height":267},
		{"id":"1653fe7c49057028","type":"file","file":"K0n9/4. fuzzing/picture/Pasted image 20231105021240.png","x":1673,"y":2709,"width":1685,"height":136},
		{"id":"9a2c3476d8080bc5","type":"text","text":"### \\_TIFFPrintField (tif_print.c)","x":-620,"y":2353,"width":360,"height":67}
	],
	"edges":[
		{"id":"4130fe8769edc2fd","fromNode":"d70ddfce34d53ae1","fromSide":"bottom","toNode":"41e62007634186fd","toSide":"top"},
		{"id":"ebdeac05901cb08f","fromNode":"41e62007634186fd","fromSide":"bottom","toNode":"4eeb862006b487e5","toSide":"top"},
		{"id":"0a6345c08a6eb7d2","fromNode":"41e62007634186fd","fromSide":"right","toNode":"9635e8febeec811a","toSide":"left"},
		{"id":"d7794d367fb17faf","fromNode":"9635e8febeec811a","fromSide":"right","toNode":"6e3bb7245150fa4a","toSide":"left"},
		{"id":"359674a39c791d19","fromNode":"912ef615139a74d1","fromSide":"right","toNode":"6e3bb7245150fa4a","toSide":"bottom"},
		{"id":"06be5e4dfd6c5d08","fromNode":"4eeb862006b487e5","fromSide":"right","toNode":"912ef615139a74d1","toSide":"left"},
		{"id":"63e317f0af0c0673","fromNode":"912ef615139a74d1","fromSide":"bottom","toNode":"b1e6e386a7aaa9a7","toSide":"top"},
		{"id":"32a09dbdd8d46b15","fromNode":"8f16b96505733b5d","fromSide":"right","toNode":"1653fe7c49057028","toSide":"left"},
		{"id":"a23658203d0a579a","fromNode":"d70ddfce34d53ae1","fromSide":"left","toNode":"d52d777f3e90d4da","toSide":"right"},
		{"id":"321dec43d853c96c","fromNode":"41e62007634186fd","fromSide":"left","toNode":"a3ea40f178daf279","toSide":"right"},
		{"id":"4de5fc7c32010df7","fromNode":"4eeb862006b487e5","fromSide":"left","toNode":"9a2c3476d8080bc5","toSide":"right"}
	]
}