{
	"nodes":[
		{"id":"a62175fca162f699","type":"text","text":"# 1. INTRODUCTION\n\nfuzzzing은 1990년대 초 소개된 이 기술은 소프트웨어의 정확성과 신뢰성을 테스트하는 데 널리 사용되고 있다.\n높은 수준에서 fuzzing은 구문적 또는 의미적으로 기형적일 수 있는 생성된 입력으로 프로그램을 반복적으로 실행하는 과정을 의미한다. \n실제로 악의적인 공격자는 exploit generation 과 침투 테스트 같은 시나리오에 fuzzing을 일상적으로 배치한다.\n이러한 활동에 힘입어 방어자는 공격자보다 먼저 취약점을 발견하기 위해 fuzzing을 사용하기 시작했다.\n예를 들어 Adobe, Cisco, Google, 및 Microsoft, 와 같은 저명한 벤더는 모두 보안 개발 관행의 일부로 fuzzing을 사용한다. 보다 최근에는 보안 감시자와 오픈 소스 개발자도 fuzzing을 사용하여 상품 소프트웨어 패키지의 보안을 측정하고 최종 사용자에게 몇 가지 적합한 형태의 보증을 제공하기 시작했다. \nfuzzing 커뮤니티는 매우 활기차있다. 이 글을 쓰는 현재, GitHub에서만 fuzzing과 관련된 1000개 이상의 공공 저장소를 호스팅하고 있다. 그리고 우리가 보여줄 수 있듯이 문헌에도 많은 fuzzing이 포함되어 있으며 점점 더 많은 fuzzing 연구가 나타난다.\n\n어쩌구 저쩌구 ~~~ 안중요함\n\n아무튼 요점은 용어에서 단편화과 생기기 시작했다. 그래서 이 논문에서 fuzzing 용어 및 fuzzing의 통합 모델을 제시하고 fuzzer의 단계를 살펴보고 주요 fuzzer에 대한 자세한 개요를 제시할 것이다.","x":-96,"y":-51,"width":1096,"height":511},
		{"id":"a938b0ff11d7b889","type":"text","text":"# 2 SYSTEMIZATION, TAXONOMY, AND TEST PROGRAMS\n\nFuzz라는 용어는 원래 1990년 밀러 등에 의해 대상 프로그램이 소비할 무작위 문자 스트림을 생성 하는 프로그램을 지칭하기 위해 만들어졌다. 그 이후 fuzz와 그 작용에 대한 개념인 fuzz는 동적 기호 실행, 문법 기반 테스트 케이스 생성, 권한 테스트, 행동 테스트, 복잡도 테스트, 커널 테스트, 표현 의존성 테스트, 함수 검출, 견고성 평가, 악용 개발, GUI 테스트, 시그니처 생성, 침투 테스트, , 임베디드 디바이스, 신경망 테스트 등 다양한 맥락에서 나타났다. \n방대한 fuzz의 문헌에서 나온 지식을 체계화하기 위해 먼저 현대적인 용도에서 추출한 fuzz의 용어를 제시해보겠다.","x":-96,"y":640,"width":1096,"height":280},
		{"id":"78cc7de75c47b6b7","type":"text","text":"# 2.1 Fuzzing & Fuzz Testing\n\n직관적으로 fuzz inputs 으로 PUT(Program Under Test)을 실행하는 동작이다. 우리는 fuzzing 입력이 PUT가 예상하지 못할 수 있는 입력, 즉 PUT 가 잘못 처리하여 PUT의 개발자가 의도하지 않은 동작을 유발할 수 있는 입력으로 간주한다. 이러한 아이디어를 포착하기 위해 우리는 fuzzing이라는 용어를 다음과 같이 정의한다.\n\n**Definition 1** (Fuzziing), Fuzzing은 PUT의 예상 입력 공간을 돌출하는 입력 공간으로부터 샘플링된 입력들을 사용하여 PUT를 실행시키는 것이다.\n\n다음 세가지 설명이 있다.\n첫째, fuzz 입력 공간이 예상 입력 공간을 포함하는 것을 보는 것이 일반적일 수 있다. 이것은 필요하지 않다. 전자는 후자가 아닌 여러 번 반복하여 실행되므로 위의 반복 실행을 작성하는 것이 여전히 정확할 것이다.\n둘째, 실제로 fuzz는 거의 확실하게 여러 번 반복하여 실행되므로 위의 반복 실행을 작성하는 것이 여전히 정확할 것이다.\n셋째, 샘플링 프로세스가 반드시 무작위적일 필요는 없다. fuzz 테스트는 fuzzing을 활용하는 소프트웨어 테스트 기술의 한 형태이다. 역사적으로 fuzz test는 주로 보안 관련 버그를 찾는데 사용되었지만 , 오늘 날 많은 비보안 응용 프로그램에서도 널리 사용된다.\n\n**Definition 2** (Fuzz Testing). Fuzz Testing은 PUT가 올바른 정책을 위반하는지 테스트하기 위해 Fuzzing을 사용하는 것이다.\n**Definition 3** (Fuzzer). Fuzzer는 PUT에 대한 fuzz test를 수행하는 프로그램이다.\n**Definition 4** (Fuzz Campaign). Fuzz Campaign은 PUT에 대한 특정 fuzzer를 특정 정확도 정책과 함께 실행하는 것이다.\n\nfuzz campaign을 통해 PUT을 실행하는 목표는 지정된 정확도 정책을 위반하는 버그를 찾는 것이다. 예를 들어 초기 fuzzer들이 사용하는 정확도 정책은 생성된 입력, 즉 테스트 케이스가 PUT를 충돌시켰는지 여부만을 테스트했다. 그러나 실제로 fuzz test는 실행에서 관찰 가능한 모든 정책, 즉 EM-enforceable를 테스트하는 데 사용될 수 있다. 실행이 정책을 위반하는지 여부를 결정하는 특정 메커니즘을 Bug Orcle이라고 한다.\n\n**Definition 5** (Bug Oracle). 버그 오라클은 fuzzer의 일부로 주어진 PUT 실행이 특정 수정 정책을 위반하는지 여부를 결정하는 프로그램이다. \n\nfuzz test는 정책 위반을 찾는데 중점을 두지만, 그 기반이 되는 기술은 다른 용도로 전용될 수 있다. 실제로 fuzz에서 영감을 받은 접근 방식은 광범위한 응용 분야에서 사용되었다. 예를 들어 PerlFuzz는 성능 문제를 나타내는 입력을 찾는다. 우리는 fuzz에 의해 구현된 알고리즘을 단순히 fuzz 알고리즘이라고 부른다. 거의 모든 fuzz 알고리즘은 PUT 이후의 일부 매개변수에 의존한다. 매개변수의 각 구체적인 설정은 fuzz 구성이다.\n\n**Definitino 6** (Fuzz Configuration). fuzz 알고리좀의 fuzz 구성은 fuzz 알고리즘을 제어하는 파라미터 값으로 구성된다.\n\nfuzz 구성에 대한 우리의 정의는 광범위하다. fuzz 구성에서 값의 유형은 fuzz 알고리즘의 유형에 따라 달라진다. 예를 들어, 임의 바이트 스트림을 PUT으로 보내는 fuzz 알고리즘은 단순한 구성 공간{(PUT)}을 갖는다. 반면에 정교한 fuzzer는 구성의 추가 및 제거를 포함하는 일련의 구성을 받아들이고 시간에 따라 집합을 진화시키는 알고리즘이 포함된다. 시드는 PUT에 대한 입력으로 이를 수정하여 테스트 케이스를 생성하는 데 사용된다. 일반적으로 fuzz pool은 seed pool로 알려진 시드 컬렉션을 유지하며, 일부 fuzz는 fuzz campaign이 진행됨에 따라 pool을 진화시킨다. 마지막으로 fuzz는 각 구성내에 일부 데이터를 저장할 수 있다. 예를 들어, 커버리지 기반(:coverage-guided) 퍼저는 각 configuration에서 획득한 커버리지를 저장한다.","x":1100,"y":210,"width":1096,"height":1140},
		{"id":"a2cfeadf02e683d3","type":"text","text":"# 2.2 Paper Selection Criteria\n\n범위를 잘 설정하기 위해, 2008년 1월부터 2019년 2월까지 4개의 메이저 보안 컨퍼런스와 3개의 메이저 소프트웨어 엔지니어링 컨퍼런스의 논문집에서 퍼징에 관한 모든 출판물을 포함했다.\n\n4개의 `메이저 보안 컨퍼런스`는 다음과 같다. (모두 알파벳 순서)\n\n1. ACM Conference on Computer and Communications Security (CCS)\n\n2. IEEE Symposium on Security and Privacy (S&P)\n\n3. Network and Distributed System Security Symposium (NDSS)\n\n4. USENIX Security Symposium (USEC)\n\n3개의 `메이저 소프트웨어 엔지니어링 컨퍼런스`는 다음과 같다.\n\n1. ACM International Symposium on the Foundations of Software Engineering (FSE)\n\n2. IEEE/ACM International Conference on Automated Software Engineering (ASE)\n\n3. International Conference on Software Engineering (ICSE)\n\n다른 곳에 등장하는 퍼저들의 경우 관련성을 자체적으로 판단하여 포함하였다.\n\ntesting tool을 설계할 때, 소스코드에 대한 접근과 PUT에 대한 일부 지식이 전제되는 경우가 많다. 이러한 전제 때문에 때로는 퍼저와는 다른 성격의 테스팅 도구가 개발되곤 한다.\n\n그럼에도 불구하고 두 분야 밀접한 관련이 있다. 따라서 어떤 publication을 fuzz test와 관련된 것으로 분류하고, 본 연구에 포함할지 여부를 확신할 수 없는 경우, 다음과 같은 간단한 경험 법칙(:rule of thumb)을 따른다: `fuzz`라는 단어를 사용한 출판물이면 본 연구에 포함한다.","x":2300,"y":385,"width":1140,"height":790},
		{"id":"e5bc15ae44027e16","type":"text","text":"# 2.3 Fuzz Testing Algorithm\n\n본 논문에서는 fuzz testing을 위한 generic한 알고리즘인 `Algorithm 1`을 제시한다.\n\n- ALGORITHM 1: Fuzz Testing\n\n![](https://i.imgur.com/DpmndGI.png)\n\n이는 2.4절에 정의된 블랙 박스(black-box), 그레이 박스(grep-box), 화이트 박스(white-box) 퍼징을 포함하는 기존 퍼징 기술을 수용할 만큼 충분히 일반적이다.\n\n**Algorithm 1**은 fuzz configuration set인 C 와 timeout인 t limit ﻿을 입력으로 사용하고, 발견한 버그들의 set B를 출력으로 한다. 이는 두 파트로 구성되어있다.\n\n첫 번째 파트는 fuzz campaign이 시작될 때 실행되는 **PREPROCESS** 함수다.\n\n두 번째 파트는 loop 안의 다섯 가지의 연속하는 함수들이다: **SCHEDULE**, **INPUTGEN**, **INPUTEVAL**, **CONFUPDATE**, **CONTINUE.**\n\n이 loop의 각 실행을 `fuzz iteration`이라고 하며, ﻿**INPUTEVAL**이 test case에서 PUT를 실행하는 각 행위를 `fuzz run`이라고 한다. 어떤 퍼저는 다섯 가지 함수를 모두 구현하지는 않았을 수도 있다. 예를 들어 fuzz configuration의 set을 업데이트 하지 않는 Radamsa를 모델링하면 `CONFUPDATE`는 현재 configuration set을 그대로 return한다.\n\n- PREPROCESS(C)→C﻿\n    \n    사용자는 입력으로 fuzz configureation set과 함께 **PREPROCESS**를 제공하고, 잠재적으로 수정된(:potentially-modified) fuzz configuration set을 리턴한다. 퍼즈 알고리즘에 따라 **PREPROCESS**는 PUT에 instrumentation 코드 삽입이나 시드 파일의 실행 속도 측정 등 다양한 동작을 수행할 수 있다. (3절)\n\n- SCHEDULE(C, t elapsed​, t limit​)→conf﻿\n    \n    **SCHEDULE**은 현재 fuzz configuration set, 현재 시간인 t elapsed​﻿ 및 제한 시간인 t limit​﻿을 입력으로하고 현재 fuzz iteration에 사용할 fuzz configuration을 선택한다. (4절)\n\n- INPUTGEN(conf)→tcs﻿\n    \n    **INPUTGEN**은 fuzz configuration을 입력으로 하고, 구체적인 test case set인 tcstcs﻿를 리턴한다. 테스트 케이스들을 모을 때, **INPUTGEN**은 confconf﻿에서 구체적인 파라미터를 사용한다. test case를 생성하기 위해 confconf﻿에 있는 시드를 사용하는 퍼저도 있고, 모델이나 문법(:grammer)을 파라미터로 사용하는 퍼저도 있다. (5절)\n\n- INPUTEEVAL(conf,tcs,O bug​)→B′,execinfos﻿\n    \n    **INPUTEVAL**은 fuzz configuration인 confconf﻿, 테스트 케이스들의 set인 tcstcs﻿, 버그 오라클인 O bug​﻿를 입력으로 받는다. tcstcs﻿에서 PUT를 실행하고, 그 실행이 보안 정책을 위반하는지 여부를 버그 oracle O bug​﻿를 사용하여 확인한다. 그런 다음 발견된 버그의 set인 B﻿와 보통 fuzz configuration 업데이트에 쓰이는 각 fuzz run에 대한 정보인 execinfosexecinfos﻿를 반환한다. O         bug​﻿는 model fuzzer에 임배딩되어 있다고 가정한다. (6절)\n    \n\n- CONFUPDATE(C,conf,execinfos)→C﻿\n    \n    **CONFUPDATE**는 fuzz configuration의 set인 C﻿, 현재 configuration인 confconf﻿, 각 fuzz run에 대한 정보인 execinfosexecinfos﻿를 입력으로 한다. 그리고 fuzz configurations의 set인 C﻿를 업데이트 한다. 예를 들어, 많은 그레이 박스 퍼저는 execinfosexecinfos﻿를 기반으로 fuzz configuarion의 수를 줄인다. (7절)\n    \n\n- CONTINUE(C)→{True, False}﻿\n    \n    **CONTINUE**는 fuzz configuration의 set인 C﻿를 입력으로, 새로운 fuzz iteration이 필요한지(:occur)의 여부를 나타내는 boolean을 리턴한다. 이 함수는 탐색할 경로가 더 이상 없을 때 종료될 수 있는 화이트 박스 퍼저를 모델링하는 데 유용하다.","x":3560,"y":-140,"width":1140,"height":1840},
		{"id":"0c9a892970f269ca","type":"text","text":"# 2.4 Taxonomy of Fuzzers\n\n본 논문에서는 퍼저가 각 `fuzz run`에서 관찰하는 의미론(:semantic)적인 세분성(:granularity)을 기반으로 퍼저를 세 그룹으로 분류했다. 세 그룹은 `블랙 박스 퍼저`, `그레이 박스 퍼저`, `화이트 박스 퍼저`라고 불리며 아래와 같이 정의했다.\n\n이 분류는 두 개의 주요 범주(블랙 박스 테스트와 화이트 박스 테스트)만 있는 기존의 소프트웨어 테스트와 다르다. 그레이 박스 퍼징은 화이트 박스 퍼징의 변형으로, 각 fuzz run에서 일부 `단편적인 정보`(:partial)만을 얻을 수 있는 경우를 의미한다.","x":4780,"y":660,"width":1140,"height":240},
		{"id":"47b48459acb548ba","type":"text","text":"# 2.4.1 Black-box Fuzzer\n\n소프트웨어 테스트와 퍼징에서 사용되는 용어인 `블랙 박스`는 일반적으로 `PUT의 내부를 관찰할 수 없는 기술`을 의미한다. 입력과 출력 동작만 관찰할 수 있어서 블랙 박스라고 부른다. 소프트웨어 테스트에서는 블랙 박스 테스트를 IO-driven testing 또는 data-driven testing이라고 부른다.\n\nzzuf, BFF, GPF와 같은 대부분의 전통적인 퍼저들은 블랙 박스 퍼저에 해당된다. funfuzz나 Peach와 같은 일부 최신 퍼저는 보다 의미 있는 테스트 케이스를 생성하기 위해 입력에 대한 입력에 대한 구조적 정보를 고려하여, PUT를 검사(:inspect)하지 않는 특성을 유지한다. \\<Adaptive random testing: The ART of test case diversity>에서 유사한 아이디어가 사용된다.","x":4780,"y":977,"width":1140,"height":303},
		{"id":"54998e7db16967ce","type":"text","text":"# 2.4.2 White-box Fuzzer\n\n화이트 박스 퍼징은 블랙 박스 퍼징과 반대로 `PUT 내부와 PUT를 실행하면서 얻은 정보를 분석하여 테스트 케이스를 생성`한다. 따라서 화이트 박스 퍼저는 PUT의 state space을 체계적으로 탐색할 수 있다.\n\n화이트 박스 퍼징이라는 용어는 2007년 Godefroid의 연구 \\<Random testing for security: Blackbox vs. whitebox fuzzing>에서 도입되었는데, symbolic execution의 변형인 `dynamic symbolic execution`(DSE)를 다룬다.\n\nDSE에서 symbolic/concrete execution이 동시에 작동하며, concrete 프로그램 상태는 symbolic constraints을 단순화하는 데 사용된다(예: concretizing system calls). 그래서 DSE는 `concolic(concrete + symbolic) testing`이라고도 한다.\n\n또한 화이트 박스 퍼징은 `taint analysis`를 사용하는 퍼저를 설명하는데도 사용되었다:\\<Taint-based directed whitebox fuzzing>. 화이트 박스 퍼징은 일반적으로 블랙 박스 퍼징보다 오버 헤드(over head)가 훨씬 높다. 이는 DSE를 구현할 때 종종 dynamic instrumentation과 SMT solving을 사용하기 때문이기도 하다. DSE는 활발한 연구 분야지만, 많은 DSE가 보안 버그를 찾는 것을 목표로 하지는 않기 때문에 **화이트 박스 퍼저가 아니다**. 따라서 이 본 논문에서는 DSE에 대한 포괄적인 survey를 제공하지 않으며, DSE에 대한 자세한 내용은 최근 survey 논문인 \\<An orchestrated survey of methodologies for automated software test case generation>와 \\<All you ever wanted to know about dynamic taint analysis and forward symbolic execution>을 참고하라.","x":4780,"y":1364,"width":1140,"height":516},
		{"id":"cdd4125cbaabe293","type":"text","text":"# 2.4.3 Grey-box Fuzzer\n\n`그레이 박스 퍼징`이라는 절충적인(:middle ground) 접근 방식을 사용하는 퍼저도 있다. 그레이 박스 퍼저는 더 많은 입력을 테스트하고 속도 측면의 최적화를 위해 `근사적이고 불완전한 정보`에 의존한다.\n\n보통 그레이 박스 퍼저는 PUT와(또는) 실행에 대한 내부 정보를 얻을 수 있다. 화이트 박스 퍼저와 달리, 그레이 박스 퍼저는 PUT에 대한 full semantics을 추론(:reason)하지는 않는다. 대신 가벼운 정적 분석을 수행하거나 PUT와(또는) 코드 커버리지와 같은 실행에 대한 동적인 정보를 획득할 수 있다.\n\n블랙 박스 퍼징, 그레이 박스 퍼징, 화이트 박스 퍼징의 구분이 항상 명확한 것은 아니다. 블랙 박스 퍼저가 fuzz run에 대한 정보를 획득할 수도 있으며, 화이트 박스 퍼저자 종종 개략적인 정보를 활용하기도 한다. 본 연구에서, 특히 Table 1에서 최선의 판단을 하기 위해 노력했다.\n\n그레이 박스 퍼저의 초기 예는 EFS로, 각 fuzz run에서 획득한 코드 커버리지를 이용해 evolutionary 알고리즘으로 테스트 케이스를 생성했다. Randoop도 비슷한 접근 방식을 사용했지만, 보안 취약점이 목표는 아니었다. 최신 퍼저인 AFL이나 VUzzer가 그레이 박스 퍼저에 속한다.","x":4780,"y":1960,"width":1140,"height":480},
		{"id":"1d8adf6f64990bd7","type":"text","text":"# 2.5 - 3 Fuzzer Genealogy and Overview\n\n아래 Figure 1은 현재 존재하는 퍼저들을 시간순으로 나타낸 그림이다.\n\n- **Figure 1**\n    \n    Miller의 퍼저로 거슬러 올라가는 퍼저들의 계보. 같은 행의 각 노드는 같은 연도에 나타난 퍼저임을 의미한다. X —> Y 꼴의 실선 화살표는 Y가 X의 기술을 인용, 참조, 사용하고 있다는 것을 의미한다. 📕은 논문으로 출판되었음을 의미한다.\n\n![](https://i.imgur.com/6wj50yS.png)\n\n최초의 퍼저인 Miller의 퍼저부터, 메이저 컨퍼런스에서 발표되었거나 100개 이상의 github star를 받은 인기 있는 퍼저들을 골라서 관계도를 그래프로 나타냈다. 블랙 박스 퍼저는 왼쪽에, 그레이 박스 퍼저와 화이트 박스 퍼저는 오른쪽에 배치했다.\n\n이후 파일, 네트워크, UI, 웹, 커널, I/O, 스레드(concurrency fuzzer)와 같이 PUT의 입력 종류에 따라 세분화했다.\n\n아래 `Table 1`은 `Figure 1`에서 가장 주목할만한 퍼저에 사용된 기술을 요약한 표이다.\n\n- **Table 1**\n\n    instrumentation granularity와 이름으로 정렬한 퍼저들 개요. 블랙박스(●), 그레이박스(◑), 화이트박스(○)\n\n![](https://i.imgur.com/ChAZ20v.png)\n\n공간상 제약으로 Figure 1의 일부 퍼저를 생략했다.\n\n각 퍼저를 앞서 제시한 model fuzzer의 다섯 가지 함수(PREPROCESS, SCHEDULE, INPUTGEN, INPUTEVAL, CONFUPDATE)와 퍼저의 세부 정보를 제공하는 기타 섹션(Misc.)으로 분류했다.\n\n다음은 각 열이 나타내는 특징들이다.\n\n- \\[Misc.]\n    \n    **Feedback Gathering Granularity** : 퍼저가 블랙 박스(●), 그레이 박스(◑), 화이트 박스(○) 중 무엇인지 나타낸다. 퍼저가 서로 다른 종류의 피드백을 획득해 사용하는 경우 원이 두 개다. 예를 들어, SymFuzz는 전처리로 화이트 박스를 분석하여 후속 블랙 박스 캠페인의 성능을 최적화한다(●+○). Driller와 같은 하이브리드 퍼저는 화이트 박스 퍼징과 그레이 박스 퍼징을 번갈아가며 사용한다(○+◑).\n    \n    **Open-Sourced** : 퍼저가 오픈소스코드인지 나타낸다.\n    \n    **Source Code Required** : 퍼징을 할 때 PUT의 소스코드가 필요한지 나타낸다.\n    \n\n- PREPROCESS\n    \n    **Support In-memory Fuzzing** : 퍼저가 in-memory 퍼징(3.1.2)을 지원하는지 나타낸다.\n    \n    **Model Construction** : 퍼저가 모델을 추론(:infer)할 수 있는지 나타낸다.\n    \n    **Program Analysis** : 퍼저가 PREPROCESS 단계에서 정적 분석이나 동적 분석을 수행하는지 나타낸다.\n    \n\n- SCHEDULE\n    \n    **Seed Scheduling** : 퍼저가 여러 개의 시드를 처리하고 스케줄링을 수행하는지 나타낸다.\n    \n\n- INPUTGEN\n    \n    **Mutation** : 퍼저가 테스트 케이스를 생성하기 위해 입력에 변이(:mutation)를 수행하는지 여부를 나타낸다. execution feedback을 통한 입력 변이 기반 퍼저인지 나타내기 위해 ◑ 심볼을 사용한다.\n    \n    **Model-based** : 퍼저가 모델을 기반으로 테스트 케이스를 생성하는지 나타낸다.\n    \n    **Constraint-based** : 퍼저가 테스트 케이스 생성을 위해 symbolic analysis을 하는지 나타낸다.\n    \n    **Taint Analysis** : 테스트 케이스 생성 과정을 위해 taint analysis를 사용하는지 나타낸다.\n    \n\n- INPUTEVAL\n    \n    **Crash Triage: Stack Hash** : 퍼저가 크래시 분류(:triage)를 수행할 때 stack hashing을 사용하는지 나타낸다.\n    \n    **Crash Triage: Coverage** : 퍼저가 크래시 분류(:triage)를 수행할 때 코드 커버리지를 사용하는지 나타낸다.\n    \n\n- CONFUPDAE\n    \n    **Evolutionary Seed Pool Update** : CONFUPDATE 단계에서 \"시드 풀에 새로운 시드 추가\"와 같은 시드 풀 evolve 과정이 있는지 나타낸다.\n    \n    **Model Update** : 퍼저가 online 방식으로 입력 모델을 학습하는지 나타낸다. \\[머신러닝의 online]\n    \n    **Seed Pool Culling** : 시드 풀에서 시드를 제거하는지 나타낸다.","x":6360,"y":-1020,"width":1140,"height":3600},
		{"id":"9c78467e566cf6a0","type":"text","text":"# 3.1 Instrumentation\n\n블랙 박스 퍼저와 달리 그레이 박스나 화이트 박스 퍼저는 INPUTEVAL 단계에서 fuzz run을 할 때 `execution feedback`을 수집하거나 런타임에 메모리를 퍼징하도록 PUT를 instrument 할 수 있다. 수집되는 정보의 양에 따라 블랙 박스, 화이트 박스, 그레이 박스로 정의된다. PUT 내부 정보를 수집하는 다른 방법들(예: processor traces나 system call usage)이 있긴 하지만, `instrumentation은 가장 가치 있는 피드백을 수집하는 방법`을 의미한다.\n\n프로그램 instrumentation은 `정적(static)`이거나 `동적(dynamic)`일 수 있다. 정적의 경우 PUT 실행 전에 수행하고(PREPROCESS), 동적의 경우 실제로는 PUT 실행 중(INPUTEVAL)에 수행한다. 그러나 독자의 편의를 위해 이 섹션(PREPROCESS)에서 동정과 정적 instrumentation을 모두 요약한다.\n\n실제로 dynamic instrumentation은 INPUTEVAL에서 이루어짐.\n\n- **static instrument**\n    \n    static instrument은 종종 소스 코드나 중간 코드(intermediate code)를 컴파일할 때 수행된다. 실행시간 전에 instrument 하면, 동적 instrument보다 런타임(runtime) 오버헤드가 적다. 만약 PUT가 라이브러리를 의존하는 경우, 보통 동일한 instrumentation으로 다시 컴파일해서 별도로 instrument 한다. 소스 코드 기반 instrumentation 외에도, 바이너리 수준의 동적 instrumentation(i.e., binary rewriting) 도구를 개발한 연구들도 있다: \\<A platform for secure static binary instrumentation>, <PEBIL: Efficient static binary instrumentation for linux>, <Vulcan: Binary transformation in a distributed environment>.\n    \n\n- **dynamic instrument**\n    \n    동적의 경우 정적 보다 오버헤드가 심하다는 단점이 있지만, instrumentation이 런타임 도중에 이뤄지기 때문에 동적으로 링크되는 라이브러리를 쉽게 instrument 할 수 있다는 장점이 있다. 여기 잘 알려진 몇 개의 동적 instrumentation 도구들을 소개한다 : DynInst, DynamoRIO, Pin, Valgrind, and QEMU.\n    \n\n한 퍼저가 한 가지 이상의 instrumentation 방법을 사용할 수도 있다. 예를 들어 AFL은 전용(:modified) 컴파일러를 이용해 소스 코드 수준의 정적 instrument를 하기도 하고, QEMU의 도움으로 바이너리 수준의 동적 instrument를 하기도 한다. 동적 instrumentation 방식을 사용하는 경우, AFL은 (1) 실행 가능한 코드를 PUT 내부에서 instrument 하거나(기본 설정) (2) 실행 가능한 코드를 PUT나 외부 라이브러리에서 instrument 한다(AFL_INST_LIBS 옵션). 두 번째 옵션은 실행되는(:encountered) 코드를 모두 instrument 하는 것인데, 외부 라이브러리의 코드에 대한 커버리지 정보도 포함할 수 있어서, 더 완전한 커버리지 정보를 제공한다. 이는 AFL이 외부 라이브러리 함수에서 추가적인 경로를 퍼징하도록 도와준다.\n","x":1100,"y":2320,"width":1096,"height":930},
		{"id":"cd95149f5a92fc20","type":"text","text":"# 3 Preprocess\n\n어떤 퍼저는 첫 번째 fuzz iteration 전에 fuzz configuration의 초기 set을 수정한다. 이러한 `preprocess`(전처리)는 보통 PUT를 instrument(:추론)하고, 잠재적으로 중복될 수 있는 configuration을 제거하고, 시드를 트리밍(trim)하고, driver application을 생성하는데 사용된다. 5.1.1절에서 자세히 다루겠지만, PREPROCESS는 향후 입력 생성(INPUTGEN)을 위한 모델을 준비하는데 사용될 수도 있다.","x":-100,"y":2654,"width":1096,"height":263},
		{"id":"356faa05390d77be","type":"text","text":"# 3.1.1 Execution Feedback\n\n그레이 박스 퍼저는 보통 테스트 케이스를 evolve하기 위한 입력으로 `execution feedback` 정보를 사용한다.\n\nAFL과 그 하위(AFL 계보 퍼저들)의 퍼저는 PUT의 모든 branch instruction을 instrument해서 branch coverage를 계산한다. 그러나 branch coverage 정보를 bit vector에 저장하므로 충돌쌍(path collision)이 발생할 수 있다. CollAFL은 이러한 문제를 해결하기 위해 path-sensitive hash function를 도입했다. 반면 LibFuzzer와 Syzkaller는 execution feedback을 위해 node coverage를 사용한다. Hongfuzz는 어떤 execution feedback을 사용할지 사용자가 선택할 수 있게 하였다.","x":1100,"y":3330,"width":1096,"height":265},
		{"id":"2fe751ade5db6fb8","type":"text","text":"# 3.1.2 In-Memory Fuzzing\n\n크기가 큰 프로그램을 테스트할 때, 프로그램 실행 시 발생하는 오버헤드를 줄이기 위해 각 fuzz iteration 과정에서 프로세스를 다시 생성하지 않고, `PUT의 일부분만 퍼징`하는 것이 좋다.\n\n- **in-memory** \n\nGUI처럼 복잡한 프로그램은 프로세스를 생성하고 입력을 전달하기까지 수 초가 소요된다. 이런 프로그램을 퍼징하기 위해 GUI 초기화가 완료된 후에 메모리 스냅샷(snapshot)을 찍는 접근 방식이 존재한다. 새로운 테스트 케이스를 퍼징하기 위해, 테스트 케이스를 메모리에 집접 쓰고 실행하기 전에, 메모리 스냅샷을 복원할 수 있다. 클라이언트-서버간의 상호 작용이 많은 네트워크 응용프로그램을 퍼징할 때도 이런 접근 방식을 사용할 수 있다.\n\n예를 들어, GRR은 입력 바이트를 로딩하기 전에 스냅샷을 찍는다. 그러면 불필요한 초기 실행 코드를 건너뛸 수 있다. AFL은 초기 실행의 코스트를 줄이기 위해 fork server를 사용한다. fork server는 모든 fuzz iteration에 대해 새로운 프로세스를 fork 한다.\n\n- **in-memory API fuzzing**\n\nLibfuzzer나 AFL 같은 퍼저들은 각 iteration 이후 PUT의 상태를 복구하지 않으면서도 in-memory 퍼징을 수행한다. 예를 들어 AFL은 persistent mode라는 옵션을 이용해, 프로세스를 재시작하지 않고 loop에서 in-memory API fuzzing을 반복 수행한다. 이 경우, 동일한 실행에서 여러 번 호출되는 함수에서 발생 가능한 side effect를 찾지 못할 수도 있지만, AFL은 이를 감안한다.\n\n이러한 효율성에도 불구하고, in-memory API fuzzing은 버그나 크래시가 reproducing이 안 되는 부정확한 결과를 초래하기도 한다. 그 이유는 다음과 같다.\n\n(1) 타겟 함수를 정확하게 호출하는 calling context를 재현하지 못할 수 있다.\n\n(2) 함수를 여러 번 호출하는 과정에서 캡쳐하지 못한 side-effect가 있을 수 있다.\n\nin-memory API fuzzing은 entry point 함수를 정확하게 찾는 것이 중요한데, 이는 아주 어려운(:challenging) 일이다.","x":1100,"y":3670,"width":1096,"height":820},
		{"id":"7d432adff82390c9","type":"text","text":"# 3.1.3 Thread Scheduling\n\n`race condition` bug는 드물게 발생하는 비결정론적인 동작에 의해 발생하기 때문에 트리거 하기 어렵다. 그러나 instrumentation은 스레드가 `스케줄 되는 방식을 제어`해서 다른 비결정론적인 프로그램을 트리거 할 수 있다.\n\n이런 방식은 아래 연구들을 참고하라: \\<Effective random testing of concurrent programs>, \\<Race directed random testing of concurrent program>, \\<Randomized active atomicity violation detection in concurrent programs>, \\<A randomized dynamic program analysis technique for detecting real deadlocks>, \\<Detecting atomic-set serializability violations in multithreaded programs through active randomized testing>, <MagicFuzzer: Scalable deadlock detection for large-scale applications>, \\<Synthesizing racy tests>\n\n반대로 <Effective random testing of concurrent programs]>에서는 스레드를 `랜덤하게 스케줄링`하는 것이 race condition bug를 찾는데 효과적일 수 있다는 사실을 보였다.","x":1100,"y":4570,"width":1096,"height":400},
		{"id":"cacaf18627b02240","type":"text","text":"# 3.2 Seed Selection\n\n2절에서 전술하였듯이 퍼저는 퍼징 알고리즘의 동작을 제어하는 `fuzz configuration set`을 전달받는다. 불행하게도 일부 fuzz configuration의 파라미터들은 그 값의 범위(:domain)가 크다. (예: 변이 기반 퍼저의 시드)\n\n예를 들어, MP3 파일을 입력으로 받는 MP3 player를 퍼징한다고 가정해보자. 생성 가능한 MP3 파일은 무한하기 때문에 다음과 같은 질문을 떠올릴 수 있다: 퍼징에 어떤 시드를 사용해야 할까?\n\n초기 시드 풀의 크기를 줄이는 문제를 `seed selection problem`이라고 한다.\n\nseed selection 문제를 해결하는 몇 가지 접근 방식과 도구들이 있다. 일반적인 접근 방식은 node coverage 같은 `coverage metric를 최대화` 할 수 있는 `가장 작은 seed set`을 찾는 것이다. 이런 과정을 `minset` 계산이라고 한다.\n\n예를 들어, 현재 configuration set C가 시드 s1, s2로 구성되어 있고, 이를 실행하면 PUT이 다음과 같은 주소를 커버한다고 가정하자: `{s1 → {10, 20} , s2 → {20, 30}}`. 그리고 s1과 s2만큼 빠르게 실행되는 세 번째 시드 `s3가 {10, 20, 30}`을 커버한다고 가정하면, s1과 s2 대신 s3를 fuzz하는게 합리적이다. (직관적으로, 실행 시간의 비용은 절반인데 더 많은 프로그램 logic을 테스트하기 때문) 코드 커버리지가 1% 증가하면 버그 발견율이 92% 증가했다는 Miller의 연구 \\<Fuzz by number: More data about fuzzing than you ever wanted to know>가 이런 직관을 뒷받침해 준다.\n\n7.2절에서 다루겠지만 이 단계는 CONFUPDATE에 포함될 수 있다. 이는 캠페인 전체에 걸쳐 시드 풀에 새 시드를 추가할 수 있는 퍼저에게 유용하다.\n\n퍼저는 실제로 다양한 `coverage metric`를 사용한다.\n\n예를 들어, AFL의 minset은 각 branch에 지수적(:logarithm)인 카운터가 있는 branch coverage를 기반으로 한다. 그 이유는 branch 카운터가 몇 배 차이로 다를 때만 차이가 있다고 인지하도록 설정한 것이다.\n\nHongfuzz는 실행된 instruction, 실행된 branch, unique basic block의 수를 기반으로 커버리지를 계산한다. 이 metric은 퍼저가 minset에 대해 더 긴 실행을 추가할 수 이어서 DoS 취약점이나 성능 관련 문제를 탐지하는 데 도움이 될 수 있다.","x":2308,"y":2361,"width":1096,"height":849},
		{"id":"e861401aeb0e211e","type":"text","text":"# 3.3 Seed Trimming\n\n시드가 작을수록 메모리는 더 적게 소비하고, 더 높은 throughput을 유도한다. 따라서 어떤 퍼저는 퍼징을 하기 전에 먼저 `시드의 크기를 줄인다`. 이런 기술을 `seed trimming`이라고 한다. 시드 트리밍은 PREPROCESS에서 메인 fuzzing loop을 수행하기 전에 수행되거나, CONFUPDATE의 일부분으로 수행된다.\n\nAFL은 어떤 시드가 동일한 커버리지를 달성하도록 유지하면서, 그 시드의 일부분을 제거하는 코드 커버리지 instrumentation을 사용한다.\n\n한편 Rebert의 연구에 따르면, 크기가 작은 시드에 더 높은 우선순위를 부여하는 minset 알고리즘은 랜덤하게 시드를 선택하는 경우보다 unique 한 버그가 더 적게 발견될 수도 있다고 한다. MoonShine은 Linux system call handler 퍼징의 특정 사례를 위해 syzkaller를 확장하여 시드 크기를 줄이면서 정적 분석을 사용하여 감지된 호출 간의 dependency를 유지한다.","x":3560,"y":2595,"width":1140,"height":381},
		{"id":"cb65917d8e1b625d","type":"text","text":"# 3.4 Preparing a Driver Application\n\n시드가 작을수록 메모리는 더 적게 소비하고, 더 높은 throughput을 유도한다. 따라서 어떤 퍼저는 퍼징을 하기 전에 먼저 `시드의 크기를 줄인다`. 이런 기술을 `seed trimming`이라고 한다. 시드 트리밍은 PREPROCESS에서 메인 fuzzing loop을 수행하기 전에 수행되거나, CONFUPDATE의 일부분으로 수행된다.\n\nAFL은 어떤 시드가 동일한 커버리지를 달성하도록 유지하면서, 그 시드의 일부분을 제거하는 코드 커버리지 instrumentation을 사용한다.\n\n한편 Rebert의 연구에 따르면, 크기가 작은 시드에 더 높은 우선순위를 부여하는 minset 알고리즘은 랜덤하게 시드를 선택하는 경우보다 unique 한 버그가 더 적게 발견될 수도 있다고 한다. MoonShine은 Linux system call handler 퍼징의 특정 사례를 위해 syzkaller를 확장하여 시드 크기를 줄이면서 정적 분석을 사용하여 감지된 호출 간의 dependency를 유지한다.","x":4780,"y":2599,"width":1140,"height":374},
		{"id":"6a0eeb7243ddf125","type":"text","text":"# 4. Scheduling\n\n퍼징에서 `scheduling`은 `다음 fuzz iteration을 위해 fuzz configuration을 선택하는 것`을 의미한다. 전술했듯이, 각 configuration의 내용은 퍼저의 유형에 따라 다르다.\n\n간단한 퍼저의 경우 스케줄링이 단순하다. 예를 들어, zzuf의 기본 모드는 하나의 configuration만 허용한다. BFF나 AFLFast과 같이 더 복잡한(:advanced) 퍼저의 경우, 기발한 스케줄링 알고리즘이 해당 퍼저의 성공과 직결되는 아주 중요한 요소로 작용했다.\n\n이 섹션에서 블랙 박스 퍼징과 그레이 박스 퍼징의 스케줄링 알고리즘만을 다룬다. 화이트 박스 퍼징의 스케줄링은 symbolic executor에 복잡한 설정이 필요해서 생략한다. 궁금한 독자는 다음 연구를 참고하라: <[Billions and billions of constraints: Whitebox fuzz testing in production](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/main-may10.pdf)>.","x":-100,"y":5160,"width":1096,"height":360},
		{"id":"c3d92ee6d8d3641e","type":"text","text":"# 4.1 The Fuzz Configuration Scheduling (FCS) Problem\n\n`스케줄링`의 목표는 configuration에 대해 현재 사용 가능한 정보를 분석하고 `가장 유리한 결과`(예: unique한 버그의 수가 많아지거나, 생성된 입력 set을 통해 커버리지 최대화하기 등)로 이어질 가능성이 있는 정보를 선택하는 것이다.\n\n기본적으로 모든 스케줄링 알고리즘은 `탐색`(:exploration)과 `익스플로잇`(exploitation)의 trade off 문제에 직면하게 된다.\n\n- **exploration**\n    \n    향후 결정을 위해 각 configuration에 대한 더 정확한 정보 수집에 시간을 할애하는 것이 합리적이다.\n    \n\n- **exploration**\n    \n    현재 가장 유리한 결과물로 이어질 것 같은 configuration을 퍼징하는 것이 합리적이다.\n    \n\nWoo의 연구 Scheduling black-box mutational fuzzing>에서 이러한 고질적인 문제를 `Fuzz Configuration Scheduling (FCS) Problem`라고 정의했다.\n\n**Algorithm 1**에서 제시한 model fuzzer에서 SCHEDULE은 현재 fuzz configuration set인 `C`﻿, 현재 시간인 `t elapsed​`﻿, time out인 `t limit​`﻿ 세 가지를 기반으로 다음 configuration을 선택한다. 이 configuration은 다음 fuzz iteration을 위해 쓰인다.\n\nSCHEDULE은 오직 `의사결정`(:decision-making)에 관한 동작일 뿐이다. 이 결정의 기반이 되는 정보는 PREPROCESS와 CONFUPDATE에서 획득되며, 이 지식으로 C﻿가 업데이트(:augment)된다.","x":1100,"y":5021,"width":1096,"height":638},
		{"id":"f823f8a8a0757776","type":"text","text":"# 4.2 Black-box FCS Algorithms\n\n블랙 박스 환경에서 FCS 알고리즘이 사용할 수 있는 정보는 fuzz configuration의 결과(크래시와 버그의 수, 소요 시간) 뿐이다.\n\nHouseholder and Foote의 연구 \\<Probability-based parameter selection for black-box fuzz testing>에서 변이 기반 블랙 박스 퍼저 CERT BFF에서 이런 정보가 어떻게 활용될 수 있는지 처음 제시되었다. 해당 연구에서 더 높은 성공률( bugs, runs﻿)을 가진 configuration이 더 유리하다고 가정했다. 실제로 BFF에서 uniform-sampling scheduling 알고리즘을 적용하여, ffmpeg 프로그램을 5백만 번 실행했다. 결과적으로 unique crash가 85% 증가한 것을 관찰할 수 있었으며, 이를 통해 FCS algorithm이 향상되면 잠재적으로 이점이 있을 수 있다는 것을 입증했다.\n\n얼마 지나지 않아 Woo의 연구 \\<Scheduling black-box mutational fuzzing>에서 이 아이디어를 여러 측면에서 개선하였다.\n\n일련의 Bernoulli trial에서 Weighted Coupon Collector’s Problem with Unknown Weights (WCCP/UW)라는 문제로 변이 기반 블랙 박스 퍼징의 수학적인 모델을 개선했다. 전자(Bernoulli trials)는 각 configuration이 고정적인 최종 성공 확률을 가지고 있다고 가정하고 시간이 지남에 따라 학습한다. 후자(WCCP/UW)는 upper-bound를 명시적으로 유지한다(as it decays).\nWCCP/UW 모델이 multi-armed bandit(MAB) 문제에 대한 알고리즘을 investigate하도록 유도했으며, 이는 decision science에서 exploration vs exploitation 문제에 대처하기 위한 전형적인 방식(:formalism)이다. 이를 위해 아직 decayed된 것으로 알려지지 않은 configuration을 정확하게 exploit하는 MAB 알고리즘을 구상할 수 있었다.\n그들은 퍼징을 더 빠르게 할 수 있는 configuration이 더 많은 unique bug를 발견하거나 향후 성공 확률에 대한 upperbound를 더 빠르게 감소시킬 수 있다고 보았다. 이를 통해 configuration에 사용한 시간으로 성공 확률을 정규화하여, 더 빠른 configuration이 유리하도록 했다.\nBFF에서 fuzz iterations(BFF에서 epoch에 해당) per configuration selection이었던 기존의 fuzz run의 orchestration을 fixed amount of time per selection으로 변경했다. 덕분에 BFF는 느린 configuration에 시간 낭비하지 않을 수 있게 되었다.\n결과적으로 기존 BFF와 비교했을 때 동일한 시간 동안 unique 버그를 1.5배 더 많이 발견할 수 있다는 것을 보여주었다.\n","x":2320,"y":4970,"width":1096,"height":740},
		{"id":"73c3a28493a8412f","type":"text","text":"# 4.3 Grey-box FCS Algorithms\n\n그레이 박스 환경에서, FCS 알고리즘은 더 많은 정보들(예: 커버리지 획득 정보 등)을 사용해 configuration을 선택할 수 있다.\n\nAFL은 이 분야의 선두주자인데, evolutionary algorithm(EA)을 사용한다. 간단히 말하면, EA는 `fitness`의 가치가 있는 configuration set을 유지한다. EA는 `fit한`(이하 `더 효과적인`으로 해석) configuration을 선택하고 나중에 새로운 configuration이 될 수 있는 자식을 생성하기 위해 mutation이나 재조합과 같은 유전적 변형(:genetic transformation)을 적용한다. 이는 이렇게 만들어진 configuration이 효과적일 가능성이 높을 것이라는 가정을 기반으로 한다.\n\nEA의 관점에서 FCS를 이해하려면 다음 세 가지를 잘 정의해야 한다.\n\n(i) configuration을 효과적으로 만드는 요소\n\n(ii) configuration 선택 방법\n\n(iii) 선택된 configuration가 사용되는 방법\n\nAFL에서는 control-flow edge를 실행하는 configuration 중, **가장 빠르고 가장 작은** configuration 입력을 포함하는 configuration을 가장 효과적(AFL에서는 **favorite**라는 용어를 사용)이라고 판단한다. AFL은 config 큐를 원형 큐(circular queue) 형태로 유지하면서 다음으로 효과적인 configuration을 선택하고, 일정한 횟수만큼 실행한다.\n\n빠른 configuration이 효과적이라고 판단하는 것은 블랙 박스 환경의 FCS와 유사하다.\n\n최근에 AFLFast는 위 세 가지 측면에서 AFL을 개선했다.\n\n1. AFLFast는 입력이 \"**favorite**\"이 되도록 두 가지 기준을 추가했다.\n\n(i) control flow edge를 실행하는 configuration 중에서 AFLFast는 가장 적게 선택되는 configuration을 선호한다. 이는 edge를 실행하는 configuration들 사이에서 cycling하는 효과가 있었고, 덕분에 exploration 관점에서 유리하다.\n\n(ii) (i)이 동일한 경우 가장 적게 실행된 경로를 탐색할 수 있는 configuration을 더 선호한다. 이는 아직 커버하지 못한 영역을 탐색할 수 있게 해주는 희귀한 경로를 더 많이 찾게 해주는 효과가 있다.\n\n2. AFLFast round-robin 방식 대신 우선순위에 따라 효과적인 다음 configuration을 선택하는 방식을 사용한다.\n\n특히 효과적인 configuration은 덜 선택되거나 더 희귀한 경로를 탐색할 수 있는 경우 우선순위가 높다. 첫 번째 개선사항(위에서 추가한 두 가지 기준)과 유사하게, 효과적인 configuration들 간의 탐색을 늘리고 희귀한 경로를 많이 탐색할 수 있는 효과가 있다.\n\n3. AFLFast는 power schedule을 기반으로 선택된 configuration을 다양한 횟수만큼 퍼징한다.\n\nAFLFast의 FAST power schedule은 \"**energy**\"라는 작은 값에서 시작하는데, 이는 configuration들 간의 초기 탐색을 보장하고 충분한 탐색을 위해 limit까지 지수 단위로 증가한다. 또한 동일한 경로를 탐색하는 입력의 수를 energy를 기반으로 정규화하여 더 적게 퍼징되는 configuration을 탐색할 수 있도록 한다.\n\nAFLFast의 이러한 변화들은 효과적이었다. 24시간 동안 퍼징한 결과, AFL이 발견하지 못한 버그를 3개 더 발견했으며, 두 퍼저 모두 발견한 6개의 버그는 평균 7배 더 빠르게 발견했다.\n\nAFLGo는 특정 프로그램의 위치를 타겟으로 우선순위 속성(:attribution)을 수정하여 AFLFast를 확장했다. Hawkeye는 시드 스케줄링과 입력 생성 단계에서 정적 분석을 활용하여 directed fuzzing을 개선했다. FairFuzz는 시드와 rare branch의 각 쌍에 대해 mutation mask를 적용하여 campaign이 rare branch를 실행하도록 했다. QTEP은 정적 분석을 통해 바이너리의 어떤 부분이 더 \"`결함`(:faulty)\"인지 추론하고, 이를 포함하는 configuration에서 우선순위를 부여하는 방식을 사용한다.","x":3560,"y":4645,"width":1140,"height":1390},
		{"id":"040f5e026598e266","type":"text","text":"# 5. Input Generation\n\n테스트 케이스가 버그 발생 여부와 직결되기 때문에, 입력 생성에 사용되기 때문에 `입력 생성`(:input generation)은 퍼저에서 가장 중요한 design decision 중 하나이다.\n\n전통적으로 퍼저는 `생성 기반`(generation-based) 퍼저와 `변이 기반`(mutation-based) 퍼저로 분류할 수 있다. 생성 기반 퍼저는 PUT가 처리할 수 있는 입력 공간에 대한 모델을 기반으로 테스트 케이스를 생성한다. 본 논문에서는 이하 모델 기반(model-based) 퍼저라고 부르겠다.\n\n반면 변이 기반 퍼저는 주어진 시드 입력을 기반으로 변이 시켜 테스트 케이스를 생성한다. 생성 기반 퍼저는 보통 모델이 없는 퍼저에서 사용된다. 그 이유는 시드는 단지 작은 예시일 뿐이고 대부분 PUT의 예상 입력 공간을 다 커버하지 못하기 때문이다.\n\n본 절에서는 테스트 케이스 생성(INPUTGEN) 매커니즘을 기반으로 퍼저가 사용하는 다양한 입력 생성 방법을 다룬다.","x":-100,"y":5850,"width":1096,"height":430},
		{"id":"7ddd9d514548715b","type":"text","text":"# 5.1 Model-based (Generation-based) Fuzzers\n\n생성 기반 퍼저가 테스트 케이스를 생성하기 위해 기반으로 사용하는 모델의 예시로 입력 형식을 특성화(:characterizing)하는 **정확한 문법**이나 파일 유형을 식벽하기 위해 magic value와 같은 **덜 정확한 제약**사항이 있다.","x":1100,"y":5990,"width":1096,"height":150},
		{"id":"ed470972680d2519","x":1100,"y":6280,"width":1096,"height":760,"type":"text","text":"# 5.1.1 Predefined Model\n\n사용자가 설정할 수 있는 모델을 사용하는 퍼저들도 있다.\n\nPeach, PROTOS, Dharma사용자가 설정하는 모델을 사용다. Autodafe, Sulley, SPIKE, SPIKEfile은 사용자가 입력 모델을 생성 할 수 있는 API를 제공한다. Tavor는 EBNF(Extended Backus-Naur Form)로 작성된 명세(:specification)를 이용하여 해당 문법에 맞는 테스트 케이스를 생성한다. 유사하게 PROTOS, SNOOZE, KiF, T-Fuzz와 같은 네트워크 프로토콜 퍼저도 사용자로부터 프로토콜 명세를 받는다. 커널 API 퍼저 Trinity, syzkaller, KernelFuzzer, Triforce linux syscall fuzzer, perf fuzzer는 system call template의 형태로 입력 모델을 정의한다. 이런 템플릿은 보통 시스템 콜이 입력으로 사용하는 넘버링과 인자의 수를 지정한다. 모델을 기반으로 커널을 퍼징하는 아이디어는 Koopman의 연구 \\<Comparing operating systems using robustness benchmarks>에서 비롯되었다. 이 연구에서 OS의 강건함(:robustness)을 시스템 호출을 위해 선택한 유한한 테스트 케이스 set과 비교했다. Nautilus는 범용(general-purpose) 퍼징을 위해 문법(grammar) 기반 입력 생성을 사용하며, 이 문법을 시드 트리밍에서도 사용한다.\n\n특정 언어나 문법을 대상으로 하며 언어 모델이 퍼저에 내장되어 있는 퍼저들도 있다. cross fuzz와 DOMfuzz은 랜덤한 DOM(Document Object Model) 객체를 생성한다. jsfunfuzz는 문법 모델을 기반으로 랜덤하지만 문법적으로 올바른 Javascript 코드를 생성한다. QuickFuzz는 파일 포멧을 설명하는 Haskell 라이브러리를 활용한다. Frankencerts, TLS-Attacker, tlsfuzzer, Ll-fuzzer와 같은 네트워크 프로토콜 퍼저들은 TLS나 NFC와 같은 특정 네트워크 프로토콜 모델을 기반으로 설계되었다.\n\nDewey는 연구 \\<Language fuzzing using constraint logic programming>와 \\<Fuzzing the rust typechecker using clp>에서 constraint logic programming을 활용하여 문법적으로 정확하면서, 의미론적으로(:semantically) 다양한 테스트 케이스를 생성하는 방법을 제안했다.\n\nLangFuzz는 입력으로 주어지는 시드 set을 파싱 하여 코드 조각을 만든다. 그리고 랜덤하게 코드 조각(:fragment)을 결합하고 시드와 함께 변이 시켜 테스트 케이스를 생성한다. 문법(:grammar)을 기반으로 하기 때문에 문법적으로(:syntactically) 올바른 테스트 케이스를 생성할 수 있다. LangFuzz는 JavaScript와 PHP에 적용되었다. BlendFuzz는LangFuzz와 비슷한 아이디어를 기반으로 XML과 정규 표현식을 대상으로 한다."}
	],
	"edges":[
		{"id":"5768795ffe8ef9b4","fromNode":"a938b0ff11d7b889","fromSide":"right","toNode":"78cc7de75c47b6b7","toSide":"left"},
		{"id":"71422fe8882d48c1","fromNode":"78cc7de75c47b6b7","fromSide":"right","toNode":"a2cfeadf02e683d3","toSide":"left"},
		{"id":"e5814e7cf378c2af","fromNode":"a2cfeadf02e683d3","fromSide":"right","toNode":"e5bc15ae44027e16","toSide":"left"},
		{"id":"8a2a560ce25dc895","fromNode":"e5bc15ae44027e16","fromSide":"right","toNode":"0c9a892970f269ca","toSide":"left"},
		{"id":"5fd530593b7f6e33","fromNode":"0c9a892970f269ca","fromSide":"bottom","toNode":"47b48459acb548ba","toSide":"top"},
		{"id":"22459096492b52c4","fromNode":"47b48459acb548ba","fromSide":"bottom","toNode":"54998e7db16967ce","toSide":"top"},
		{"id":"34d5e8adf94ed646","fromNode":"54998e7db16967ce","fromSide":"bottom","toNode":"cdd4125cbaabe293","toSide":"top"},
		{"id":"6642a35aafb9d025","fromNode":"a62175fca162f699","fromSide":"bottom","toNode":"a938b0ff11d7b889","toSide":"top"},
		{"id":"8f6de16cfdda85a7","fromNode":"0c9a892970f269ca","fromSide":"right","toNode":"1d8adf6f64990bd7","toSide":"left"},
		{"id":"0f9c0047af3f24b6","fromNode":"a938b0ff11d7b889","fromSide":"bottom","toNode":"cd95149f5a92fc20","toSide":"top"},
		{"id":"ea0735674da8ec1c","fromNode":"cd95149f5a92fc20","fromSide":"right","toNode":"9c78467e566cf6a0","toSide":"left"},
		{"id":"3134c8f71b003c3e","fromNode":"9c78467e566cf6a0","fromSide":"bottom","toNode":"356faa05390d77be","toSide":"top"},
		{"id":"6fa3957e3bbfecf2","fromNode":"356faa05390d77be","fromSide":"bottom","toNode":"2fe751ade5db6fb8","toSide":"top"},
		{"id":"649583e4c756c0da","fromNode":"2fe751ade5db6fb8","fromSide":"bottom","toNode":"7d432adff82390c9","toSide":"top"},
		{"id":"ae0c75e4d707a55f","fromNode":"9c78467e566cf6a0","fromSide":"right","toNode":"cacaf18627b02240","toSide":"left"},
		{"id":"87c051aad43f3dab","fromNode":"cacaf18627b02240","fromSide":"right","toNode":"e861401aeb0e211e","toSide":"left"},
		{"id":"662ab304c0d49a51","fromNode":"e861401aeb0e211e","fromSide":"right","toNode":"cb65917d8e1b625d","toSide":"left"},
		{"id":"a030112b2fb0541c","fromNode":"cd95149f5a92fc20","fromSide":"bottom","toNode":"6a0eeb7243ddf125","toSide":"top"},
		{"id":"2f84176a1a01ff3b","fromNode":"6a0eeb7243ddf125","fromSide":"right","toNode":"c3d92ee6d8d3641e","toSide":"left"},
		{"id":"3fd5deaa8f26ab2b","fromNode":"c3d92ee6d8d3641e","fromSide":"right","toNode":"f823f8a8a0757776","toSide":"left"},
		{"id":"690010c790de7f1e","fromNode":"f823f8a8a0757776","fromSide":"right","toNode":"73c3a28493a8412f","toSide":"left"},
		{"id":"0a977aad2ee52c3c","fromNode":"6a0eeb7243ddf125","fromSide":"bottom","toNode":"040f5e026598e266","toSide":"top"},
		{"id":"fd2361fdf9f5d890","fromNode":"040f5e026598e266","fromSide":"right","toNode":"7ddd9d514548715b","toSide":"left"},
		{"id":"34a55d75af309608","fromNode":"7ddd9d514548715b","fromSide":"bottom","toNode":"ed470972680d2519","toSide":"top"}
	]
}