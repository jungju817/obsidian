{
	"nodes":[
		{"id":"9f1d6e49787a6c68","type":"text","text":"FUZZING이란?","x":-140,"y":-80,"width":173,"height":58},
		{"id":"9c900e42d9fcaf9c","x":-315,"y":-22,"width":523,"height":270,"type":"text","text":"fuzzing이란 fuzz input을 사용해 PUT(Program Under Test)를 실행하는 것이고, fuzz input 이란 PUT가 예상하지 못할 input을 뜻한다. PUT이 잘못 처리하는 input 혹은 개발 의도와는 다른 행동을 보이는 input을 넣어 PUT을 실행하는 것이라고 볼 수 있다. 즉 fuzzing이란,\n\n자동화 테스트로 기형/반기형적 데이터를 주입하여 소프트웨어 버그를 찾는 블랙박스 테스팅 기술이다.\n\nPUT은 테스트 실행중인 프로그램이라고 해석하자"},
		{"id":"4a754ba8c8fce9e7","type":"text","text":"Fuzzing을 왜 쓰나?","x":-641,"y":-111,"width":191,"height":60},
		{"id":"a2c6337340a91558","x":-760,"y":-51,"width":429,"height":210,"type":"text","text":"결론적으로는 fuzzing을 통해 버그를 자동으로 찾을 수 있다는 것이다. 일반적인 정적분석으로도 버그를 찾을 수 있지만 많은 시간과 노력이 들며 자신의 실력에 따라 버그를 찾을 수도, 못 찾을 수 도 있다.\n\n그렇다고 fuzzing이 만능은 아니다. crash가 터져도 오탐일 가능성도 있고 익스가 불가능한 crash일 수도 있다."},
		{"id":"f21e9ec89e081239","type":"text","text":"Fuzzing의 한계","x":280,"y":-51,"width":191,"height":60},
		{"id":"b4970712e5cc9708","x":240,"y":9,"width":412,"height":138,"type":"text","text":"정확한 분석보다는 무작위성에 의존한다.\n\n메모리 손상같은 단순한 결함들은 쉽게 찾아내지만 로직 버그는 감지하기 매우 어렵다고 한다."},
		{"id":"36c53730800a8422","x":-1560,"y":-440,"width":742,"height":1417,"type":"text","text":"code coverage는 Fuzzing을 진행할 때 테스트가 얼마나 충분한가를 나타내는 지표이다.\n\n즉 테스트시 코드 자체가 얼마나 실행이 되었는지를 나타낸다.\n\n코드의 구조를 이루는 것은 크게 구문(Statement), 조건(Condition), 결정(Desision)이다.\n\n1. Statement / Line Coverage\n    \n    코드가 한번 이상 실행되면 충족된다.\n    \n    예를 들어서\n    \n    ```c\n    void func(int a)\n    {\n    \tprintf(\"START!\");   // (1)\n    \tif(a > 3)           // (2)\n    \t\tprintf(\"a > 3\\\\n\");  // (3)\n    \tprintf(\"END\");      // (4)\n    }\n    ```\n    \n    위 코드에서 func(2)가 실행 될 경우 (1),(2),(4) 는 실행되지만 (3)은 실행이 되지 않는다. 이럴 경우 Statement Coverage는 75%가 된다.\n    \n2. Condition\n    \n    각 분기문들에 대한 Coverage 이다.\n    \n    예를 들어서\n    \n    ```c\n    void func(int a, int b)\n    {\n    \tprintf(\"START!\");\n    \tif(a > 0 && b < 0)\n    \t\tprintf(\"good\");\n    \tprintf(\"END\");\n    }\n    ```\n    \n    위 코드의 조건식에서 Condition Coverage를 모두 만족하는 입력값은 func(1, 1)와 func(-1, -1) 이 존재한다.\n    \n    x > 0 의 조건식에서 true/false 를 모두 만족하고 y < 0 의 조건식에서 true/false 를 모두 만족한다.\n    \n    조건식은 무조건 false를 반환한다. 즉 조건의 실행여부를 측정한다고 보면 된다.\n    \n3. Desision / Branch Coverage\n    \n    모든 조건식이 true/false를 가지면 충족된다.\n    \n    예를 들어\n    \n    ```c\n    void func(int a, int b)\n    {\n    \tprintf(\"START\");\n    \tif( (a > 0) && (b > 0))\n    \t\tprintf(\"great\");\n    \tprintf(\"END\");\n    }\n    ```\n    \n    위 코드의 조건식에서 true/false 를 모두 가질 수 있는 입력값은 func(1, 1)와 func(0, 0) 이 있다. 첫 번째는 x > 0과 y > 0 을 모두 만족해 true를 반환, 두 번째는 x ≤ 0, y ≤ 0 을 만족해 false를 반환한다. 모든 조건식을 만족하니 Desision Coverage를 만족한다."},
		{"id":"07d626e8cf255726","type":"text","text":"Code Coverage","x":-1284,"y":-500,"width":191,"height":60},
		{"id":"a88ab1bbfb83b1b1","x":145,"y":-530,"width":175,"height":60,"type":"text","text":"Fuzzing의 구현"},
		{"id":"ff3265fc7ff563f9","x":86,"y":-470,"width":566,"height":150,"type":"text","text":"Fuzzer는 반무작위 데이터를 주입하고 버그를 탐지한다.\n\n데이터 생성은 생성기로, 취약점 탐지는 디버깅 도구에 의존한다. 생성기는 일반적인 퍼징 벡터(위험한 것으로 알려진 값 목록) 또는 완전 무작위의 데이터 조합을 사용한다.\n"},
		{"id":"75c9e449b781657d","x":-65,"y":358,"width":165,"height":62,"type":"text","text":"Fuzzing의 종류"},
		{"id":"ac9fb61fd2208a52","x":767,"y":-481,"width":250,"height":60,"type":"text","text":"공격 유형"},
		{"id":"3db2ad7d87c7420c","x":767,"y":-421,"width":470,"height":233,"type":"text","text":"##Fuzzer는 아래와 같은 공격조합을 시도한다.\n\n- numbers (signed/unsigned integers/ float …)\n- chars\n- metadata (사용자 입력)\n- pure binary sequences (이진 수열)\n\n이들을 재조합하여 주입한다."},
		{"id":"a20da1922ea56b13","x":-236,"y":420,"width":707,"height":340,"type":"text","text":"1. Blackbox Fuzzing\n\t   소스코드를 가지고 있지 않고 Binary 만을 이용하여 test한다.\n\t   입력 값은 무작위적이며 단순하다.\n\t   어플리케이션의 실행이 멈추거나(crash) 실행이 일시적으로 보류(hang)되면 테스트에서 실패한것으로 간주되고, 그렇지 않다면 테스트 통과이다.\n\t   단순하지만 취약점 발견확률이 낮다.\n2. Whitebox Fuzzing\n\t   소스코드가 필요하며 분석이 복잡하다.\n\t   Blackbox Fuzzing과 다른 종류의 취약점을 찾을 수 있다.\n3. Graybox Fuzzing\n\t   내부 프로그램의 구조를 부분적으로 알고있다.(데이터 구조체, 알고리즘 등)"},
		{"id":"2082f921870d4da8","x":520,"y":491,"width":584,"height":199,"type":"text","text":"### crash와 hang의 차이점\n\ncrash : 프로그램이 예기치 않게 완전히 중단되는 것을 의미한다.( 터짐 )\n\nhang : 프로그램이 응답을 멈추고 사용자의 입력이나 다른 프로세스에 대해 반응하지 않는 상태이다.( 무한 로딩 )"},
		{"id":"6e46b8ab2c764cea","x":-440,"y":840,"width":250,"height":60,"type":"text","text":"Fuzzer의 구성요소"},
		{"id":"a9611ca92a11f742","x":-645,"y":900,"width":660,"height":627,"type":"text","text":"fuzzer는 크게 3가지 부분으로 나뉜다.\n\n1. TestCase Generator\n    \n    테스트 케이스 생성을 담당한다. 즉 타겟 프로그램에 삽입할 입력을 만든다.\n    \n    1. Smart Fuzzer\n        \n        프로그램의 입력 데이터 구조를 파악하여 해당 구조에 맞게 Mutation을 진행한다.\n        \n    2. Dumb Fuzzer\n        \n        랜덤한 데이터를 생성하여 Mutation을 진행한다.\n        \n        \n2. Logger\n    \n    발견된 crash와 test case를 기록한다. coverage 기반 fuzzing일 경우 새롭게 찾은 코드 corverage도 저장을 한다. 이를 통해 crash가 발생한 로그를 확인하여 분석을 진행한다.\n    \n    \n3. Worker\n    \n    테스트케이스를 실행하는 주체이다. 또한 예상치 못한 동작을 파악해야한다. ASAN같은 도구를 이용해서 버그를 찾을 수 있다.\n    \n    \n4. Server/Master\n    \n    1,2,3을 컨트롤하고 상호작용을 관리한다."},
		{"id":"1d4b7a898a100272","x":173,"y":1184,"width":250,"height":60,"type":"text","text":"ASAN이란?"},
		{"id":"5501b97099b39ef6","x":118,"y":1244,"width":611,"height":372,"type":"text","text":"Address Sanitizer이란 잘못된 메모리 주소로의 접근 및 쓰기를 검출하는 것을 도와주는 도구이다. 이 도구는 런타임에 binding하는 도구와는 달리 컴파일 타임에 붙어 추가적인 코드를 삽입해주는 도구이다.\n\ngcc에서는 -fsanitizer=address 옵션을 주어서 쉽게 사용할 수 있다.\n\n기본적으로 stack에서 메모리 침범을 했을 때 갚을 덮어씌우는 시점에서 프로그램이 멈추지는 않는다. stack rewinding 도중에서야 값이 잘못 덮어씌워진 것을 확인하고 프로그램이 멈추게 된다.\n\n하지만 address sanitizer을 사용하면 잘못된 지역에 값을 덮어씌우는 시점에 바로 프로그램이 멈추면서 추가로 디버그 정보까지 보여준다.\n\n아무튼 runtime error을 탐지해주는 도구라고 볼 수 있다."},
		{"id":"5a796ef57e5aa433","x":1140,"y":113,"width":250,"height":60,"type":"text","text":"Fuzzing 방법"},
		{"id":"ac59bde896421c50","x":1140,"y":173,"width":1029,"height":556,"type":"text","text":"1. Guided Fuzzing\n\n\tTest Case의 생성을 Code Coverage를 넓히기 위해서 사용하는 방법이며, Test case에서 변경할 데이터를 정하고 그 부분의 데이터만 변경하는 것이다.\n\n2. Dumb Fuzzing\n\n\t랜덤한 데이터를 생성하여 대상 소프트웨어에 전달하는 방식으로 프로그램에 대한 이해도 없이도 진행할 수 있다.\n\n- Mutation Based Fuzzing\n    \n    알려진 test case를 변경하여 새로운 test case를 만든다. mutation의 방법으로는 비트플립, 랜덤화 등이 있다. dumb fuzzing의 일종이다.\n    \n    \n\n3. Smart Fuzzing\n\n\t입력에 대한 구조를 미리 파악하고 그것에 맞춰 적절한 테스트 케이스(받아들일 수 있는 입력)를 생성한다.\n\n- Generation Based Fuzzing\n    \n    입력가능한 공간에 대한 모델을 기반으로 test case를 만든다.\n    \n    PUT의 입력 형태를 고려한 model이 있다.\n    \n\n\t더 높은 Code Coverage를 가진다."},
		{"id":"07bcd1e569c49922","x":2440,"y":426,"width":167,"height":50,"type":"text","text":"mutation 종류"},
		{"id":"7af465a42b7d9769","x":2440,"y":476,"width":876,"height":766,"type":"text","text":"## Bit-Flipping\n\nBit-flipping 은 많은 변이 기반 퍼저들이 사용하는 기법이다.\n\n고정된 수의 비트 수만큼만 플립 하는 경우도 있고, 플립 할 비트 수를 랜덤하게 정하는 경우도 있다.\n\n## Arithmetic Mutation\n\n선택된 byte sequence를 integer로 취급하여 그 값에 간단한 산술(:arithmetic)연산을 수행하는 변이 기법이다.\n\n계산된 값은 선택된 byte sequence를 대체하는데 사용한다. 변이하는 크기를 작게 제한하는 것이 중요하다.\n\n## Block-based Mutation\n\n시드의 byte sequence를 block이라고 하자. 몇 가지 블록 기반 변이 기법이 있다.\n\n1. 랜덤하게 생성된 블록을 시드의 랜덤 한 위치에 삽입하는 방법. (AFL, LibFuzzer)\n2. 시드에서 랜덤하게 선택된 블록을 제거하는 방법. (AFL, radamsa, honggfuzz, LibFuzzer)\n3. 랜덤하게 선택된 블록을 랜덤 한 값으로 대체하는 방법. (AFL, honggfuzz, radamsa, LibFuzzer)\n4. 일련의 블록들의 순서를 임의로 바꾸는 방법. (radamsa, LibFuzzer)\n5. 랜덤 한 블록을 시드 뒤에 추가하는 방법. (honggfuzz)\n6. 시드끼리 랜덤 한 블럭을 추가하거나 삽입하는 방법. (AFL], LibFuzzer)\n\n## Dictionary-based Mutation\n\n0이나 -1과 같이 잠재적으로 중요한 의미론적 가중치 set을 미리 정의해서 사용하거나 변이를 위한 format string을 사용하는 fuzzer도 있다."},
		{"id":"049b5bff11edd6fe","x":-700,"y":-1217,"width":250,"height":60,"type":"text","text":"Fuzzing Tools"},
		{"id":"9c3780537647e998","x":-700,"y":-1157,"width":753,"height":627,"type":"text","text":"Radamsa - 이 샛기는 fuzzer가 아님, mutator 임,(입력을 안함)\n\tRadamsa는 Sample File을 기반으로 자동으로 Mutation을 진행한다. Mutation-Based Fuzzer로 분류되고 있다.\n\nAFL ** 내가 사용할 것!!\n\tCode Coverage-Based, Mutation-Based, Dumb Fuzzer 이다. 입력에 대한 구조를 알 필요가 없지만 해당 Fuzzer 에서 자동으로 데이터 구조를 파악해 Mutation을 진행하는 특징을 가지고 있다.\n\nPeach Fuzzer\n\t데이터 구조와 변경할 데이터를 지정해 Fuzzing을 진행하는 Smart Fuzzer 이다.\n\nlibFuzzer\n\tcoverage-guide in-process fuzzing engine In process fuzzing은 한 프로세스에서만 발생하는 fuzzing 기술\n\ndomato - 이 샛기도 그냥 mutator\n\tDOM fuzzer, html 등의 파일을 대상으로 mutate\n\nHonhhfuzzer\n\tgoogle에서 관리하는 프로젝트이다. \n\t멀티 스레드와 멀티 프로세스를 사용한다. \n\topenSSL 즉 오픈 소스로 개발된 라이브러리를 target으로 하는 fuzzer이다.\n\nzzuf\n\t다양한 프로그램 유형의 파일에 적용된다. 특히 네트워크 프로토콜도 가능하다."}
	],
	"edges":[
		{"id":"2869353db0604366","fromNode":"9f1d6e49787a6c68","fromSide":"top","toNode":"a88ab1bbfb83b1b1","toSide":"left"},
		{"id":"544d49d3467e0add","fromNode":"9f1d6e49787a6c68","fromSide":"right","toNode":"f21e9ec89e081239","toSide":"top"},
		{"id":"3790b9f95dd7fe3b","fromNode":"9f1d6e49787a6c68","fromSide":"left","toNode":"4a754ba8c8fce9e7","toSide":"top"},
		{"id":"10f1c846eb21b966","fromNode":"9f1d6e49787a6c68","fromSide":"top","toNode":"07d626e8cf255726","toSide":"top"},
		{"id":"0eda62c143a2f143","fromNode":"9c900e42d9fcaf9c","fromSide":"top","toNode":"75c9e449b781657d","toSide":"top"},
		{"id":"80735714171a1a18","fromNode":"a88ab1bbfb83b1b1","fromSide":"right","toNode":"ac9fb61fd2208a52","toSide":"left"},
		{"id":"00b0b8b193dcfcc2","fromNode":"a20da1922ea56b13","fromSide":"right","toNode":"2082f921870d4da8","toSide":"left"},
		{"id":"643c04014e9504c2","fromNode":"9c900e42d9fcaf9c","fromSide":"top","toNode":"6e46b8ab2c764cea","toSide":"top"},
		{"id":"19fbbb7c1a449dd1","fromNode":"a9611ca92a11f742","fromSide":"right","toNode":"1d4b7a898a100272","toSide":"left"},
		{"id":"06013df6bbca32ea","fromNode":"9c900e42d9fcaf9c","fromSide":"top","toNode":"5a796ef57e5aa433","toSide":"left"},
		{"id":"f3a17ed24f85ef4e","fromNode":"ac59bde896421c50","fromSide":"right","toNode":"07bcd1e569c49922","toSide":"left"},
		{"id":"cc2b7d6360b83eb1","fromNode":"9f1d6e49787a6c68","fromSide":"top","toNode":"049b5bff11edd6fe","toSide":"top"}
	]
}