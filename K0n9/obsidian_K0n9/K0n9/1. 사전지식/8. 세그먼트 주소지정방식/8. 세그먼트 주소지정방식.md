카나리를 보면 이상한 부분을 볼 수 있다.
![](https://i.imgur.com/rCn5zTV.png)

fs:0x28 부분이다.
fs는 세그먼트 레지스터인데 뭔가 값을 가져오는 방법이 이상하다. 
우리는 여기서 세그먼트 주소지정방식에 대해서 알아야한다.

그리고 겸사겸사 fs, gs 등이 왜 0인지를 알아보자

### 16bit 일때
IBM에서 컴퓨터를 처음 만들때 RAM을 1Mbyte정도로 고정했다. 이때는 이게 최대 크기였기 때문이다. 1Mbyte는 20 bit 인데 이때 16bit 레지스터인 세그먼트 레지스터는 4비트가 모자르게 되었다. 그래서 오프셋이라는 주소체계가 나왔다.

FFFF : 0000  = FFFF0
세그먼트 : 오프셋
(hex) : (bit)

이러한 방식을 가진다.
그래서 segment:offset 구조로 되어있으면 segment주소를 4비트 쉬프트하고 offset을 더해주면 된다.

### 32bit 일때
세그먼트 레지스터의 값은 GDT에 존재하는 세그먼트 디스크립터의 위치이다. GDT에는 세그먼트를 기술하는 세그먼트 디스크립터들이 여러개 존재하고 세그먼트 디스크립터에는 세그먼트의 기준주소, 권한, 크기 등이 설정되어있다. 이때 첫번째 세그먼트 디스크립터는 NULL 디스크립터로 사용되지 않는 디스크립터다. 그리고 이 GDT 는 커널메모리에 존재하기 때문에 유저입장에서 바로 참조할 수는 없고, 커널을 통해서만 접근할 수있다.

그러니까 **FS 레지스터에 0이 들어갔다는 것은 단순히 GDT에 있는 첫번째 세그먼트 디스크립터를 참조하겠다는 뜻이다**. 만약 스레드가 바뀌어서 TLS의 주소도 바뀌게 되면 FS 레지스터의 값을 바꾸어서 다른 세그먼트를 지정해주던지, GDT에 있는 세그먼트 디스크립터를 수정해서 세그먼트의 시작주소, 크기등을 새로 지정해주어야 한다. 물론 이는 스레드 라이브러리와 운영체제간의 정해진 규약(시스템 콜)을 이용해서 이루어진다.

### 64bit 일때
위에서 잠시 세그먼테이션 메모리 기법에 대해서 언급했는데, 혹시 저렇게 메모리 관리를 하는 운영체제를 본적이 있는가? 윈도우/리눅스 모두 64비트 기준으로는 페이징 기법을 이용해서 메모리 관리를 하고 있고, CPU개발사들도 이걸 알았는지 그냥 세그먼테이션 기법 쓰지 말라고 비활성화 해버렸다. 32비트때도 아무도 안쓰니까 64비트에서는 비활성화 해버린거다.  
단 FS/GS 레지스터는 예외로 TLS 같은 경우를 위해서 남겨두었지만, 베이스주소만 설정되고 크기 체크는 무시된다(이 크기체크는 페이징기법을 이용해 체크된다).

그래도 FS 레지스터가 0일 이유는 없다. 첫번째 디스크립터가 NULL 디스크립터인 것이 바뀌지는 않았으니까.

디버거에서 x/x $fs_base를 하면 쉬프트를 한 값으로 나와서 그냥 그 값에 오프셋만큼 더하면 된다.